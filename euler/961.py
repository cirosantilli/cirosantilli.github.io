#!/usr/bin/env pypy3

# Generated by GPT-5 on 2025-11-05. Tested on Ubuntu 25.04, pypy3 3.11.11. Runtime on Lenovo ThinkPad P14s: 0m1.512s

from __future__ import annotations
from functools import lru_cache
from itertools import product
from typing import Tuple


def normalize(s: str) -> str:
    """Remove leading zeros. If empty, return '0'."""
    s = s.lstrip('0')
    return s if s != '' else '0'


def is_terminal(s: str) -> bool:
    """Return True if the string has no nonzero digits."""
    return all(ch == '0' for ch in s)


@lru_cache(maxsize=None)
def first_player_wins(s: str) -> bool:
    """
    Return True if the player to move has a forced win from string s.
    s: decimal string representing current number (no leading zeros except '0').
    """
    if is_terminal(s):
        # No nonzero digits left; previous move already won
        return False

    n = len(s)
    for i in range(n):
        new_s = s[:i] + s[i+1:]

        # If this move removes the last nonzero digit, current player wins
        if not any(ch != '0' for ch in new_s):
            return True

        new_s_norm = normalize(new_s)

        # If the opponent loses from the new state, current player wins
        if not first_player_wins(new_s_norm):
            return True

    # No winning move found
    return False


@lru_cache(None)
def wins_for_pattern(pattern: Tuple[int, ...]) -> bool:
    """
    pattern: tuple of 0/1 (1 = nonzero digit, 0 = zero digit),
             with pattern[0] == 1 (no leading zero).
    Returns True if the player to move can force a win.
    The actual values of the nonzero digits don't matter,
    only their positions.
    """
    s = ''.join('1' if b else '0' for b in pattern)
    return first_player_wins(s)


@lru_cache(None)
def W_digits_weighted(d: int) -> int:
    """
    Compute the number of winning integers with exactly d digits.
    Each nonzero digit can be any of 1..9, so a pattern with k ones
    represents 9^k concrete integers.
    """
    total = 0
    for bits in product([0, 1], repeat=d):
        if bits[0] == 0:
            continue  # skip patterns with a leading zero
        if wins_for_pattern(bits):
            k = sum(bits)  # number of nonzero digits
            total += 9 ** k
    return total


def W(N: int) -> int:
    """
    Return W(N): count of positive integers < N for which
    the first player has a winning strategy (given optimal play).

    This implementation is specialized for N that are powers of 10.
    For N = 10^k, it sums over all digit lengths 1..k.
    """
    if N <= 0:
        return 0

    # Require N to be an exact power of 10
    # (Project Euler 961 uses N = 10^k, including 10^18).
    tmp = N
    k = 0
    while tmp % 10 == 0:
        tmp //= 10
        k += 1

    if tmp != 1:
        raise ValueError("This implementation of W(N) currently expects N to be a power of 10.")

    total = 0
    for d in range(1, k + 1):
        total += W_digits_weighted(d)
    return total

if __name__ == "__main__":
    assert W(100) == 18
    assert W(10**4) == 1656
    print(W(10**18))

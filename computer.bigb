= Computer

The artistic instrument that enables the ultimate <art>: coding, See also: <the art of programming>{full}.

Much more useful than instruments used in inferior arts, such as pianos or paintbrushes.

Unlike other humans, computers are mindless slaves that do exactly what they are told to, except for https://www.youtube.com/watch?v=aNzTUdOHm9A[occasional cosmic ray bit flips]. Until they <artificial general intelligence>[take over the world that is].

\Video[https://www.youtube.com/watch?v=rTRzYjoZhIY]
{title=A <computer> is the equivalent of a bicycle for our minds by <Steve Jobs> (1980)}
{description=Likely an excerpt from an interview done for a documentary in 1980. TODO exact source.}

\Video[https://www.youtube.com/watch?v=8KZdA2O3H1k]
{title=<Steve Jobs> talking about the <Internet> (1995)}
{description=
\Q[[The web is incredibly exciting, because it is the fulfillment of a lot of our dreams, that the computer would ultimately primarily not be a device for computation, but [sic] metamorphisize into a device for communication.]]
also:
\Q[Secondly it exciting because <Microsoft> doesn't own it, and therefore there is a tremendous amount of innovation happening.]
then he talks about the impending role for online sales. <Amazon> incoming.

Computers basically have two applications:
* computation
* communication. Notably, computers through the <Internet> allow for modes of communication where:
  * both people don't have to be on the same phone line at the exact same time, a server can relay your information to other people
  * anyone can broadcast information easily and for almost free, again due to servers being so good at handling that
Generally, the smaller a computer, the more it gets used for communication rather than computing.

The early computers were large and expensive, and basically only used for computing. E.g. <ENIAC> was used for calculating ballistic tables.

Communication only came later, and it was not obvious to people at first how incredibly important that role would be.

This is also well illustrated in the documentary <Glory of the Geeks>. Full interview at: https://www.youtube.com/watch?v=TRZAJY23xio[]. It is apparently known as the "Lost Interview" and it was by Cringely himself: https://www.youtube.com/watch?v=bfgwCFrU7dI[] for his <Triumph of the Nerds> documentary.
}

= The art of programming
{parent=Computer}
{tag=Essays by Ciro Santilli}

Big goals:
* the pursuit of <AGI>
* <computational physics>[physics simulations], including <scientific visualization software>
* <formalization of mathematics>

Just <art>:
* useless mathy stuff
* incredibly nifty little tools that are just so satisfying to use it is mind blowing:
  * <ncdu>
  * <GNU parallel>
* media related stuff
  * <ffmpeg> one liners!

= How computers work?
{parent=Computer}
{tag=Essays by Ciro Santilli}

= Computer abstraction layer
{synonym}

A computer is a highly layered system, and so you have to decide which layers you are the most interested in studying.

Although the layer are somewhat independent, they also sometimes interact, and when that happens it usually hurts your brain. E.g., if <compilers> were perfect, no one optimizing software would have to know anything about <microarchitecture>. But if you want to go hardcore enough, you might have to learn some lower layer.

It must also be said that like in any industry, certain layers are hidden in commercial secrecy mysteries making it harder to actually learn them. In computing, the lower level you go, the more <closed source> things tend to become.

But as you climb down into the abyss of low level hardcoreness, don't forget that <backward design>[making usefulness is more important than being hardcore]: <image xkcd 378: Real Programmers>.

First, the most important thing you should know about this subject: https://cirosantilli.com/linux-kernel-module-cheat/should-you-waste-your-life-with-systems-programming

Here's a summary from low-level to high-level:
* <semiconductor physical implementation> this level is of course the most closed, but it is fun to try and peek into it from any openings given by commercials and academia:
  * <photolithography>, and notably <photomask> design
* <register transfer level>
  * interactive <verilator> fun: https://stackoverflow.com/questions/38108243/is-it-possible-to-do-interactive-user-input-and-output-simulation-in-vhdl-or-ver/38174654#38174654[Is it possible to do interactive user input and output simulation in VHDL or Verilog?]
  * more importantly, and much harder/maybe impossible with <open source>, would be to try and set up a open source <standard cell library> and supporting software to obtain <power, performance and area> estimates
    * https://www.quora.com/Are-there-good-open-source-standard-cell-libraries-to-learn-IC-synthesis-with-EDA-tools/answer/Ciro-Santilli[Are there good open source standard cell libraries to learn IC synthesis with EDA tools?] on <Quora>
    * the most open source ones are some initiatives targeting FPGAs, e.g. https://symbiflow.github.io/[], http://www.clifford.at/icestorm/[]
    * <qflow> is an initiative targeting actual <integrated circuits>
* <microarchitecture>: a good way to play with this is to try and run some minimal userland examples on <gem5> userland simulation with logging, e.g. see on the <Linux Kernel Module Cheat>:
  * https://cirosantilli.com/linux-kernel-module-cheat/gem5-event-queue-derivo3cpu-syscall-emulation-freestanding-example-analysis
  This should be done at the same time as books/website/courses that explain the microarchitecture basics.

  This is the level of abstraction that <Ciro Santilli> finds the most interesting of the hardware stack. Learning it for actual <CPUs> (which as of 2020 is only partially documented by vendors) could actually be useful in hardcore software optimization use cases.
* <instruction set architecture>: a good approach to learn this is to manually write some userland assembly with assertions as done in the <Linux Kernel Module Cheat> e.g. at:
  * https://github.com/cirosantilli/linux-kernel-module-cheat/blob/9b6552ab6c66cb14d531eff903c4e78f3561e9ca/userland/arch/x86_64/add.S
  * https://cirosantilli.com/linux-kernel-module-cheat/x86-userland-assembly
  * learn a bit about calling conventions, e.g. by calling C standar library functions from assembly: 
    * https://github.com/cirosantilli/linux-kernel-module-cheat/blob/9b6552ab6c66cb14d531eff903c4e78f3561e9ca/userland/arch/aarch64/inline_asm/linux/asm_from_c.c
    * https://stackoverflow.com/questions/16255608/calling-c-functions-from-x86-assembly-language/56328708#56328708[Calling C functions from x86 assembly language]
  * you can also try and understand what some simple <C (programming language)> programs <compile> to. Things can get a bit hard though when `-O3` is used. Some cute examples:
    * https://stackoverflow.com/questions/310974/what-is-tail-call-optimization/55230417#55230417[What is tail call optimization?]
    * https://stackoverflow.com/questions/1345670/stack-smashing-detected/51897264#51897264[What is the "Stack smashing detected" error in GCC and how to solve it?]
    * https://stackoverflow.com/questions/745870/realistic-usage-of-the-c99-restrict-keyword/30827311#30827311[Realistic usage of the C99 'restrict' keyword?]
* <executable file format>, notably <executable and Linkable Format>. Particularly important is to understand the basics of:
  * address relocation:  https://stackoverflow.com/questions/3322911/what-do-linkers-do/33690144#33690144[How do linkers and address relocation work?]
  * position independent code: https://stackoverflow.com/questions/2463150/what-is-the-fpie-option-for-position-independent-executables-in-gcc-and-ld/51308031#51308031[What is the -fPIE option for position-independent executables in GCC and ld?]
  * how to observe which symbols are present in object files, e.g.:
    * how C++ uses name mangling https://stackoverflow.com/questions/1041866/what-is-the-effect-of-extern-c-in-c/30526795#30526795[What is the effect of extern "C" in C++?]
    * how C++ template instantiation can help reduce link time and size: https://stackoverflow.com/questions/2351148/explicit-template-instantiation-when-is-it-used/59614755#59614755[Explicit template instantiation - when is it used?]
* <operating system>. There are two ways to approach this:
  * learn about the Linux kernel <Linux kernel>. A good starting point is to learn about its main interfaces. This is well shown at <Linux Kernel Module Cheat>:
    * system calls
      * write some system calls in
        * pure assembly:
          * https://github.com/cirosantilli/linux-kernel-module-cheat/blob/9b6552ab6c66cb14d531eff903c4e78f3561e9ca/userland/arch/x86_64/freestanding/linux/hello.S
          * https://stackoverflow.com/questions/174942/how-should-strace-be-used/55397255#55397255[How should strace be used?]
        * C GCC inline assembly:
          * https://stackoverflow.com/questions/9506353/how-to-invoke-a-system-call-via-syscall-or-sysenter-in-inline-assembly/54956854#54956854
          * https://github.com/cirosantilli/linux-kernel-module-cheat/blob/9b6552ab6c66cb14d531eff903c4e78f3561e9ca/userland/arch/x86_64/inline_asm/freestanding/linux/hello.c
    * learn about kernel modules and their interfaces. Notably, learn about to demystify special files such `/dev/random` and so on:
      * https://stackoverflow.com/questions/22632713/how-to-write-a-simple-linux-device-driver/44640466#44640466
      * https://github.com/cirosantilli/linux-kernel-module-cheat/tree/9b6552ab6c66cb14d531eff903c4e78f3561e9ca/kernel_modules
    * learn how to do a minimal Linux kernel disk image/boot to userland hello world: https://unix.stackexchange.com/questions/2692/what-is-the-smallest-possible-linux-implementation/203902#203902[What is the smallest possible Linux implementation?]
    * learn how to GDB <Step debug the Linux kernel> itself. Once you know this, you will feel that "given enough patience, I could understand anything that I wanted about the kernel", and you can then proceed to not learn almost anything about it and carry on with your life
  * write your own (mini-) OS, or study a minimal educational OS, e.g. as in:
    * <x86 bare metal examples>
    * https://stackoverflow.com/questions/22054578/how-to-run-a-program-without-an-operating-system/32483545#32483545
* <programming language>

\Image[https://web.archive.org/web/20191222121520if_/http://imgs.xkcd.com/comics/real_programmers.png]
{height=600}
{title=<xkcd> 378: Real Programmers}
{source=https://xkcd.com/378/}

\Video[https://youtube.com/watch?v=_6D05gCWh_I]
{title=How low can you go video by <Ciro Santilli> (2017)}
{description=In this infamous video Ciro has summarized the computer hierarchy.}

= The lower level you go into a computer, the harder it is to observe things
{parent=How computers work?}
{wiki}

This is a general principle of software/hardware design that Ciro feels holds wide applicability.

The most extreme case of this is of course the <integrated circuit> itself, in which it is essentially impossible (?) to observe the specific value of some indidual wire at some point.

Somewhat on the other extreme, we have high level programming languages running on top of an <operating system>: at this point, you can just <GDB step debug> your program, print the value of any variable/memory location, and fully understand anything that you want. Provided that you manage to easily reach that point of interest.

And for anything in between we have various intermediate levels of complication. The most notable perhaps being developing the operating system itself. At this level, you can't so easily step debug (although <Step debug the Linux kernel>[techniques do exist]). For early boot or <bootloaders> for example, you might want to use <JTAG> for example on real hardware.

In parallel to this, there is also another very important pair of closely linked tradeoffs:
* the lower level at which something is implemented, the faster it runs
* <emulation> gives you observability back, at the cost of slower runtime

Emulation also has another potential downside: unless you are very careful at implementing things correctly, your model might not be representative of the real thing. Also, there may be important tradeoffs between how much the model looks like the real thing, and how fast it runs. For example, <QEMU>'s use of <binary translation> allows it to run orders of magnitude faster than <gem5>. However, you are unable to make any predictions about system performance with QEMU, since you are not modelling key elements like the cache or CPU pipeline.

<Instrumentation (computer programming)> is another technique that has can be considered to achieve greater observability.

= Instrumentation
{disambiguate=computer programming}
{parent=The lower level you go into a computer, the harder it is to observe things}

= Instrumentation
{disambiguate=software}
{synonym}

Instrumentation basically means adding loggers/print statements to certain points of interest of your hardware/software.

Instrumentation tends to slow execution down a bit, but way less than <emulation>.

The downside is that if the instrumentation does not provide you the data you need to debug, there's not much you can do, you will need to modify it, i.e. you don't get full visibility from instrumention.

This is unlike emulation that provides full observability.

= Computer architecture
{parent=How computers work?}
{wiki}

The term loosely refers to certain layers of the <computer abstraction layers> hierarchy, usually high level hardware internals like <CPU> pipeline, caching and the memory system. Basically exactly what <gem5> models.

= Analog computer
{parent=Computer}
{tag=Analog electronics}
{wiki}

Some of the earlier computers of the 20th centure were analog, not digital.

At some point analog died however, and "computer" basically by default started meaning just "<digital computer>".

As of the 2010's and forward, with the limit of <Moore's law> and the rise of <machine learning>, people have started looking again into analog computing as a possile way forward. A key insight is that huge floating point precision is not that crucial in many <deep learning> applications, e.g. many new digital designs have tried <16-bit floating point> as opposed to the more traditional 32-bit minium. Some papers are even looking into 8-bit: https://dl.acm.org/doi/10.5555/3327757.3327866

As an example, the <Lightmatter> company was trying to implement <silicon photonics>-based matrix multiplication.

A general intuition behind this type of development is that the <human brain>, the holy grail of <machine learning>, is itself an <analog computer>.

= Digital computer
{parent=Analog computer}

= Computer benchmark
{parent=Computer}
{wiki}

* <CPU> benchmark: https://askubuntu.com/questions/634513/cpu-benchmarking-utility-for-linux/701532#701532
* <GPU> benchmark: https://askubuntu.com/questions/31913/how-to-perform-a-detailed-and-quick-3d-performance-test

= stress-ng
{parent=Computer benchmark}

The interface is a bit annoying, but the tool is really cool.

100 cycles of `matrixprod`:
``
stress-ng -c1 --cpu-ops 100 --cpu-method matrixprod
``
`man stress-ng` gives the list of possible `--cpu-method`. It documents `matrixprod` as:
\Q[<matrix product> of two 128 × 128 matrices of double floats. Testing on 64 bit <x86> hardware shows that this is provides a good mix of memory, cache and floating point operations and is probably the best CPU method to use to make a CPU run hot.]

If you don't specify the `--cpu-method` it apparently loops through every method one by one.

Limit time to 1s instead of limiting cycles:
``
stress-ng -c1 -t1 --cpu-method matrixprod
``

= Computer company
{parent=Computer}
{tag=Company}
{wiki}

This section is about companies that were primarily started as computer makers.

For companies that make <integrated circuits>, see also: <semiconductor company>{full}.

\Include[apple-inc]{parent=Computer company}

= Fujitsu
{c}
{parent=Computer company}
{tag=Japanese company}
{title2=Japanese IBM}
{wiki}

= 富士通
{synonym}
{title2}

The japanese name literally means:
* 富士 fushi, from Mount Fuji, which itself has unknown origin
* 通 tong: telecommunications

= International Computers Limited
{c}
{parent=Computer company}
{tag=European Tower of Babel}
{title2=ICL, British IBM}
{wiki}

They died so completely, <Googling> "ICL" now has higher hits such as <Imperial College London>.

\Video[https://www.youtube.com/watch?v=EkTHDgYTh64]
{title=Why the UK's <IBM> Failed by <Asianometry> (2022)}
{description=Main lesson perhaps: don't put national money to fight already established markets. You have to fight for what is coming up next. E.g. that is part of the reason for <TSMC>'s success.}

= IBM
{c}
{parent=Computer company}
{wiki}

As of the 2020's, a slumbering giant.

But the pre-Internet impact of IBM was insane! Including notably:
* some of the most important business computers of the pre-<personal computer> era
* <SQL>
* <IBM Generalized Markup Language>, which is a predecessor to <XML> and <HTML>

= IBM product
{c}
{parent=IBM}

= IBM System/360
{c}
{parent=IBM product}
{title2=1964}
{wiki}

This is a family of computers. It was a big success. It appears that this was a big unification project of previous architectures. And it also gave software portability guarantees with future systems, since writing software was starting to become as expensive as the hardware itself.

Media:
* https://youtu.be/qwocVH3_1Eo?t=841 from <video Inside the WILD Lab of CuriousMarc by Keysight Labs (2022)>.

= IBM 650
{c}
{parent=IBM product}
{title2=1954}
{wiki}

This was the first major commercial computer hit. Stlil <vacuum tube>-based.

\Video[https://www.youtube.com/watch?v=8Il6SkRdZ84]
{title=Learning how to program on the IBM 650 <Donald Knuth> interview by <Web of Stories> (2006)}
{description=It was decimal!}

= IBM 1401
{c}
{parent=IBM product}
{title2=1959}

\Video[https://www.youtube.com/watch?v=uFQ3sajIdaM]
{title=The IBM 1401 compiles and runs <FORTRAN> II by <CuriousMarc> (2018)}

= IBM 700/7000 series
{c}
{parent=IBM product}
{title2=1953-1970}
{wiki}

= IBM 705
{c}
{parent=IBM 700 7000 series}

= IBM Personal Computer
{c}
{parent=IBM}
{wiki}

= IBM PC
{c}
{synonym}

= Computer engineer
{parent=Computer}
{tag=Engineer}
{wiki}

= Gordon Moore
{c}
{parent=Computer engineer}
{wiki}

= Robert Noyce
{c}
{parent=Computer engineer}
{wiki}

= Robert Noyce: The Man Behind the Microchip by Leslie Berlin (2006)
{c}
{parent=Robert Noyce}
{tag=Good book}

Borrow from the <Internet Archive> for free: https://archive.org/details/manbehindmicroc000berl/page/n445/mode/2up

= Seymour Cray
{c}
{parent=Computer engineer}
{wiki}

= Cray
{c}
{parent=Seymour Cray}
{wiki}

= The Supermen: The Story of Seymour Cray by Charles J. Murray (1997)
{c}
{parent=Seymour Cray}
{tag=Good book}

Borrow from the <Internet Archive> for free: https://archive.org/details/supermenstory00murr

Initial chapters put good clarity on the formation of the <military-industrial complex>. Being backed by the military, especially just after <World War II>, was in itself enough credibility to start and foster a company.

It is funny to see how the first computers were very artisanal, made on a one-off basis.

Amazing how Control Data Corporation raised capital IPO style as a startup without a product. The dude was selling shares at dinner parties in his home.

Very interesting mention on page 70 of how <Israel> bought CDC's https://en.wikipedia.org/wiki/UNIVAC_1103[UNIVAC 1103] which Cray contributed greatly to design, and everyone knew that it was to make <thermonuclear weapons>, since that was what the big American labs like this mention should be added to: https://en.wikipedia.org/wiki/Nuclear_weapons_and_Israel but that's Extended Protected... the horrors of <Wikipedia>.

Another interesting insight is how "unintegrated" computers were back then. They were literally building computers out of individual <vacuum tubes>, then individual semiconducting transistors, a gate at a time. Then things got more and more integrated as time went. That is why the now outdated word "microprocessor" existed. When processors start to fit into a single <integrated circuit>, they were truly micro compared to the monstrosities that existed previously.

Also, because integration was so weak initially, it was important to more manually consider the length of wire signals had to travel, and try to put components closer together to reduce the <critical path> to be able to increase clock speeds. These constraints are also of course present in modern computer design, but they were just so much more visible in those days.

The book does unfortunately not give much detail in Crays personal life as mentioned on this book review: https://www.goodreads.com/review/show/1277733185?book_show_action=true[]. His childhood section is brief, and his wedding is described in one paragraph, and divorce in one sentence. Part of this is because he was very private about his family most likely note how Wikipedia had missed his first wedding, and likely misattribute children to the second wedding; https://en.wikipedia.org/wiki/Talk:Seymour_Cray section "Weddings and Children".

Crays work philosophy is is highlighted many times in the book, and it is something worthy to have in mind:
* if a design is not working, start from scratch
* don't be the very first pioneer of a technology, let others work out the problems for you first, and then come second and win

Cray's final downfall was when he opted to try to use a promising but hard to work with material <gallium arsenide> instead of <silicon> as his way to try and speed up computers, see also: <gallium arsenide vs silicon>. Also, he went against the extremely current of the late 80's early 90's pointing rather towards using massively parallel systems based on <silicon> off-the-shelf <Intel> processors, a current that had <DARPA> support, and which by far the path that won very dramatically as of 2020, see: <Intel supercomputer market share>.

= Computer graphics
{parent=Computer}

= 2D computer graphics
{parent=Computer graphics}
{wiki}

= 3D computer graphics
{parent=Computer graphics}
{wiki}

= 3D graphics
{synonym}

= Computer network
{parent=Computer}
{wiki}

= Computer network software
{parent=Computer network}

= Nmap
{c}
{parent=Computer network software}
{wiki}

= OSI model
{c}
{parent=Computer network}
{wiki}

= Physical layer
{parent=OSI model}
{wiki}

= Bluetooth
{c}
{parent=Physical layer}
{title2=1997}
{wiki}

= Ethernet
{c}
{parent=Physical layer}
{title2=1980}
{wiki}

= Ethernet cable
{c}
{parent=Ethernet}

https://en.wikipedia.org/wiki/Category:Ethernet_cables

= Sneakernet
{parent=Physical layer}
{wiki}

= Universal asynchronous receiver-transmitter
{c}
{parent=Physical layer}
{wiki}

= UART
{c}
{synonym}
{title2}

A good project to see UARTs at work in all their beauty is to connect two <Raspberry Pis> via UART, and then:
* type in one and see characters appear in the other: https://scribles.net/setting-up-uart-serial-communication-between-raspberry-pis/
* send data via a script: https://raspberrypi.stackexchange.com/questions/29027/how-should-i-properly-communicate-2-raspberry-pi-via-uart

Part of the beauty of this is that you can just connect both boards directly manually with a few wire-to-wire connections with simple <jump wire>. Its simplicity is just quite refreshing. Sure, you could do something like that for any physical layer link presumably...

Remember that you can only have one <GNU screen> connected at a time or else they will mess each other up: https://unix.stackexchange.com/questions/93892/why-is-screen-is-terminating-without-root/367549#367549

On <Ubuntu 22.04> you can screen without <sudo> by adding yourself to the `dialout` group with:
``
sudo usermod -a -G dialout $USER
``

= Wi-Fi
{c}
{parent=Physical layer}
{title2=2-6 GHz, 1997}
{wiki}

= Wifi
{c}
{synonym}

The frequency range of Wi-Fi, which falls in the <microwave> range, is likely chosen to allow faster data transfer than say, <FM broadcasting>, while still being relatively <transparent> to walls (though not as much).

= Internet
{c}
{parent=Computer network}
{wiki}

\Video[https://www.youtube.com/watch?v=XpZ5STahhPE]
{title=Are YOU Ready for the INTERNET? by <BBC> (1994)}

= Online
{synonym}

= ARPANET
{c}
{parent=Internet}
{title2=1970}
{wiki}

Bibliography:
* some good interview excerpts with some of the pioneers on <Glory of the Geeks>

= Interface Message Processor
{c}
{parent=ARPANET}
{title2=IMP}
{wiki}

= URL
{c}
{parent=Internet}
{title2=Uniform Resource Locator}
{wiki}

= Internet protocol suite
{c}
{parent=Internet}
{wiki}

= TCP/IP
{c}
{synonym}
{title2}

= MAC address
{c}
{parent=Internet protocol suite}
{wiki}

Hardcoded and unique network addresses for every single device on <Earth>.

Started with 48 bits (6 bytes), usually given as 01:23:45:67:89:AB but people now encouraged to use 64-bit ones.

How they are assigned: https://www.quora.com/How-are-MAC-addresses-assigned Basically <IEEE> gives out the 3 first bytes to device manufacturers that register, this is called the <organizationally unique identifier>, and then each manufacturer keeps their own devices unique.

= Organizationally unique identifier
{parent=MAC address}
{wiki}

= Internet Protocol
{c}
{parent=Internet protocol suite}
{title2=IP}
{wiki}

= IP address
{c}
{parent=Internet Protocol}

= IP
{c}
{synonym}

\Video[https://www.youtube.com/watch?v=rPoalUa4m8E]
{title=The Internet Protocol by Ben Eater (2014)}

= ping
{disambiguate=networking utility}
{parent=Internet Protocol}
{tag=Computer network software}
{wiki}

= Transmission Control Protocol
{c}
{parent=Internet protocol suite}
{title2=TCP}
{wiki}

= Domain Name System
{c}
{parent=Internet protocol suite}
{title2=DNS}
{wiki}

= DNS
{synonym}

= DNS database
{c}
{parent=Domain Name System}

As of 2023, working with DNS data is just going through a mish-mash of closed datasets/expensive APIs.

We really need some open data in that area.

* https://opendata.stackexchange.com/questions/1951/dataset-of-domain-names
* https://opendata.stackexchange.com/questions/2110/domain-name-system-record-a-database

= 2013 DNS Census
{parent=DNS database}

Data format overview: https://opendata.stackexchange.com/questions/1951/dataset-of-domain-names/21077#21077

= CAIDA/commoncrawl-host-ip-mapper
{c}
{parent=DNS database}

https://github.com/CAIDA/commoncrawl-host-ip-mapper

= Domain name
{parent=Domain Name System}
{title2=DNS}
{wiki}

= Top-level domain
{parent=Domain name}
{wiki}

= Interesting domain name
{parent=Domain name}
{wiki}

* http://cunt.com[]: https://www.reddit.com/r/RandomThoughts/comments/103icty/why_does_typing_cuntcom_lead_to_jeremy_corbyns/

= Internet company
{c}
{parent=Internet}
{tag=Company}

https://en.wikipedia.org/wiki/List_of_largest_Internet_companies

\Include[amazon]{parent=Internet company}

= Alibaba
{c}
{parent=Internet company}
{tag=Chinese company}
{wiki}

\Include[google]{parent=Internet company}

= Alibaba product
{parent=Alibaba}

= Netflix
{c}
{parent=Internet company}
{tag=American company}
{wiki}

= Yahoo!
{c}
{parent=Internet company}
{tag=American company}
{wiki}

= Internet service provider
{c}
{parent=Internet}
{wiki}

= ISP
{c}
{synonym}
{title2}

= Networking hardware
{parent=Computer network}
{wiki}

= Network interface controller
{parent=Networking hardware}
{title2=NIC}
{wiki}

= SmartNIC
{c}
{parent=Network interface controller}
{title2=DPU}

A <network interface controller> that does more than just the base <OSI model> protocols, notably in a programmable way.
* https://www.nextplatform.com/2022/05/11/intel-unrolls-dpu-roadmap-with-a-two-year-cadence/
* https://www.trentonsystems.com/blog/what-is-a-smartnic
* https://blogs.nvidia.com/blog/2021/10/29/what-is-a-smartnic/ "Some are using <FPGAs> which promise flexibility"
* https://www.servethehome.com/intel-ipu-exotic-answer-to-industry-dpu/ "Intel IPU is an Exotic Answer to the Industry DPU"
* 2022 https://www.datacenterdynamics.com/en/news/amd-to-buy-smartnic-firm-pensando-for-19-billion/ "<AMD> to buy <SmartNIC> firm Pensando for \$1.9 billion"
  \Q[
  <Nvidia> gets Mellanox, <AMD> gets Pensando.

  The company, which develops programmable packet processors, includes Goldman Sachs, IBM Cloud, Microsoft Azure, and Oracle Cloud among its customers.

  Its processors and SmartNIC offering competes with AWS Nitro, Intel's DPU, and Nvidia's BlueField.
  ]
* https://www.theregister.com/2022/06/14/alibaba_dpu_cloud/ mentions that <Alibaba Cloud> created their own.

\Video[https://www.youtube.com/watch?v=kwroXmFJJf0]
{title=<Hyperscalers> Lead The Way To The Future With <SmartNICs> by The Next Platform (2019)}
{description=
* https://youtu.be/kwroXmFJJf0?t=599 <financial industry> is one of the users, notably <high frequency trading>

Associated article: https://www.nextplatform.com/2019/10/31/hypercalers-lead-the-way-to-the-future-with-smartnics/ mentions that:
\Q[Google is widely believed to be working on its own design.]
}

= Router
{disambiguate=computing}
{parent=Networking hardware}
{wiki}

= Router
{synonym}

= Network switch
{parent=Networking hardware}
{wiki}

A switch is a box with a bunch of <Ethernet> wires coming into it:
``
+--------------------+
| +-+  +-+  +-+  +-+ |
| |1|  |2|  |3|  |4| |
| +-+  +-+  +-+  +-+ |
+--------------------+
``
Except that it doesn't have to be <Ethernet>, e.g. it would also be a <Wi-Fi>.

What the switch does is:
* an <Ethernet> request came in from wire 1
* decide which wire to send it out on, e.g. wire 2, 3, 4, 5, etc. You likely don't want to send it back through 1 where it came from.
After the destination is found, a confirmation is somehow sent back to the switch, which then learns which wire to send each <MAC address> to.

A switch is a bit like a <router> but it is a bit dumber/operates at a lower level: it basically operates only on <MAC addresses>, not on <IP addresses>.

The <Internet service provider> boxes most people have at home combines a switch for the local network and a <router> for the ISP communication.

= Networking hardware company
{parent=Networking Hardware}

= Cisco
{c}
{parent=Networking hardware company}
{tag=University of Stanford spinout company}
{wiki}

\Video[https://youtu.be/d0ya8DggDYs?t=2621]
{title=<Nerds 2.0.1> excerpt about <Cisco> (1998)}
{description=
* https://youtu.be/mhz24AR3nIc?t=45 the founders both worked at <Stanford University> but because they were in different departments they couldn't send an <email> to one another.
* https://youtu.be/mhz24AR3nIc?t=54 Sandy Lerner is very nice and chilled. She says how she was amazed by Leonard's manners!
* https://youtu.be/mhz24AR3nIc?t=86 "sincerity begins at a little over 100 hours a week". The dude is a robot.
* https://youtu.be/mhz24AR3nIc?t=279 earthquake!!!
* https://youtu.be/d0ya8DggDYs?list=PLn7AqqWS1I_9EHEHy6sw-v6hUMhbeOTRW&t=3268 she bought a manor house, probably in Chawton Hampshire, England, possibly https://en.wikipedia.org/wiki/Chawton_House[Chawton House]
* https://youtu.be/d0ya8DggDYs?list=PLn7AqqWS1I_9EHEHy6sw-v6hUMhbeOTRW&t=3312 he started donating to <search for extraterrestrial intelligence>
}

= Making the Cisco connection
{c}
{parent=Cisco}
{title2=2000}
{wiki}

https://archive.org/details/makingciscoconne0000bunn on the <Internet Archive Open Library>.

Nothing phenomenally new on the early days to add on top of <video Nerds 2.0.1 excerpt about Cisco (1998)>, but a few new good points:
* Cisco at one point became the largest company by market capitalization. This wore off a bit as of 2020.

  They used this overvalued stock in part to buy many other (often also overvalued) up and coming companies. This acquisition spree strategy was apparently not the norm at the time. https://rohitnair.wordpress.com/2011/12/13/cisco-history-cisco-systems-history-and-trivia-brand-history-and-trivia/ mentions they have bought more than 140 companies since, and that they call this strategy "Build, Buy And Partner"
* a big part of what Cisco did was to allow cheap local communication in-campus. At that time, the <ARPANET> was already up and running, but their "routers", called <Interface Message Processors> were very expensive at about \$100,000, and to send data across the campus you had to go through them, which meant expensive bandwidth. The routers sometimes failed, and the fallback was to send students around with disks: "<sneakernet>". They needed new local protocols and hardware to efficiently connect different campus networks.
* <Sandy Lerner nude photo>
* Cisco was a pioneer in having an Internet support forum. Customers could also help one another. This was fundamental in scaling support, as they grew so fast it would be impossible to hire a support team large enough without the help of the forum.
* Cisco gave out source code to some customers who would then implement protocols they cared about, and Cisco would then merge it back

= Sandy Lerner
{c}
{parent=Cisco}
{wiki}

This chick is hardcore.

= Sandy Lerner nude photo
{c}
{parent=Sandy Lerner}
{title2=1997}

She posed naked on horseback for Forbes to promote animal rights in 1997, ultra low resolution image at: https://rohitnair.wordpress.com/2011/12/13/cisco-history-cisco-systems-history-and-trivia-brand-history-and-trivia/

= Server
{disambiguate=computing}
{parent=Networking Hardware}
{tag=Computer form factor}
{wiki}

= Server
{synonym}

\Video[https://www.youtube.com/watch?v=CkeY_bm9EK0]
{title=Unpacking 200 servers by Play with Junk (2021)}

\Video[https://www.youtube.com/watch?v=5eo8nz_niiM]
{title=Visiting Hetzner in Falkenstein by der8auer (2022)}

= Node
{disambiguate=server}
{parent=Server (computing)}

It runs one instance of the <Linux kernel> and has one <IP address>. Each node is therefore a complete computer. As such is must also contain <RAM> memory, <disk storage> and a <network interface controller>.

= CPUs per node and nodes per server
{disambiguate=server}
{parent=Server (computing)}

* there can be more than one node per server.
* there can be more than one <CPU> per <node (server)>
E.g.:
* <Frontier (supercomputer)>:
  * 2 <node (server)>[nodes] per <blade (server)>[blade], 1 CPU per node. Therefore 1 CPU per node.

= Server form factor
{parent=Server (computing)}

= Rack server
{parent=Server form factor}

= 19-inch rack
{parent=Rack server}
{wiki}

= Rack unit
{parent=Rack server}
{title2=1U, 2U, 3U, 4U}
{wiki}

= Blade server
{parent=Server form factor}
{wiki}

\Image[https://upload.wikimedia.org/wikipedia/commons/thumb/e/eb/HP_BladeSystem_c7000_Enclosure.jpg/1024px-HP_BladeSystem_c7000_Enclosure.jpg]
{description=Good image from <Wikimedia Commons>. In this one we can see how the blades are put vertically, and you get several of them per horizontal rack space, instead of a tipical single <rack server> going all the way horizontally.}

\Video[https://www.youtube.com/watch?v=RsZjjAqlpJ0]
{title=HP Blade Server by Brian Kirsch (2013)}
{description=
Featuring an HP DL380 blade server, presumably an older model of this series: https://buy.hpe.com/uk/en/servers/proliant-dl-servers/proliant-dl300-servers/proliant-dl380-server/hpe-proliant-dl380-gen10-server/p/1010026818[].

In the video we can see that it contains <RAM>, <disk storage>, we are told about two <CPUs>, and networking interfaces, so it is a complete <computer> on its own. He also explains that unlike typical <rack servers>, each blade unit does not have its own coolers and power supply related hardware, which goes instead on the chassis.
}

= Data center
{parent=Server (computing)}
{wiki}

= Local server
{parent=Server (computing)}

Server run on the current machine. That's how all <websites> are developed and born!

= Client
{disambiguate=computing}
{parent=Server (computing)}
{wiki}

\Include[computer-science]{parent=computer}

= Cybersecurity
{parent=Computer}
{wiki}

= Hacker group
{parent=Cybersecurity}

= Boitatech
{c}
{parent=Hacker group}
{tag=Brazil}

A <misogenous> <Brazilian> hacking group:
* https://boitatech.com.br/
* https://github.com/boitatech
Just kidding.

Some people from them contacted <Ciro Santilli> after Ciro's initial publishing of <CIA 2010 covert communication websites>.

After a quick <Discord> chat with them, it was apparent that these people were really cool and knowledgeable.

Also many of them seem to think <university is broken> and just go hack straigh away.

A perfect example of a <dojo learning model>.

Also they don't seem to need sleep. Go figure!

With pepole like this, there's hope for <Brazil>: <what poor countries have to do to get richer>{full}.

= Capture the flag
{disambiguate=Cybersecurity}
{parent=cybersecurity}
{wiki}

= Cybercrime
{parent=Cybersecurity}
{wiki}

= Cyber crime
{synonym}

= Silk Road
{disambiguate=marketplace}
{c}
{parent=Cybercrime}
{wiki}

<Ciro Santilli> has become slightly obsessed with this story, and the main mastermind <Ross Ulbricht>.

\Image[https://web.archive.org/web/20190629084608if_/https://cdn.arstechnica.net/wp-content/uploads/2015/01/GX-201C-640x853.png]
{title=Ross Ulbricht's open laptop shortly after his arrest at the Francisco Public Library}
{description=He was running some GNOME based distro, could be <Ubuntu> from that photo, and likely is given that Ross once recommended Ubuntu to his flatmate.}
{source=https://arstechnica.com/tech-policy/2015/01/the-incredibly-simple-story-of-how-the-govt-googled-ross-ulbricht}

The best article available so far is: https://www.theregister.co.uk/2019/01/29/how_i_caught_silk_road_mastermind (https://web.archive.org/web/20191008142214/https://www.theregister.co.uk/2019/01/29/how_i_caught_silk_road_mastermind[archive]) which summarizes what one of the investigators said in a 2019 French computer security conference.

The key living posts are:
* https://stackoverflow.com/questions/15445285/how-can-i-connect-to-a-tor-hidden-service-using-curl-in-php (https://web.archive.org/web/20191121133952/https://stackoverflow.com/questions/15445285/how-can-i-connect-to-a-tor-hidden-service-using-curl-in-php[archive]) which was originally asked under the real name, and then the username was changed to "Frosty", which matches one of the server's logins after the laptop was captured
* altoid early Silk Road mention: https://bitcointalk.org/?topic=175.70;wap2 (https://web.archive.org/web/20190628133852/https://bitcointalk.org/?topic=175.70;wap2[archive])

The big question is of course how libertarian free market ideologically motivated the website was, and how purely criminal greed it was.

The magnitude of the early <operational security> mistakes does make Ciro think that Ross did it "because he could" and https://www.urbandictionary.com/define.php?term=i%20did%20it%20for%20the%20lulz["for the lolz"] in a real world <Breaking Bad> way.

The entry in Ross' diary does <Ciro Santilli's selfish desires>[resonate a lot] with Ciro and any entrepreneur, full diary at: https://www.wired.com/2015/01/heres-secret-silk-road-journal-laptop-ross-ulbricht/ (https://web.archive.org/web/20190613011454/https://www.wired.com/2015/01/heres-secret-silk-road-journal-laptop-ross-ulbricht/[archive]).

\Q[
\[i\]n 2011," \[I believe I will be\] "creating a year of prosperity and power beyond what I have ever experienced before,

Silk Road is going to become a phenomenon and at least one person will tell me about it, unknowing that I was its creator."
]

Having this kind of feeling, is the greatest thing any human can have, and what motivates all great things.

Capitalizing in <illegal> things though is a cheat, big things take longer than a few years to reach, but reaching them is that much more satisfying as well.

Other interesting quotes:
\Q[I hated working for someone else and trading my time for money with no investment in myself.]
which Ciro also feels, see <don't be a pussy>, and:
\Q[Everyone knows I am working on a bitcoin exchange. I always thought honesty was the best policy and now I didn't know what to do. I should have just told everyone I am a freelance programmer or something, but I had to tell half truths. It felt wrong to lie completely so I tried to tell the truth without revealing the bad part, but now I am in a jam. Everyone knows too much. Dammit.]

Also very worth reading is the San Francisco flat mate account: https://www.vice.com/en_us/article/ae3q8g/my-roommate-the-darknet-drug-lord (https://web.archive.org/web/20191201090353/https://www.vice.com/en_us/article/ae3q8g/my-roommate-the-darknet-drug-lord[archive]).

The murder for hire allegations are also interesting: https://mashable.com/2013/10/03/silk-road-hits[], he paid 80k dollars to undercover DEA agents!

Except for the fact that Ross was an 80 million <Dollar> <drug lord>, those accounts sound exactly like what you would expect from any other nerdy startup founder! The:
* "just do it" strategy effectively going to a minimal viable product (manual transaction management!), while making many mistakes along the way, including hiring mistakes and successes when scaling is needed
* the hardship of self bootstrapping your own social network (here with some kilos of mushrooms)
* the variety of periods, from relatively calm, to hair pulling stress during big changes

It is also amusing to see very concretely the obvious fact that the FBI can get a https://en.wikipedia.org/wiki/Subpoena[subpoena] for all accounts you ever had, e.g. they knew his <laptop> model from <Amazon> and brought a corresponding power cable to the arrest! If you are going to be a cyber criminal, don't use your real name, ever!

Should justice be blind? Maybe. But it does hurt for mere non-blind men to see it sometimes. Especially when <drug liberalization> is involved.

= Ross Ulbricht
{c}
{parent=Silk Road (marketplace)}
{wiki}

= Domain-specific language
{parent=Computer}
{title2=DSL}
{wiki}

<Evil>. Just use <Python> instead for <software>, and a well known <data file format> for data, please.

= E-book
{parent=Computer}
{wiki}

= E-book file format
{parent=E-book}

= EPUB
{c}
{parent=E-book file format}
{wiki}

This is a good thing. It basically contains an entire <website>, with <HTML> and assets inside a single <ZIP>, and a little bit of metadata.

It is incomprehensible why <browsers> don't just implement it as they already have all the web part, and also <ZIP> stuff:
* https://www.quora.com/What-is-the-reason-that-browsers-cannot-open-epub-files-without-extensions on <Quora>

The situation is so sad. <Ubuntu> 21.04 doesn't come with a reader installed by default:
* https://askubuntu.com/questions/14378/what-software-can-i-use-to-view-epub-documents

= PDF
{c}
{parent=E-book file format}
{wiki}

= E-book viewer
{parent=E-book}

= Calibre
{disambiguate=software}
{c}
{parent=E-book viewer}
{wiki}

Sometimes <Ciro Santilli> says half jokingly that <user interface> does not matter.

This software circa 2010-2020 makes that joke not be funny.

How can a UI feel so clunky!

The most aggravating thing is that it is not immediately obvious why it feels so bad.

= Evince
{parent=E-book viewer}
{wiki}

= Okular
{parent=E-book viewer}
{wiki}

This is generally good, especially compared to how crappy Evince, the default <Ubuntu> one, has been around 2014-2020.

= File format
{parent=Computer}
{wiki}

= Human-readable medium
{parent=File format}
{wiki}

= Human-readable format
{synonym}

= Plaintext file
{synonym}
{title2}

= Human-readable
{synonym}

= Binary data
{parent=Human-readable medium}
{wiki}

The opposite of a <human-readable format>.

= Binary large object
{parent=Binary data}
{wiki}

= BLOB
{c}
{synonym}

Less evil are BLOBs that come from <Reproducible builds>.

= Binary-to-text encoding
{parent=Binary data}
{wiki}

= Base58
{c}
{parent=Binary-to-text encoding}

https://en.bitcoin.it/wiki/Base58Check_encoding

Invented for <Bitcoin>.

= Base64
{c}
{parent=Binary-to-text encoding}
{wiki}

= yEnc
{c}
{parent=Binary-to-text encoding}
{wiki}

= Archive file
{parent=File format}
{wiki}

= ZIP
{disambiguate=file format}
{c}
{parent=Archive file}
{wiki}

= ZIP
{c}
{synonym}

= Audio file format
{parent=File format}
{wiki}

= Audio editor
{parent=Audio file format}
{wiki}

= Audacity
{disambiguate=audio editor}
{parent=Audio editor}
{wiki}

= Audacity profile-based background noise removal
{parent=Audacity (audio editor)}

You select a sample noise-only area, and it remove noise from the entire video for you:
* https://www.youtube.com/watch?v=AeOjtMOq3EU
* https://www.youtube.com/watch?v=3nMkMn4--5w

= MIDI
{c}
{parent=Audio file format}
{wiki}

In simple terms, represents keystrokes of a piano, but it can likely also represent other effects (TODO confirm: bend, vibrato, slides, attack strength)

Can contain multiple parallel tracks as seen from the <Wikipedia> example: https://en.wikipedia.org/wiki/File:MIDI_sample.mid

You can see what it contains well with <GUI music editor>.

MIDI is fun. It is a basic high level representation of most instrumental music, including beats.

To actually listen to MIDI, you need a <software synthesizer>, which knows what sound to make for each note. One way to specify such instruments is the <SoundFont> file format.

Convert MIDI to more common standalone formats:
* https://stackoverflow.com/questions/16295459/convert-midi-to-mp3/65207296#65207296
* https://softwarerecs.stackexchange.com/questions/10915/automatically-turn-midi-files-into-wav-or-mp3/76955#76955

= SoundFont
{c}
{parent=MIDI}
{wiki}

Contains instructions on how to synthesize MIDI.

Extension: sf2.

Can be imported for example by:
* <vmpk>
* <Csound> with `sfload`: http://www.csounds.com/manual/html/sfload.html

= vmpk
{c}
{parent=MIDI}

https://vmpk.sourceforge.io/

Opens a virtual <MIDI> piano <GUI>. It just works on <Ubuntu> 20.04: https://askubuntu.com/questions/34391/virtual-midi-piano-keyboard-setup/1298026#1298026

VMPK is a virtual device that replicates what you would get by connecting a physical MIDI keyboard to your computer. It is not a <software synthesizer> on its own. But it does connect to a working synthesizer by default (Sonivox EAS) which makes it produce sounds out-of-the box.

TODO: then I messed with my sound settings, and then it stopped working by default on the default "MIDI Connection" > "MIDI Out Driver" > "Network". But it still works on "SonivoxEAS".

A <hello world> of actually connecting it to a specific software synthesizer manually on <Advanced Linux Sound Architecture> with `aconnect` can be found at: https://askubuntu.com/questions/34391/virtual-midi-piano-keyboard-setup/1298026#1298026

Save to a <MIDI> file: https://askubuntu.com/questions/709673/save-as-midi-when-playing-from-vmpk-qsynth/1298231#1298231

Reasonable default key mappings to keyboard covering 2 octaves.

3 multiple simultaneous keys did not work (tested "ZQI"). This might just be a limitation of <ciro santilli s hardware/Lenovo ThinkPad P51 (2017)>[my keyboard] however.

TODO how to save to a `.mid` file? https://askubuntu.com/questions/709673/save-as-midi-when-playing-from-vmpk-qsynth

<SourceForge>.

= Data file format
{parent=File format}
{wiki=Data_file}

= Comma-separated values
{parent=Data file format}
{wiki}

= CSV
{c}
{synonym}
{title2}

= JSON
{c}
{parent=Data file format}
{wiki}

= JSON trailing comma
{parent=JSON}

https://stackoverflow.com/questions/201782/can-you-use-a-trailing-comma-in-a-json-object

The fact that you cannot have trailing commans in lists or dicts as in `3,` at:
``
{
  "asdf": [
    1,
    2,
    3,
  ]
}
``
is one of the most infuriating design choices of all time!!!

= Hierarchical Data Format
{c}
{parent=Data file format}
{title2=HDF}
{wiki}

= Unified Modeling Language
{c}
{parent=Data file format}
{wiki}

= UML
{c}
{synonym}
{title2}

= XML
{c}
{parent=Data file format}
{tag=Markup language}
{title2=Extensible Markup Language}
{wiki}

Do you know what is worse than XML? <HTML>[Pseudo XML]: https://stackoverflow.com/questions/5558502/is-html5-valid-xml/39560454#39560454

= Standard Generalized Markup Language
{c}
{parent=XML}
{wiki}

= SGML
{c}
{synonym}
{title2}

<XML> predecessor.

= IBM Generalized Markup Language
{c}
{parent=Standard Generalized Markup Language}
{wiki}

<SGML> predecessor.

= XPath
{c}
{parent=XML}
{wiki}

XPath kind of died with the rise of <CSS> selectors around the beginnning of the 2010's. But that is a shame. XPath is a good standard, and was generally more powerful than CSS selectors for many many years.

= YAML
{c}
{parent=Data file format}
{wiki}

= Image file format
{parent=File format}
{wiki=Image_file_formats}

= Raster graphics
{parent=Image file format}
{wiki}

Represents image <pixel> by pixel, rather than by mathematical primitives such as done in <vector graphics>:

= Pixel
{parent=Raster graphics}
{wiki}

= Vector graphics
{parent=Image file format}
{wiki}

Smaller files, scalable image size, and editability. Why would you use anything else for programmatically generated images?!?!

= Scalable Vector Graphics
{parent=Vector graphics}
{wiki}

= SVG
{c}
{synonym}
{title2}

<Companies> have been really slow to support SVG features in their browsers, and that is very saddening: https://medium.com/@michaelmangial1/introduction-to-scalable-vector-graphics-6450c03e8d2e

You can't drop SVG support for `canvas` until there's a way to run untrusted <JavaScript> on the browser!

<SVG> does have some compatibility annoyances, notably <SVG fonts>. But we should as a society work to standardize and implement a fix those, the benefits of SVG are just too great!

Examples:
* \a[svg/svg.svg] a minimal somewhat sane SVG:
  * if the `width` and `height` properties were not given, you get the default 300x150, which seems to be set in the SVG standard:
    * https://stackoverflow.com/questions/40156710/why-does-this-svg-image-have-a-height-of-150px
    * https://css-tricks.com/scale-svg
* how to add na SVG image to a <HTML> file:
  * \a[svg/svg.html]: external image. The included file is \a[svg/svg.svg].
  * \a[svg/inline.html]: inline.
* \a[svg/billion-laughs.svg]
* \a[svg/html.svg]
* \a[svg/triangle.svg]
* \a[svg/viewBox.svg]: this attribute allows you to control the default SVG `svg width=` and `height=` while keeping the coordinates of the drawing untouched. If the `viewBox` aspect ratio differs from the width/height ratio, you likely want to play with `preserveAspectRatio`, otherwise you would get white spaces by default on the generated image
* <CSS> with SVG:
  * \a[svg/style.svg]: inline CSS
  * \a[svg/style-external.svg]: external CSS with: `<?xml-stylesheet type="text/css" href="svg.css" ?>`, see also: https://stackoverflow.com/questions/18434094/how-to-style-svg-with-external-css
    * \a[svg/subdir/style-external.html]: is the relative CSS relative to the HTML or to the SVG? Answer: to the SVG... OMG. So how to make it work reliably?
  * \a[svg/current-color.html] and \a[svg/current-color.svg]: illustrates `fill="currentColor"`. Only works for inline SVG however... See also: https://stackoverflow.com/questions/13000682/how-do-i-have-an-svg-image-inherit-colors-from-the-html-document/13002311
* <JavaScript> with SVG:
  * \a[svg/script.svg]
  * \a[svg/external-js.svg]
* \a[svg/defs.html] hows how `defs` works
  * \a[svg/defs-external.html] tries to include external `defs` from \a[svg/defs.svg], but that fails like everything else related to external SVGs

= SVG tutorial
{c}
{parent=Scalable Vector Graphics}

= SVG background color
{c}
{parent=SVG tutorial}

This is a pain point as of <SVG 1.1>...

Examples at \a[svg/background.html] which answers from https://stackoverflow.com/questions/11293026/default-background-color-of-svg-root-element/11293812[]:
* \a[svg/background-rect.svg]
* \a[svg/background-viewport-fill.svg]: was part of <SVG 1.2>, but that whole standard got dropped. Not implemented neither in <Chromium (web-browser)> 85 nor <Firefox> 93 as of 2021.

This pain reflects directly on Inkscape: <set SVG background color in Inkscape>.

= SVG fonts
{c}
{parent=SVG tutorial}

The major problem with SVG is text <computer fonts>. If you make an image with text that depends on one <computer font> and it is not present in the viewer's machine, it will use some other font, which may overlap with other elements of the image. Some libraries <Matplotlib> solve this https://stackoverflow.com/questions/34387893/output-matplotlib-figure-to-svg-with-text-as-text-not-curves[by writing characters as curves], but this produces large files and unsearchable text. The inability of different computer platforms to standardize fonts that must always be present is a major issue.

= Join two SVG side-by-side from the command line
{parent=Scalable Vector Graphics}

TODO:
* https://stackoverflow.com/questions/9612434/how-to-concatenate-svg-files-lengthwise-from-linux-command-line
* https://graphicdesign.stackexchange.com/questions/90844/joining-together-multiple-svg-images
* https://graphicdesign.stackexchange.com/questions/137096/is-there-a-way-to-stack-two-svgs-on-top-of-each-other

= SVG version
{c}
{parent=Scalable Vector Graphics}

= SVG 1.0
{c}
{parent=SVG version}

= SVG 1.1
{c}
{parent=SVG version}

= SVG 1.2
{c}
{parent=SVG version}

Dropped in favor of <SVG 2>.

= SVG 2
{c}
{parent=SVG version}

= List of image file formats
{parent=Image file format}

= GIF
{parent=List of image file formats}
{wiki}

\Video[https://www.youtube.com/watch?v=Nrk8sqZfsgI]
{title=It's pronounced <GIF> by Jehtt (2022)}

= Jacquard machine
{c}
{parent=List of image file formats}
{tag=Punched card}
{title2=1804}
{wiki}

\Image[https://upload.wikimedia.org/wikipedia/commons/thumb/5/55/A_Jacquard_loom_showing_information_punchcards%2C_National_Museum_of_Scotland.jpg/800px-A_Jacquard_loom_showing_information_punchcards%2C_National_Museum_of_Scotland.jpg]

\Video[https://www.youtube.com/watch?v=OlJns3fPItE]
{title=A Jacquard loom in action by NationalMuseumsScotland (2016)}
{description=The lack of audio is unsettling!}

= JPEG
{c}
{parent=List of image file formats}
{wiki}

= Portable Network Graphics
{parent=List of image file formats}
{wiki}

= PNG
{c}
{synonym}
{title2}

= libpng
{c}
{parent=Portable Network Graphics}

<PNG> reference implementation. Ahh, if feels good to have a dominating open source reference implementation.

Demo of using it by <Ciro Santilli>: https://stackoverflow.com/questions/1362945/how-to-decode-a-png-image-to-raw-bytes-from-c-code-with-libpng/36399711#36399711

\Image[https://i.stack.imgur.com/rfdHr.png]

\Image[https://i.stack.imgur.com/IWBSj.png]

= Image editor
{parent=Image file format}

= GIMP
{c}
{parent=Image editor}
{wiki}

It's not super easy to use at first.

And it sometimes says that the basic drawing thing you want to do is off the project's scope.

But as you learn more about it and further generalize the concepts, there are often reasonable reasons for those design choices.

And the UI looks good :-)

Examples:
* https://superuser.com/questions/167873/how-do-i-draw-a-box-in-gimp you need to go on a top menu to draw a rectangle

Some answers by <Ciro Santilli>:
* https://graphicdesign.stackexchange.com/questions/83446/gimp-how-to-combine-two-images-side-by-side/145543#145543

= Inkscape
{c}
{parent=Image editor}
{wiki}

Inkscape is a a good software for editing/creating <SVG> files.

Its functionality is fundamental for as a <software for drawing geometry diagrams>, as it is a good middle ground between algorithmic generation, and <raster graphics>.

At 1.0.2, its <UI> is a bit terrible:
* the way the menus open on the right with title below the window...
* several defaults are atrocious, e.g. export drawing rather than page

And it crashes from time to time on <Ubuntu> 21.04. And it has some glaring bugs, e.g.:
* https://gitlab.com/inkscape/inbox/-/issues/5794

But still, it is a very good initiative.

What would be really amazing is if they had constraints: https://gitlab.com/inkscape/inbox/-/issues/1465 like proper <CAD> software, it would make it possible to not have to redo entire diagrams when you want to change a small part of them.

= Rotate object around a point in Inkscape
{parent=Inkscape}

There's a tiny little crosshair that you can drag around to set the center of rotation.

And there's a button to make that crosshair snap: https://inkscape.org/forums/questions/can-a-pivotingtransfrom-crosshair-be-moved-and-made-to-snap-to-a-node-or-a-grid-point/#c14432

= Set SVG background color in Inkscape
{parent=Inkscape}

This is related to the underlying SVG pain point of <SVG background color>:
* https://gitlab.com/inkscape/inkscape/-/issues/531
* https://graphicdesign.stackexchange.com/questions/74906/in-inkscape-how-do-i-add-a-white-background/144952#144952

For <PNG> export:
* https://superuser.com/questions/249860/how-can-i-change-inkscapes-default-export-background-color-from-yellow-to-white

= Video file format
{parent=File format}
{wiki=Video_file_formats}

= Video codec
{parent=Video file format}
{wiki}

= Codec acceleration
{parent=Video codec}
{wiki}

= Video editing software
{parent=Video file format}
{wiki}

= Kdenlive
{c}
{parent=Video editing software}
{wiki}

This seems like a decent option, although it has bugs coming in and out all the time! Also it is quite hard to learn to use.

To get started:
* import a clip
* drag it onto the track area

To cut tracks at current point: Ctrl + R.

To set the video length, search for "set outpoint" on "monitor".

Add subtitles:
* Effects
* Dynamic text
then drag on top of the video track. To add only to part of the video, cut it up first.

Preview has no sound on <Ubuntu> 20.10. Fixed as of <Ubuntu 22.04>.

Sound worked on Ubuntu 21.04 though, but it then soon crashed with:

``
 = = SET EFFECT PARAM:  "rect"  =  0=1188 0 732 242
MUTEX LOCK!!!!!!!!!!!! slotactivateeffect:  1
// // // RESULTING REQUIRED SCENE:  1
Object 0x557293592da0 destroyed while one of its QML signal handlers is in progress.
Most likely the object was deleted synchronously (use QObject::deleteLater() instead), or the application is running a nested event loop.
This behavior is NOT supported!
qrc:/qml/EffectToolBar.qml:80: function() { [native code] }
Killed
``
amazing.

On Ubuntu 22.04 haven't crashed yet.

<Ubuntu 23.04> broke the clip drag and drop!
* https://askubuntu.com/questions/1464992/cant-drag-clip-to-timeline-in-kdenlive-in-ubuntu-23-04/1469359#1469359
* https://gitlab.gnome.org/GNOME/mutter/-/issues/2715#note_1753579
* https://www.reddit.com/r/kdenlive/comments/12x0t6s/kdenlive_drag_and_drop_not_working/

= ShotCut
{c}
{parent=Video editing software}
{wiki}

Worked on <Ubuntu> 20.10.

The UI is a bit too buggy to bear.

How to unsplit, can't find on shotcut 21.05.01: https://forum.shotcut.org/t/is-it-possible-to-unsplit/1466/2

Background noise reduction: couldn't easily find out how, especially with automatic profile detected based on a selected region as mentioned at <audacity profile-based background noise removal>:
* https://forum.shotcut.org/t/how-to-apply-filter-reduction-noise-on-audio/12678/2
* https://forum.shotcut.org/t/noise-reduction-filter-request/5348/6

= OpenShot
{c}
{parent=Video editing software}
{wiki}

<Ubuntu> 20.10 crash...:
``
  exceptions:ERROR Unhandled Exception
Traceback (most recent call last):
  File "/usr/bin/openshot-qt", line 11, in <module>
    load_entry_point('openshot-qt==2.5.1', 'gui_scripts', 'openshot-qt')()
  File "/usr/lib/python3/dist-packages/openshot_qt/launch.py", line 97, in main
    app = OpenShotApp(argv)
  File "/usr/lib/python3/dist-packages/openshot_qt/classes/app.py", line 218, in __init__
    from windows.main_window import MainWindow
  File "/usr/lib/python3/dist-packages/openshot_qt/windows/main_window.py", line 45, in <module>
    from windows.views.timeline_webview import TimelineWebView
  File "/usr/lib/python3/dist-packages/openshot_qt/windows/views/timeline_webview.py", line 42, in <module>
    from PyQt5.QtWebKitWidgets import QWebView
ImportError: /usr/lib/x86_64-linux-gnu/libQt5Quick.so.5: undefined symbol: _ZN4QRhi10newSamplerEN11QRhiSampler6FilterES1_S1_NS0_11AddressModeES2_, version Qt_5_PRIVATE_API
``

= Subtitle
{parent=Video file format}

= How to hardcode subtitle into a video with FFmpeg?
{parent=Subtitle}

* https://superuser.com/questions/869248/hardcoding-subs-with-ffmpeg
* https://askubuntu.com/questions/485100/how-may-i-burn-srt-subtitles-to-video-with-avconv

On <Ubuntu> 20.10, just:
``
ffmpeg -i input.mp4 -vf "subtitles=subtitle.srt" output.mp4
``

To change font size: https://stackoverflow.com/questions/21363334/how-to-add-font-size-in-subtitles-in-ffmpeg-video-filter
``
ffmpeg -i input.mp4 -vf "subtitles=subtitle.srt:force_style='Fontsize=64'" output.mp4
``
The default appears to be 24, so just multiply that by whatever seems like a reasonable factor.

Note howver that <.ass subtitle files> can contain style information, which ffmpeg respects. <Aegisub> can produce and preview such styles, making .ass one of the best options.

= Subtitle file format
{parent=Subtitle}

= SubStation Alpha
{c}
{parent=Subtitle file format}
{wiki}

= .ass subtitle file
{synonym}
{title2}

= Subtitle editor
{parent=Subtitle file format}

= Subtitle Edit
{c}
{parent=Subtitle editor}

Written in <c sharp>.

= Aegisub
{c}
{parent=Subtitle editor}

https://github.com/Aegisub/Aegisub

This worked well on 3.2.2 <Ubuntu> 20.10. Recommended.

First import video with:
``
aegisub-3.2 ourbigbook-parent.mkv
``
They don't have an `aegisub` executable without the version number. Amazing.

If you already have a subtitle file that you want to edit, then just pass it on as well:
``
aegisub-3.2 ourbigbook-parent.mkv ourbigbook-parent.ass
``

Ctrl + P: play and pause video.

Ctrl + 3: set current substitle start time.

Ctrl + 4: set current substitle end time.

Enter: finish editing the current entry and start a new one.

= Gaupol
{c}
{parent=Subtitle editor}

https://github.com/otsaloma/gaupol

Good shortcuts and user experience.

No waveform viewer: https://github.com/otsaloma/gaupol/issues/49 so unusable.

= kitone/subtitleeditor
{parent=Subtitle editor}

https://github.com/SubtitleEdit/subtitleedit

Not to be confused with <Subtitle Edit>.

As of 0.54.0 this feels featureful, but extremely buggy or lacking UI obvious enhancements that would be simple to implement, and offer huge value:
* fundamental not defined out of box, e.g. Tiny forward/backwards. You can define them yourself, but they should be provided.
* https://github.com/SubtitleEdit/subtitleedit/issues/4976 can't export <SubRip>?
* can't interact with video on waveform?

It is hard to understand how that project reached this weird featureful but crappy state. Feels like they just gave push permission to a bunch of random people.

= List of subtitle file formats
{parent=Video file format}

= SubRip
{c}
{parent=List of subtitle file formats}
{title2=.srt}
{wiki}

= List of file formats
{parent=File format}
{wiki=Video_file_formats}

= UF2
{c}
{parent=List of file formats}

https://github.com/microsoft/uf2

A <Microsoft> format for flashing <microcontrollers> by copying files to a magic filesystem mounted  on host, e.g. as done on the <Micro Bit> and <Raspberry Pi Pico>.

= Information
{parent=Computer}
{wiki}

= Data
{parent=Information}
{wiki}

= Synthetic data
{parent=Data}
{wiki}

= Procedural generation
{parent=Synthetic data}
{wiki}

= Information theory
{parent=Information}
{wiki}

= Noisy-channel coding theorem
{parent=Information theory}
{title2=Shannon's theorem}
{wiki}

Setting: you are sending bits through a communication channel, each bit has a random probability of getting flipped, and so you use some error correction code to achieve some minimal error, at the expense of longer messages.

This theorem sets an upper bound on how efficient you can be in your encoding, for any encoding.

The next big question, which the theorem does not cover is how to construct codes that reach or approach the limit. Important such codes include:
* <turbo code>
* <low-density parity-check code>

But besides this, there is also the practical consideration of if you can encode/decode fast enough to keep up with the coded bandwidth given your hardware capabilities.

https://news.mit.edu/2010/gallager-codes-0121 explains how turbo codes were first reached without a very good mathematical proof behind them, but were still revolutionary in experimental performance, e.g. turbo codes were used in 3G/4G.

But this motivated researchers to find other such algorithms that they would be able to prove things about, and so they rediscovered the much earlier <low-density parity-check code>, which had been published in the 60's but was forgotten, partially because it was computationally expensive.

= Turbo code
{parent=Noisy-channel coding theorem}
{wiki}

TODO how close does it get to Shannon's limit?

= Low-density parity-check code
{parent=Noisy-channel coding theorem}
{title2=LDPC}
{wiki}

= Signal processing
{parent=Information theory}
{wiki}

= Filter
{disambiguate=signal processing}
{parent=Signal processing}
{wiki}

= Bandpass filter
{parent=Filter (signal processing)}
{wiki}

= Signal-to-noise ratio
{parent=Information theory}
{wiki}

= Signal-to-noise
{synonym}

= Quantum information
{parent=Information}
{wiki}

\Include[quantum-computing]{parent=quantum-information}

= Quantum key distribution
{parent=Quantum information}
{tag=Cryptography}
{wiki}

= QKD
{c}
{synonym}
{title2}

Man-in-the-middle attack

https://quantumcomputing.stackexchange.com/questions/142/advantage-of-quantum-key-distribution-over-post-quantum-cryptography/25727#25727 Advantage of quantum key distribution over post-quantum cryptography has <Ciro Santilli>'s comparison to classical encryption.

<BB84> is a good first algorithm to look into.

Long story short:
* QKD allows you to generate shared keys without <public-key cryptography>. You can then use thses shared keys
* QKD requires authentication on a classical channel, exactly like a classical <public-key cryptography> <forward secrecy> would. The simplest way to do this is a with a <pre-shared key>, just like in classical public key cryptography. If that key is compromised at any point, your future messages can get <man-in-the-middle>'d, exactly like in classical cryptography.

QKD uses <quantum mechanics> stuff to allow sharing unsnoopable keys: you can detect any snooping and abort communication. Unsnoopability is guaranteed by the known <laws of physics>, up only to engineering imperfections.

Furthermore, it allows this <key (cryptography)> distribution without having to physically take a box by car somewhere: once the channel is established, e.g. <optical fiber>, you can just keep generating perfect keys from it. Otherwise it would be pointless, as you could just drive your <one-time pad> key every time.

However, the keys likely have a limited rate of generation, so you can't just <one-time pad> the entire message, except for small text messages. What you would then do is to use the shared key with <symmetric encryption>.

Therefore, this setup usually ultimately relies on the idea that we believe that <symmetric encryption> is safer than , even though there aren't mathematical safety proofs of either as of 2020.

= Quantum key distribution protocol
{parent=Quantum key distribution}

= BB84
{c}
{parent=Quantum key distribution protocol}
{wiki}

Does not require <entangled particles>, unlike <E91> which does.

https://en.wikipedia.org/w/index.php?title=Quantum_key_distribution&oldid=1079513227#BB84_protocol:_Charles_H._Bennett_and_Gilles_Brassard_(1984) explains it well. Basically:
* Alice and Bob randomly select a measurement basis of either 90 degrees and 45 degrees for each <photon>
* Alice measures each photon. There are two possible results to either measurement basis: parallel or perpendicular, representing values 0 or 1. TODO understand better: weren't the possible results supposed to be pass or non-pass? She writes down the results, and sends the (now <wave function collapse>[collapsed]) photons forward to Bob.
* Bob measures the photons and writes down the results
* Alice and Bob communicate to one another their randomly chosen measurement bases over the unencrypted classic channel.

  This channel must be authenticated to prevent <man-in-the-middle>. The only way to do this authentication that makes sense is to use a <pre-shared key> to create <message authentication codes>. Using <public-key cryptography> for a <digital signature> would be pointless, since the only advantage of <QKD> is to avoid using <public-key cryptography> in the first place.
* they drop all photons for which they picked different basis. The measurements of those which were in the same basis are the key. Because they are in the same basis, their results must always be the same in an ideal system.
* if there is an eavesdropper on the line, the results of measurements on the same basis can differ.

  Unfortunately, this can also happen due to imperfections in the system.

  Alice and Bob must decide what level of error is above the system's imperfections and implies that an attacker is listening.

= BB86 vs E91
{c}
{parent=BB84}

https://physics.stackexchange.com/questions/441870/bb84-protocol-vs-e91-protocol

= E91
{c}
{parent=Quantum key distribution protocol}

Requires <entangled particles>, unlike <BB84> which does not.

= Markup language
{parent=Computer}
{wiki}

= Lightweight markup language
{parent=Markup language}
{wiki}

= List of markup languages
{parent=Markup language}

= AsciiDoc
{c}
{parent=List of markup languages}
{tag=Lightweight markup language}
{wiki}

= AsciiDoctor
{c}
{parent=AsciiDoc}
{wiki}

= LaTeX
{c}
{parent=List of markup languages}
{wiki}

Revolutionary for its time, and a big part of <ourbigbook com/motivation>[Ciro's Enlightenment].

But too insane, and did not https://tex.stackexchange.com/questions/39309/convert-latex-to-html/196520#196520[keep up with internet age], and so Ciro wants to kill it now.

= LaTeX to HTML
{c}
{parent=LaTeX}

* full document: https://tex.stackexchange.com/questions/39309/convert-latex-to-html/196520#196520
* just the formulas: https://tex.stackexchange.com/questions/23804/how-to-incorporate-tex-mathematics-into-a-website/646504#646504

= KaTeX
{c}
{parent=LaTeX to HTML}

https://github.com/KaTeX/KaTeX

Default mathematics typesetting used in <OurBigBook Markup>.

Key issues:
* https://github.com/KaTeX/KaTeX/issues/2228 `newcommand` did not support optional arguments

= Softcover
{disambiguate=LaTeX}
{parent=LaTeX to HTML}

https://github.com/softcover/softcover

LaTeX subset that output nicely to HTML.

Too insane though due to LaTeX roots, better just move to newer HTML-first markups like <OurBigBook Markup> or <markdown>.

= MathBook XML
{c}
{parent=List of markup languages}

https://github.com/rbeezer/mathbook

<XML>, ain't nobody ever going to write that manually.

= Markdown
{parent=List of markup languages}
{tag=Lightweight markup language}
{wiki}

= Pandoc
{parent=Markdown}
{wiki}

This is good software.

If it only it were written in <JavaScript> instead of Haskell (!?), then Ciro might have used it as the basis for <OurBigBook Markup>.

= karlcow/markdown-testsuite
{parent=Markdown}

https://github.com/karlcow/markdown-testsuite

<Ciro Santilli> was contributing to this, when <CommonMark> left private mode and killed it, thus wasting many hours of Ciro's time.

See also: <Ciro Santilli's minor projects>.

= CommonMark
{c}
{parent=Markdown}

https://commonmark.org/

CommonMark is a good project. But its initial release method was not very nice, they first developed everything behind closed doors with the big adopters like <GitHub> and <Stack Overflow>, and only later released the thing read, thus wasting the time of people who were working on alternative in the meanwhile, e.g. https://github.com/karlcow/markdown-testsuite which Ciro contributed to: <Ciro Santilli's minor projects>.

= markdownlint/markdownlint
{parent=Markdown}

https://github.com/markdownlint/markdownlint

\Include[machine-learning]{parent=Computer}

= Parallel computing
{parent=Computer}
{wiki}

= Memory semantics
{parent=Parallel computing}
{wiki}

These are the rules which specify what different concurrent read/write memory accesses from different threads/processes can or cannot see.

Notable such set of rules include:
* <C++ memory model>. These are also reflected on the semantics of memory of the corresponding <instruction set architecture>
* <SQL transaction isolation level>

= C++ memory model
{c}
{parent=Memory semantics}

https://stackoverflow.com/questions/6319146/c11-introduced-a-standardized-memory-model-what-does-it-mean-and-how-is-it-g

= Parallel computing library
{parent=Parallel computing}
{wiki}

= Read-modify-write
{parent=Parallel computing}
{wiki=Read–modify–write}

That's what usually fucks up parallel programs.

= Thread
{disambiguate=computing}
{parent=Parallel computing}
{wiki}

= Thread
{synonym}

= Simultaneous multithreading
{parent=Thread (computing)}

= Hyperthreading
{synonym}
{title2}

= Hyperthread
{synonym}

* https://superuser.com/questions/133082/what-is-the-difference-between-hyper-threading-and-multiple-cores/995858#995858
* https://stackoverflow.com/questions/680684/what-are-the-differences-between-multi-cpu-multi-core-and-hyper-thread/73405312#73405312
* https://unix.stackexchange.com/questions/88283/so-what-are-logical-cpu-cores-as-opposed-to-physical-cpu-cores/739296#739296

Hyperthreding is the <Intel> brand-name, TODO generic name.

= History of computers
{parent=Computer}

= ENIAC
{c}
{parent=History of computers}
{title2=ENIAC}
{wiki}

\Include[software]{parent=computer}
\Include[computer-hardware]{parent=computer}

= Vaporware
{parent=Computer}
{wiki}

One of the saving graces of <open source> is that you ship <shit>, but you don't announce <vaporwave>.

= Computer biliography
{parent=Computer}

= Computer YouTube channel
{parent=Computer biliography}

= ExplainingComputers
{parent=Computer YouTube channel}

https://www.youtube.com/@ExplainingComputers

It is hard to say if this channel is good because of the awesome information, or if because of the absolute cutness of that British presenter. Maybe it is both.

= Programming language
{wiki}

A language that allows you to talk to and command a <computer>.

There is only space for two languages at most in the world: the <compiled programming language>[compiled] one, and the <interpreted programming language>[interpreted] one.

For 2020 now, when you have a choice, you must go for:
* <Python> as the interpreted one
* <C++> for compiled

Those two are languages not by any means perfect from a language design point of view, and there are likely already better alternatives, they are only chosen due to a pragmatic tradeoff between ecosystem and familiarity.

Ciro predicts that Python will become like <Fortran> in the future: a legacy hated by most who have moved to <JavaScript> long ago (which is slightly inferior, but too similar, and with too much web dominance to be replaced), but with too much dominance in certain applications like machine learning to be worth replacing, like Fortran dominates certain HPC applications. We'll see. Maybe non performance critical scripting languages are easier to replace.

<C++> however is decent, and is evolving in very good directions in the 2010's, and will remain relevant in the foreseeable future.

<Bash> can also be used when you're lazy. But if the project goes on, you will sooner or later regret that choice.

The language syntax in itself does not matter. All that matters is how many useful libraries and tooling it has.

This is how other languages compare:
* <C (programming language)>[C]: but cannot make a large codebase <DRY> without insanity
* <Ruby (programming language)>[Ruby]: the exact same as Python, and only strong in one domain: <web development>, while Python rules everything else, and is not bad on web either. So just kill Ruby, please.
* <JavaScript>: it is totally fine if <Node.js> destroys <Python> and becomes the ONE scripting language to rule them all since Python and JavaScript are almost equally crappy (although JavaScript is a bit more of course).

  One thing must be said tough: `someobject.not_defined_property` silently returning `undefined` rather than blowing up is <bullshit>.
* <Go (language)>: likely a good replacement for <Python>. If the ecosystem gets there, will gladly use it more.
* <Java>: good language, but has an ugly enterprisey ecosystem, Oracle has made/kept the development process too closed, and https://en.wikipedia.org/wiki/Google_v._Oracle_America[API patenting madness on Android just kills if off completely]
* <Haskell>: many have tried to learn some functional stuff, but too hard. Sounds really cool though.
* Rust: sounds cool, you will gladly replace C and C++ with it if the ecosystem ramps up.
* C#: <Microsoft> is <evil>
* <Tcl>, <Perl (programming language)>: Python killed them way back and is less insane
* R, GNU Octave and any other "<numerical computing language>": all of this is a waste of society's time as explained at: <numerical computing language>{full}
* Swift: Ciro would rather stay away from <Apple> dominated projects if possible since they sell a <closed source> <operating system>

= Programming paradigm
{parent=Programming language}
{wiki}

= Imperative programming
{parent=Programming paradigm}
{wiki}

= Imperative program
{synonym}

= Functional programming
{parent=Programming paradigm}
{tag=Good}
{wiki}

<Good> because <unecessary state is the source of much evil>.

Even if we cannot do everything in functional, we should at least strive to clearly extract functional substes in what we do.

= Unecessary state is the source of much evil
{tag=Ciro Santilli's software engineering wisdom}
{parent=Functional programming}

= Functional programming is a subset of imperative programming
{parent=Functional programming}

<Ciro Santilli> thinks <imperative programming> is just a superset of <functional programming> where you can have state.

= Programming languages without a decent dominating package system
{parent=Programming language}

<C (programming language)>{child} and <C++>{child}: OK, you're old before the Internet and compiled, forgiven.

<Python>{child}: OMG, please, just make it work!!! Your are interpreted!!! You are a hot web technology!!! <Node.js> and <Ruby (programming language)> are doing just fine, and Ruby is not newer than you!!! See also: <pip (package manager)>.

= Compiled vs interpreted programming language
{parent=Programming language}

= Compiled programming language
{parent=Programming language}

= Compiled language
{synonym}

= Interpreted programming language
{parent=Programming language}

Interestingly, the very first programming language with an actual implementation was interpreted: <Short Code (programming-language)> in 1950.

This is not surprising, as interpreters are easier to write than compilers.

And just like modern scripting languages, it reduced execution speed by about 50x.

= List of programming languages
{parent=Programming language}

= Adobe Flash
{c}
{parent=List of programming languages}
{wiki}

= awk
{c}
{parent=List of programming languages}
{title2=1977}
{wiki}

Largest programs ever written:
* https://www.quora.com/What-is-the-most-complex-software-written-in-Awk
* https://github.com/greencardamom/Wikiget/blob/master/wikiget.awk is 2690 lines long. Mentioned at: https://webapps.stackexchange.com/questions/16359/is-there-a-way-to-download-a-list-of-all-wikipedia-categories

= Bash
{disambiguate=Unix shell}
{c}
{parent=List of programming languages}

= Bash
{c}
{synonym}

The more heavily a project relies on it, the more you start to regret it.

= C
{disambiguate=programming language}
{c}
{parent=List of programming languages}
{title2=1972}
{wiki=C++}

= C
{disambiguate=language}
{c}
{synonym}

It gets the job done, but cannot make a large codebase DRY without insanity.

As of 2020, C is like <Latin>, and we are in the <Middle Ages>, where it has become a <lingua franca>.

It is interesting to note how late C appeared: 1972, compared e.g. to <Fortran> which is from 1957. This is basically because C was a "systems programming language", i.e. with focus on pointer manipulation, and because early computers were so weak, there was no operating system or many software layers in the early days. Fortran however was a numerical language, and it ran directly on bare metal, an application that existed before systems programming.

Examples under \a[c].

= ANSI C
{c}
{parent=C (programming language)}
{tag=Closed standard}
{wiki}

A <closed standard>: https://stackoverflow.com/questions/81656/where-do-i-find-the-current-c-or-c-standard-documents[]. Nice.

= C library
{c}
{parent=C (programming language)}
{wiki}

= C POSIX library
{c}
{parent=C library}
{tag=POSIX}
{wiki}

Quick overview at https://stackoverflow.com/questions/1780599/what-is-the-meaning-of-posix/31865755#31865755

Exmples under \a[c/posix]:
* \a[c/posix/signal_return.c]: https://stackoverflow.com/questions/37063212/where-does-signal-handler-return-back-to

= C++
{c}
{parent=List of programming languages}
{wiki}

C plus plus is what you get when you want to have all of:
* ability to write DRY code, which is e.g. impossible in the <C (programming language)>
* low level control, notably not having <garbage collection>, as possible in the <C (programming language)>
* somewhat backwards compatibility with <C (programming language)>

= C#
{id=c-sharp}
{c}
{parent=List of programming languages}
{wiki=C_Sharp_(programming_language)}

= Fortran
{c}
{parent=List of programming languages}
{title2=1957}
{wiki}

= Go
{disambiguate=programming language}
{c}
{parent=List of programming languages}
{wiki}

= Go
{disambiguate=language}
{c}
{synonym}

Likely a good replacement for <Python>. If the ecosystem gets there, <Ciro Santilli> would gladly use it more.

= Haskell
{c}
{parent=List of programming languages}
{wiki}

There are only two pre-requisites to using Haskell in 2020. You have to be an <idealist>. And you have to be a genius:
* https://youtu.be/d8nzFqoEOvE?list=PLAJnaovHtaFTK9E1xHnBWZeKtAOhonqH5&t=558 <Ben Goertzel>

\Image[https://web.archive.org/web/20230127135616im_/https://imgs.xkcd.com/comics/haskell.png]
{title=<xkcd> 1312: <Haskell>}
{source=https://xkcd.com/1312/}

= Java
{disambiguate=programming language}
{c}
{parent=List of programming languages}
{wiki}

= Java
{c}
{synonym}

Java is good.

Its boilerplate requirement is a pain, but the design is otherwise very clean.

But its ecosystem sucks.

The development process is rather closed, the issue tracker obscure.

And above all, <Google LLC v. Oracle America, Inc.> killed everybody's trust in it once and for all. Thanks <Oracle>.

\Video[https://www.youtube.com/watch?v=m4-HM_sCvtQ]
{title=Java for the Haters in 100 Seconds by Fireship (2022)}

= Google LLC v. Oracle America, Inc.
{c}
{parent=Java (programming language)}
{wiki}
{title2=2021}

= Java program
{c}
{parent=Java (programming language)}

= JavaScript
{c}
{parent=List of programming languages}
{wiki}

The language all browsers converted to as of 2019, and therefore the easiest one to distribute and most widely implemented programming language.

Hopefully will be killed by https://en.wikipedia.org/wiki/WebAssembly[WebAssembly] one day.

Because JavaScript is a relatively crap/ad-hoc language, it ended up some decent tooling to make up for that, e.g. stuff like linting via ESLint and reformatting through Prettier is much more widespread than in other languages.

JavaScript data structure are also quite a bit anemic, which makes libraries such as lodash incredibly popular. But most of that stuff should be in the stdlib.

Our JavaScript examples can be found at:
* <Node.js example>: examples that don't interact with any browser feature. We are just testing those on the CLI which is much more convenient.
* <JavaScript browser example>: examples that interact with browser-specific features, notably the DOM

= Client-side storage
{parent=JavaScript}

https://www.google.com/search?q=client-side+storage&oq=Client-side+storage&aqs=chrome.0.0l3j0i22i30l4j69i60.88j0j7&client=ubuntu&sourceid=chrome&ie=UTF-8

= Clear client-side storage
{parent=Client-side storage}

= Clear client-side storage on Chromium
{parent=Clear client-side storage}

* https://superuser.com/questions/366483/how-to-delete-cookies-for-a-specific-site
* https://superuser.com/questions/722498/what-is-the-fastest-way-to-clear-cache-and-cookies-in-google-chrome

= Emscripten
{c}
{parent=JavaScript}
{wiki}

= JavaScript library
{parent=JavaScript}

= Babel
{disambiguate=transcompiler}
{c}
{parent=JavaScript library}
{wiki}

= JavaScript bi-directional communication library
{parent=JavaScript library}
{tag=Push technology}

* https://stackoverflow.com/questions/30419455/server-side-data-push-for-web-services
* https://stackoverflow.com/questions/52146670/bi-directional-communication-between-server-and-client

= Socket.IO
{c}
{parent=JavaScript library}
{wiki}

= JavaScript is single threaded
{c}
{parent=JavaScript}

<Node.js> does have <Node.js worker_threads> however.

= JavaScript language
{c}
{parent=JavaScript}

= `async`
{disambiguate=JavaScript}
{parent=JavaScript language}

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function

`async` is all present in <JavaScript> for two reasons:
* you make network requests all the time
* JavaScript is single threaded, so if you are waiting for a network request, the UI freezes, see remarks on the deprecation of synchronous HTTP request at: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests

However, it is also <Hell>: <how to convert async to sync in JavaScript>.

= How to convert `async` to sync in JavaScript
{parent=async (JavaScript)}

<God>, it's impossible! You just have to convert the entire fucking call stack all the way up to async functions. It could mean refactoring hundreds of functions.

To be fair, there is a logic to this, if you put yourself within the crappiness of the <JavaScript> threading model. And <Python> is not that much better with its <Global Interpreter Lock>.

The problem is that async was introduced relatively late, previously we just had to use infinitely deep callback <tree (data structure)>[trees], which was worse:
``
myAsync().then(ret => myAsync2(ret).then(ret2 => myAsync3(re3)))
``
compared to the new infinitely more readable:
``
ret = await myAsync()
ret2 = await myAsync2(ret)
ret3 = await myAsync3(ret3)
``
But now we are in an endless period of transition between both worlds.

It is also worth mentioning that callbacks are still inescapable if you really want to fan out into a non-linear dependency graph, usually with `Promise.all`:
``
await Promise.all([
  myAsync(1).then(ret => myAsync2(ret)),
  myAsync(2).then(ret => myAsync2(ret)),
])
``

Bibliography:
* https://stackoverflow.com/questions/21819858/how-to-wrap-async-function-calls-into-a-sync-function-in-node-js-or-javascript
* https://stackoverflow.com/questions/9121902/call-an-asynchronous-javascript-function-synchronously
* https://stackoverflow.com/questions/47227550/using-await-inside-non-async-function
* https://stackoverflow.com/questions/43832490/is-it-possible-to-use-await-without-async-in-js
* https://stackoverflow.com/questions/6921895/synchronous-delay-in-code-execution

And then, after many many hours of this work, you might notice that the new code is way, way way slower than before, because making small functions `async` has a large performance impact: https://madelinemiller.dev/blog/javascript-promise-overhead/[]. Real world case with a 4x slowdown: https://github.com/ourbigbook/ourbigbook/tree/async-slow[].

Anyways, since you Googled here, you might as well learn the standard pattern to convert callbacks functions into async functions using a promise: https://stackoverflow.com/questions/4708787/get-password-from-input-using-node-js/71868483#71868483

\Include[node-js]{parent=javascript}
\Include[typescript]{parent=javascript}

= Universal Module Definition
{c}
{parent=JavaScript}
{title2=UMD}
{wiki}

Since <JavaScript> devs are incapable of defining an unified import standard, this design pattern emerged where you just check every magic global one by one. Here's a demo where a Js library works on both the <browser> and from <Node.js>:
* \a[web-cheat/umd_my_lib.js]: the library
* \a[web-cheat/umd.js]: <Node.js> user
* \a[web-cheat/umd.html]: <browser> user

= Perl
{disambiguate=programming language}
{c}
{parent=List of programming languages}
{wiki}

TODO why did <Python> kill it? They are very similar and existed at similar times, and possibly Perl was more popular early on.
* https://www.quora.com/Why-is-Perl-no-longer-a-popular-programming-language on <Quora>

Perl likely killed <Tcl>.

= PHP
{c}
{parent=List of programming languages}
{wiki}

= Pseudocode
{parent=List of programming languages}
{wiki}

= Python
{c}
{disambiguate=programming language}
{parent=List of programming languages}
{wiki}

= Python
{c}
{synonym}

Examples under \a[python].

<Ciro Santilli's wife> was studying a bit of basic Python for some job interviews, when she noticed:
\Q[Wow, `in` is so powerful! You can do `for x in list`, `for x in dict` and `if x in dict` all with that single word!]
Damn right, girl, damn right.

Ciro remembers hearing about <Python> online briefly. It seemed like a distant thing from the <Java>/<C (programming language)> dominated (and outdated) university courses. Then some teaching assistant mentioned during some course when Ciro was at <École Polytechnique> that Python was a great integration tool. That sounded cool.

Then finally, <when the École Polytechnique mathematics department didn't let Ciro Santilli do his internship of choice due to grades> and Ciro was at an useless last moment backup internship, he learned more Python instead of doing his internship job, and was hooked.

= Python language feature
{c}
{parent=Python (programming language)}

= Python classes
{c}
{parent=Python language feature}

= Python special method
{c}
{parent=Python classes}

= Python magic method
{c}
{synonym}

https://docs.python.org/3/reference/datamodel.html#special-method-names

= Python `__getitem__`
{c}
{parent=Python special method}

= python/getitem.py
{file}
{parent=Python `__getitem__`}

= python/getitem_complex.py
{file}
{parent=Python `__getitem__`}

* https://stackoverflow.com/questions/772124/what-does-the-ellipsis-object-do/33087462#33087462
* https://stackoverflow.com/questions/43627405/understanding-getitem-method/75589367#75589367

= Python standard library
{c}
{parent=Python (programming language)}

= Python `abc`
{c}
{parent=Python standard library}

= python/abc_cheat.py
{file}
{parent=Python `abc`}

= Python `dataclass`
{c}
{parent=Python standard library}

= python/infer.py
{parent=Python `dataclass`}

= python/dataclass_cheat.py
{parent=Python `dataclass`}

= python/dataclass_hash.py
{parent=Python `dataclass`}

= Python `typing`
{c}
{parent=Python standard library}
{tag=Good}

Examples under \a[python/typing_cheat].

= python/typing_cheat/hello.py
{c}
{parent=Python `typing`}
{file}

The hello world!

= python/typing_cheat/infer.py
{c}
{parent=Python `typing`}
{file}

= python/typing_cheat/union.py
{c}
{parent=Python `typing`}
{file}

= Python `Protocol`
{c}
{parent=Python `typing`}

= python/typing_cheat/protocol.py
{c}
{file}
{parent=Python `Protocol`}

= python/typing_cheat/protocol_empty.py
{c}
{file}
{parent=Python `Protocol`}

= Zen of Python
{c}
{parent=Python (programming language)}
{tag=The correlation between software engineers and Buddhism}

= The Zen of Python
{c}
{synonym}

= Python implementation
{c}
{parent=Python (programming language)}

= CPython
{c}
{parent=Python implementation}
{wiki}

= Global Interpreter Lock
{c}
{parent=CPython}
{wiki}

https://stackoverflow.com/questions/1294382/what-is-the-global-interpreter-lock-gil-in-cpython

= Cython
{c}
{parent=Python implementation}
{wiki}

= pip
{disambiguate=package manager}
{parent=Python (programming language)}
{wiki}

How many stupid bugs. How many stupid bugs do we need to face???
* this fucking train-wreck cannot come up with a unified documented way of specifying dependencies:
  * https://stackoverflow.com/questions/14399534/reference-requirements-txt-for-the-install-requires-kwarg-in-setuptools-setup-py
  * https://stackoverflow.com/questions/26900328/install-dependencies-from-setup-py
  * https://stackoverflow.com/questions/30797124/how-to-use-setup-py-to-install-dependencies-only/63743115
  * https://stackoverflow.com/questions/6947988/when-to-use-pip-requirements-file-versus-install-requires-in-setup-py
  So basically `requirements.txt` is the `package-lock.json`. But how to generate it cleanly? You would need to create a virtualenv?
* `pip search` was disabled in 2020: https://stackoverflow.com/questions/17373473/how-do-i-search-for-an-available-python-package-using-pip[]. WTF. If server load is a problem, just create a token system! It is hard to understand how such a popular language can't rais enough money to keep such simple server functionality running.

= Python Package Index
{c}
{parent=Python (programming language)}
{wiki}

= PyPI
{c}
{synonym}

https://pypi.org

The best package ever is: https://pypi.org/project/china-dictatorship/ see also: https://cirosantilli.com/china-dictatorship/mirrors

= Python virtualization
{parent=Python (programming language)}

= pyenv
{c}
{parent=Python virtualization}

= virtualenv
{parent=Python virtualization}

``
python3 -m pip install --user virtualenv
virtualenv .venv
. .venv/bin/activate
pip install -r requirements.txt
``

= Python documentation generator
{c}
{parent=Python (programming language)}
{tag=Documentation generator}

= Sphinx
{c}
{disambiguate=documentation generator}
{parent=Python documentation generator}
{wiki}

= Sphinx
{disambiguate=Python}
{synonym}

= python/sphinx
{file}
{parent=Sphinx (documentation generator)}

To run each example and see the output run:
``
./build.sh
xdg-open out/index.html
``

= python/sphinx/hello
{file}
{parent=Sphinx (documentation generator)}

Minimal example. Gives a hint at how boilerplate heavy Sphinx can be!

= python/sphinx/union
{file}
{parent=Sphinx (documentation generator)}

https://stackoverflow.com/questions/34647966/how-to-express-multiple-types-for-a-single-parameter-or-a-return-value-in-docstr/40801906#40801906

= python/sphinx/class
{file}
{parent=Sphinx (documentation generator)}

Basic class example.

= python/sphinx/virtual_method
{file}
{parent=Sphinx (documentation generator)}

<Polymorphism> example:
* https://stackoverflow.com/questions/4714136/how-to-implement-virtual-methods-in-python/38717503#38717503
* https://stackoverflow.com/questions/17841323/how-to-annotate-a-member-as-abstract-in-sphinx-documentation/75634909#75634909

= Python library
{c}
{parent=Python (programming language)}

= Python scientific library
{c}
{parent=Python library}
{wiki}

= Jupyter Notebook
{c}
{parent=Python scientific library}
{wiki=Project_Jupyter#Jupyter_Notebook}

A waste of time. Output in my source files https://stackoverflow.com/questions/28908319/how-to-clear-an-ipython-notebooks-output-in-all-cells-from-the-linux-terminal/47774393#47774393[pollutes git] and prevents me from editing it in <Vim>. Just let me run the freacking code and render images as standalone PNGs which I can include from Markdown.

Some other basic hits due to how bad Jupyter is:
* https://stackoverflow.com/questions/41159797/how-to-disable-password-request-for-a-jupyter-notebook-session/47509274#47509274
* https://stackoverflow.com/questions/36901154/how-export-a-jupyter-notebook-to-html-from-the-command-line/47773056#47773056

= python/jupyter/hello.ipynb
{file}
{parent=Jupyter Notebook}

= NumPy
{c}
{parent=Python scientific library}
{wiki}

The people who work on this will <good>[go straight to heaven], no questions asked.

= Scikit-learn
{c}
{parent=Python scientific library}
{wiki}

Examples under \a[python/sklearn]

``
. .venv/bin/activate
pip install sklearn matplotlib seaborn
``

= Python web framework
{c}
{parent=Python library}

= Django
{disambiguate=web-framework}
{c}
{parent=Python web framework}
{wiki}

<React> setups:
* https://stackoverflow.com/questions/41867055/how-to-get-django-and-reactjs-to-work-together
* https://www.fullstackpython.com/react.html

One problem with Django is that it does not expose its <ORM> as an external library: https://stackoverflow.com/questions/33170016/how-to-use-django-1-8-5-orm-without-creating-a-django-project which is wasteful of development time.

= gothinkster/django-realworld-example-app
{parent=Django (web-framework)}

As of 2021, last updated 2016, and python 3.5 appears to be mandatory or else:
``
RuntimeError: __class__ not set defining 'AbstractBaseUser' as <class 'django.contrib.auth.base_user.AbstractBaseUser'>. Was __classcell__ propagated to type.__new__?
``
which apparently broke in 3.6: https://stackoverflow.com/questions/41343263/provide-classcell-example-for-python-3-6-metaclass and `pyenv` install fails on Ubuntu 20.10, so... fuck. Workarounds at:
* https://askubuntu.com/questions/1034475/the-python-ssl-extension-was-not-compiled-missing-the-openssl-lib-error-when
* https://stackoverflow.com/questions/52873193/error-the-python-ssl-extension-was-not-compiled-missing-the-openssl-lib-inst
but am I in the mood considering that the ancient Django version would require an immediate port anyways? Repo is at Django 1.0, while newest is now already Django 3. The Rails one is broken for the same reason. Fuck 2.

= Ruby
{disambiguate=programming language}
{c}
{parent=List of programming languages}
{wiki}

= Ruby on Rails
{c}
{parent=Ruby (programming language)}
{wiki}

The only reason why <Ruby (programming language)> exists.

This web framework is pretty good as of 2020 compared to others, because it managed to gain a critical community size, and there's a lot of basic setup already done for you.

it is just big shame it wasn't written in <Python> or even better, <Node.js>, because learning <Ruby (programming language)> is completely useless for anything else. As of 2020 for example, most <Node.js> web frameworks feel like crap compared to Rails, you just have to debug so much there.

Used in <GitLab>, which is why <Ciro Santilli> touched it.

= Ruby on Rails React integration
{c}
{parent=Ruby on Rails}

Integrations <React> integration:
* https://github.com/shakacode/react_on_rails[]: <webpack> and <server-side rendering>
* https://github.com/reactjs/react-rails Official on the React side only. Demo app linked from package: https://github.com/BookOfGreg/react-rails-example-app and how it fails: https://github.com/BookOfGreg/react-rails-example-app/issues/30[]... The related projects section has some good links:
* <shakacode react_on_rails>
* https://github.com/hyperstack-org/hyperstack <transpiles> Ruby to JavaScript + React. What could possibly go wrong? :-)

= shakacode/react_on_rails
{parent=Ruby on Rails React integration}

Uses Redux, while reactjs/react-rails appears to do that more manually

Lots of focus on <Heroku> deployability, which is fantastic: https://shakacode.gitbooks.io/react-on-rails/content/docs/additional-reading/heroku-deployment.html

Live instance: https://www.reactrails.com/ with source at: https://github.com/shakacode/react-webpack-rails-tutorial Not the most advanced web-app (a <gothinkster realworld>-level would be ideal). Also has clear dependency description, which is nice.

Trying at https://github.com/shakacode/react-webpack-rails-tutorial/tree/8e656f97d7a311bbe999ceceb9463b8479fef9e2 on <Ubuntu> 20.10. Got some failures: https://github.com/shakacode/react-webpack-rails-tutorial/issues/488 Finally got a version of it working at: https://github.com/shakacode/react-webpack-rails-tutorial/issues/488#issuecomment-812506821

Oh, and the guy behind that project lives in <Hawaii> (<Ciro Santilli's ideal city to live in>), has an Asian-mixed son, and two <Kinesis Advantage 2 keyboards> as seen at https://twitter.com/railsonmaui/status/1377515748910755851[], <Ciro Santilli> was jealous of him.

= Rust
{c}
{disambiguate=programming language}
{parent=List of programming languages}
{wiki}

= Rust
{c}
{disambiguate=language}
{synonym}

= Short Code
{disambiguate=programming-language}
{c}
{parent=List of programming languages}
{title2=1950}
{wiki=Short_Code_(computer_language)}

= Tcl
{c}
{parent=List of programming languages}
{wiki}

One of the first big <interpreted programming languages> to go a bit further than <Bash>' word replacement insanity.

To the modern viewer, it feels like a middle ground between <Bash> and <Python>.

It was completely insane however, and it just died: <Python> is much saner, and <Bash>, although totally insane still <code golf>[golfs] better, especially on the file manipulation context.

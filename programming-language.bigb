= Programming language
{wiki}

A language that allows you to talk to and command a \x[computer].

There is only space for two languages at most in the world: the \x[compiled-programming-language][compiled] one, and the \x[interpreted-programming-language][interpreted] one.

For 2020 now, when you have a choice, you must go for:
* \x[python] as the interpreted one
* \x[c-plus-plus] for compiled

Those two are languages not by any means perfect from a language design point of view, and there are likely already better alternatives, they are only chosen due to a pragmatic tradeoff between ecosystem and familiarity.

Ciro predicts that Python will become like \x[fortran] in the future: a legacy hated by most who have moved to \x[javascript] long ago (which is slightly inferior, but too similar, and with too much web dominance to be replaced), but with too much dominance in certain applications like machine learning to be worth replacing, like Fortran dominates certain HPC applications. We'll see. Maybe non performance critical scripting languages are easier to replace.

\x[c-plus-plus] however is decent, and is evolving in very good directions in the 2010's, and will remain relevant in the foreseeable future.

\x[bash] can also be used when you're lazy. But if the project goes on, you will sooner or later regret that choice.

The language syntax in itself does not matter. All that matters is how many useful libraries and tooling it has.

This is how other languages compare:
* \x[c-programming-language][C]: but cannot make a large codebase \x[dry] without insanity
* \x[ruby-programming-language][Ruby]: the exact same as Python, and only strong in one domain: \x[web-development], while Python rules everything else, and is not bad on web either. So just kill Ruby, please.
* \x[javascript]: it is totally fine if \x[node-js] destroys \x[python] and becomes the ONE scripting language to rule them all since Python and JavaScript are almost equally crappy (although JavaScript is a bit more of course).

  One thing must be said tough: `someobject.not_defined_property` silently returning `undefined` rather than blowing up is \x[bullshit].
* \x[go-language]: likely a good replacement for \x[python]. If the ecosystem gets there, will gladly use it more.
* \x[java]: good language, but has an ugly enterprisey ecosystem, Oracle has made/kept the development process too closed, and https://en.wikipedia.org/wiki/Google_v._Oracle_America[API patenting madness on Android just kills if off completely]
* \x[haskell]: many have tried to learn some functional stuff, but too hard. Sounds really cool though.
* Rust: sounds cool, you will gladly replace C and C++ with it if the ecosystem ramps up.
* C#: \x[microsoft] is \x[evil]
* \x[tcl], \x[perl-programming-language]: Python killed them way back and is less insane
* R, GNU Octave and any other "\x[numerical-computing-language]": all of this is a waste of society's time as explained at: \x[numerical-computing-language]{full}
* Swift: Ciro would rather stay away from \x[apple] dominated projects if possible since they sell a \x[closed-source] \x[operating-system]

= Programming languages without a decent dominating package system
{parent=programming-language}

\x[c-programming-language]{child} and \x[c-plus-plus]{child}: OK, you're old before the Internet and compiled, forgiven.

\x[python]{child}: OMG, please, just make it work!!! Your are interpreted!!! You are a hot web technology!!! \x[node-js] and \x[ruby-programming-language] are doing just fine, and Ruby is not newer than you!!! See also: \x[pip-package-manager].

= Compiled vs interpreted programming language
{parent=programming-language}

= Compiled programming language
{parent=programming-language}

= Interpreted programming language
{parent=programming-language}

Interestingly, the very first programming language with an actual implementation was interpreted: \x[short-code-programming-language] in 1950.

This is not surprising, as interpreters are easier to write than compilers.

And just like modern scripting languages, it reduced execution speed by about 50x.

= List of programming languages
{parent=programming-language}

= Adobe Flash
{c}
{parent=list-of-programming-languages}
{wiki}

= Bash
{c}
{disambiguate=Unix shell}
{parent=list-of-programming-languages}

= Bash
{c}
{synonym}

The more heavily a project relies on it, the more you start to regret it.

= C
{c}
{disambiguate=programming language}
{parent=list-of-programming-languages}
{title2=1972}
{wiki=C++}

= C
{c}
{disambiguate=language}
{synonym}

It gets the job done, but cannot make a large codebase DRY without insanity.

As of 2020, C is like \x[latin], and we are in the \x[middle-ages], where it has become a \x[lingua-franca].

It is interesting to note how late C appeared: 1972, compared e.g. to \x[fortran] which is from 1957. This is basically because C was a "systems programming language", i.e. with focus on pointer manipulation, and because early computers were so weak, there was no operating system or many software layers in the early days. Fortran however was a numerical language, and it ran directly on bare metal, an application that existed before systems programming.

= ANSI C
{c}
{parent=c-programming-language}
{wiki}

= C++
{c}
{parent=list-of-programming-languages}
{wiki}

C plus plus is what you get when you want to have all of:
* ability to write DRY code, which is e.g. impossible in the \x[c-programming-language]
* low level control, notably not having \x[garbage-collection], as possible in the \x[c-programming-language]
* somewhat backwards compatibility with \x[c-programming-language]

= C#
{c}
{id=c-sharp}
{parent=list-of-programming-languages}
{wiki=C_Sharp_(programming_language)}

= Fortran
{c}
{parent=list-of-programming-languages}
{title2=1957}
{wiki}

= Go
{c}
{disambiguate=programming language}
{parent=list-of-programming-languages}
{wiki}

= Go
{c}
{disambiguate=language}
{synonym}

Likely a good replacement for \x[python]. If the ecosystem gets there, \x[ciro-santilli] would gladly use it more.

= Haskell
{c}
{parent=list-of-programming-languages}
{wiki}

There are only two pre-requisites to using Haskell in 2020. You have to be an \x[idealist]. And you have to be a genius:
* https://youtu.be/d8nzFqoEOvE?list=PLAJnaovHtaFTK9E1xHnBWZeKtAOhonqH5&t=558 \x[ben-goertzel]

= Java
{c}
{disambiguate=programming language}
{parent=list-of-programming-languages}
{wiki}

= Java
{c}
{synonym}

Java is good. But its ecosystem sucks. Its boilerplate requirement is a pain, but the design is otherwise very clean.

\Video[https://www.youtube.com/watch?v=m4-HM_sCvtQ]
{title=Java for the Haters in 100 Seconds by Fireship (2022)}

= Java program
{c}
{parent=java-programming-language}

= JavaScript
{c}
{parent=list-of-programming-languages}
{wiki}

The language all browsers converted to as of 2019, and therefore the easiest one to distribute and most widely implemented programming language.

Hopefully will be killed by https://en.wikipedia.org/wiki/WebAssembly[WebAssembly] one day.

Because JavaScript is a relatively crap/ad-hoc language, it ended up some decent tooling to make up for that, e.g. stuff like linting via ESLint and reformatting through Prettier is much more widespread than in other languages.

JavaScript data structure are also quite a bit anemic, which makes libraries such as lodash incredibly popular. But most of that stuff should be in the stdlib.

Cheat:
* \a[web-cheat/js-image-load.html]: load an image from JavaScript dynamically: https://stackoverflow.com/questions/226847/what-is-the-best-javascript-code-to-create-an-img-element
* \a[web-cheat/js-image-load-viewport.html]: load an image from JavaScript dynamically when it would become visible on the viewport: https://stackoverflow.com/questions/2321907/how-do-you-make-images-load-only-when-they-are-in-the-viewport
* \a[web-cheat/image-load-lazy.html]: https://stackoverflow.com/questions/2321907/how-do-you-make-images-load-lazily-only-when-they-are-in-the-viewport/57389607#57389607
* \a[web-cheat/esm.html]: ESM modules
  * \a[web-cheat/esm1.js]
  * \a[web-cheat/esm2.js]
* \a[web-cheat/keydown.html]
  * https://stackoverflow.com/questions/16006583/capturing-ctrlz-key-combination-in-javascript

= Client-side storage
{parent=javascript}

https://www.google.com/search?q=client-side+storage&oq=Client-side+storage&aqs=chrome.0.0l3j0i22i30l4j69i60.88j0j7&client=ubuntu&sourceid=chrome&ie=UTF-8

= Clear client-side storage
{parent=client-side-storage}

= Clear client-side storage on Chromium
{parent=clear-client-side-storage}

* https://superuser.com/questions/366483/how-to-delete-cookies-for-a-specific-site
* https://superuser.com/questions/722498/what-is-the-fastest-way-to-clear-cache-and-cookies-in-google-chrome

= Emscripten
{c}
{parent=javascript}
{wiki}

= JavaScript library
{parent=javascript}

= Babel
{c}
{disambiguate=transcompiler}
{parent=javascript-library}
{wiki}

= JavaScript bi-directional communication library
{parent=javascript-library}
{tag=push-technology}

* https://stackoverflow.com/questions/30419455/server-side-data-push-for-web-services
* https://stackoverflow.com/questions/52146670/bi-directional-communication-between-server-and-client

= Socket.IO
{c}
{parent=javascript-library}
{wiki}

= JavaScript is single threaded
{c}
{parent=javascript}

\x[node-js] does have \x[node-js-worker-threads] however.

= JavaScript language
{c}
{parent=javascript}

= `async`
{disambiguate=JavaScript}
{parent=javascript-language}

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function

`async` is all present in \x[javascript] for two reasons:
* you make network requests all the time
* JavaScript is single threaded, so if you are waiting for a network request, the UI freezes, see remarks on the deprecation of synchronous HTTP request at: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests

However, it is also \x[hell]: \x[how-to-convert-async-to-sync-in-javascript].

= How to convert `async` to sync in JavaScript
{parent=async-javascript}

God, it's impossible! You just have to convert the entire fucking call stack all the way up to async functions. It could mean refactoring hundreds of functions.

To be fair, there is a logic to this, if you put yourself within the crappiness of the JavaScript threading model. And \x[python] is not that much better with its \x[global-interpreter-lock].

The problem is that async was introduced relatively late, previously we just had to use infinitely deep callback trees, which was worse. But now we are in an endless period of transition between both worlds.

* https://stackoverflow.com/questions/21819858/how-to-wrap-async-function-calls-into-a-sync-function-in-node-js-or-javascript
* https://stackoverflow.com/questions/9121902/call-an-asynchronous-javascript-function-synchronously
* https://stackoverflow.com/questions/47227550/using-await-inside-non-async-function
* https://stackoverflow.com/questions/43832490/is-it-possible-to-use-await-without-async-in-js
* https://stackoverflow.com/questions/6921895/synchronous-delay-in-code-execution

And then, after many many hours of this work, you might notice that the new code is way, way way slower than before, because making small functions `async` has a large performance impact: https://madelinemiller.dev/blog/javascript-promise-overhead/[]. Real world case with a 4x slowdown: https://github.com/cirosantilli/ourbigbook/tree/async-slow[].

Anyways, since you Googled here, you might as well learn the standard pattern to convert callbacks functions into async functions using a promise: https://stackoverflow.com/questions/4708787/get-password-from-input-using-node-js/71868483#71868483

\Include[node-js]{parent=javascript}
\Include[typescript]{parent=javascript}

= Universal Module Definition
{c}
{parent=javascript}
{title2=UMD}
{wiki}

Since \x[javascript] devs are incapable of defining an unified import standard, this design pattern emerged where you just check every magic global one by one. Here's a demo where a Js library works on both the \x[browser] and from \x[node-js]:
* \a[web-cheat/umd_my_lib.js]: the library
* \a[web-cheat/umd.js]: \x[node-js] user
* \a[web-cheat/umd.html]: \x[browser] user

= Perl
{c}
{disambiguate=programming language}
{parent=list-of-programming-languages}
{wiki}

TODO why did \x[python] kill it? They are very similar and existed at similar times, and possibly Perl was more popular early on.
* https://www.quora.com/Why-is-Perl-no-longer-a-popular-programming-language on \x[quora]

Perl likely killed \x[tcl].

= Python
{c}
{disambiguate=programming language}
{parent=list-of-programming-languages}
{wiki}

= Python
{c}
{synonym}

\x[ciro-santilli-s-wife] was studying a bit of basic Python for some job interviews, when she noticed:
\Q[Wow, `in` is so powerful! You can do `for x in list`, `for x in dict` and `if x in dict` all with that single word!]
Damn right, girl, damn right.

Ciro remembers hearing about \x[python] online briefly. It seemed like a distant thing from the \x[java]/\x[c-programming-language] dominated (and outdated) university courses. Then some teaching assistant mentioned during some course when Ciro was at \x[ecole-polytechnique] that Python was a great integration tool. That sounded cool.

Then finally, \x[when-the-ecole-polytechnique-mathematics-department-didn-t-let-ciro-santilli-do-his-internship-of-choice-due-to-grades] and Ciro was at an useless last moment backup internship, he learned more Python instead of doing his internship job, and was hooked.

= CPython
{c}
{parent=python-programming-language}
{wiki}

= Global Interpreter Lock
{parent=cpython}
{wiki}

https://stackoverflow.com/questions/1294382/what-is-the-global-interpreter-lock-gil-in-cpython

= pip
{disambiguate=package manager}
{parent=python-programming-language}
{wiki}

How many stupid bugs. How many stupid bugs do we need to face???
* this fucking train-wreck cannot come up with a unified documented way of specifying dependencies:
  * https://stackoverflow.com/questions/14399534/reference-requirements-txt-for-the-install-requires-kwarg-in-setuptools-setup-py
  * https://stackoverflow.com/questions/26900328/install-dependencies-from-setup-py
  * https://stackoverflow.com/questions/30797124/how-to-use-setup-py-to-install-dependencies-only/63743115
  * https://stackoverflow.com/questions/6947988/when-to-use-pip-requirements-file-versus-install-requires-in-setup-py
  So basically `requirements.txt` is the `package-lock.json`. But how to generate it cleanly? You would need to create a virtualenv?
* `pip search` was disabled in 2020: https://stackoverflow.com/questions/17373473/how-do-i-search-for-an-available-python-package-using-pip[]. WTF. If server load is a problem, just create a token system! It is hard to understand how such a popular language can't rais enough money to keep such simple server functionality running.

= Python Package Index
{c}
{parent=python-programming-language}
{wiki}

= PyPI
{c}
{synonym}

https://pypi.org

The best package ever is: https://pypi.org/project/china-dictatorship/ see also: https://cirosantilli.com/china-dictatorship/mirrors

= Jupyter Notebook
{c}
{parent=python-programming-language}
{wiki=Project_Jupyter#Jupyter_Notebook}

A waste of time. Output in my source files https://stackoverflow.com/questions/28908319/how-to-clear-an-ipython-notebooks-output-in-all-cells-from-the-linux-terminal/47774393#47774393[pollutes git] and prevents me from editing it in \x[vim]. Just let me run the freacking code and render images as standalone PNGs which I can include from Markdown.

= Python virtualization
{parent=python-programming-language}

= pyenv
{c}
{parent=python-virtualization}

= virtualenv
{parent=python-virtualization}

``
python -m pip install --user virtualenv
virtualenv -p python3.8 .venv
. .venv/bin/activate
``

= Python library
{c}
{parent=python-programming-language}

= NumPy
{c}
{parent=python-library}
{wiki}

The people who work on this will \x[good][go straight to heaven], no questions asked.

= Python web framework
{c}
{parent=python-library}

= Django
{c}
{disambiguate=web-framework}
{parent=python-web-framework}
{wiki}

\x[react] setups:
* https://stackoverflow.com/questions/41867055/how-to-get-django-and-reactjs-to-work-together
* https://www.fullstackpython.com/react.html

One problem with Django is that it does not expose its \x[orm] as an external library: https://stackoverflow.com/questions/33170016/how-to-use-django-1-8-5-orm-without-creating-a-django-project which is wasteful of development time.

= gothinkster/django-realworld-example-app
{parent=django-web-framework}

As of 2021, last updated 2016, and python 3.5 appears to be mandatory or else:
``
RuntimeError: __class__ not set defining 'AbstractBaseUser' as <class 'django.contrib.auth.base_user.AbstractBaseUser'>. Was __classcell__ propagated to type.__new__?
``
which apparently broke in 3.6: https://stackoverflow.com/questions/41343263/provide-classcell-example-for-python-3-6-metaclass and `pyenv` install fails on Ubuntu 20.10, so... fuck. Workarounds at:
* https://askubuntu.com/questions/1034475/the-python-ssl-extension-was-not-compiled-missing-the-openssl-lib-error-when
* https://stackoverflow.com/questions/52873193/error-the-python-ssl-extension-was-not-compiled-missing-the-openssl-lib-inst
but am I in the mood considering that the ancient Django version would require an immediate port anyways? Repo is at Django 1.0, while newest is now already Django 3. The Rails one is broken for the same reason. Fuck 2.

= Ruby
{disambiguate=programming language}
{parent=list-of-programming-languages}
{c}
{wiki}

= Ruby on Rails
{parent=ruby-programming-language}
{c}
{wiki}

The only reason why \x[ruby-programming-language] exists.

This web framework is pretty good as of 2020 compared to others, because it managed to gain a critical community size, and there's a lot of basic setup already done for you.

it is just big shame it wasn't written in \x[python] or even better, \x[node-js], because learning \x[ruby-programming-language] is completely useless for anything else. As of 2020 for example, most \x[node-js] web frameworks feel like crap compared to Rails, you just have to debug so much there.

Used in \x[gitlab], which is why \x[ciro-santilli] touched it.

= Ruby on Rails React integration
{c}
{parent=ruby-on-rails}

Integrations \x[react] integration:
* https://github.com/shakacode/react_on_rails[]: \x[webpack] and \x[server-side-rendering]
* https://github.com/reactjs/react-rails Official on the React side only. Demo app linked from package: https://github.com/BookOfGreg/react-rails-example-app and how it fails: https://github.com/BookOfGreg/react-rails-example-app/issues/30[]... The related projects section has some good links:
* \x[shakacode-react-on-rails]
* https://github.com/hyperstack-org/hyperstack \x[transpiles] Ruby to JavaScript + React. What could possibly go wrong? :-)

= shakacode/react_on_rails
{parent=ruby-on-rails-react-integration}

Uses Redux, while reactjs/react-rails appears to do that more manually

Lots of focus on \x[heroku] deployability, which is fantastic: https://shakacode.gitbooks.io/react-on-rails/content/docs/additional-reading/heroku-deployment.html

Live instance: https://www.reactrails.com/ with source at: https://github.com/shakacode/react-webpack-rails-tutorial Not the most advanced web-app (a \x[gothinkster-realworld]-level would be ideal). Also has clear dependency description, which is nice.

Trying at https://github.com/shakacode/react-webpack-rails-tutorial/tree/8e656f97d7a311bbe999ceceb9463b8479fef9e2 on \x[ubuntu] 20.10. Got some failures: https://github.com/shakacode/react-webpack-rails-tutorial/issues/488 Finally got a version of it working at: https://github.com/shakacode/react-webpack-rails-tutorial/issues/488#issuecomment-812506821

Oh, and the guy behind that project lives in \x[hawaii] (\x[ciro-santilli-s-ideal-city-to-live-in]), has an Asian-mixed son, and two \x[kinesis-advantage-2-keyboard]{p} as seen at https://twitter.com/railsonmaui/status/1377515748910755851[], \x[ciro-santilli] was jealous of him.

= Short Code
{c}
{disambiguate=programming-language}
{parent=list-of-programming-languages}
{title2=1950}
{wiki=Short_Code_(computer_language)}

= Tcl
{c}
{parent=list-of-programming-languages}
{wiki}

One of the first big \x[interpreted-programming-language]{p} to go a bit further than \x[bash]' word replacement insanity.

To the modern viewer, it feels like a middle ground between \x[bash] and \x[python].

It was completely insane however, and it just died: \x[python] is much saner, and \x[bash], although totally insane still \x[code-golf][golfs] better, especially on the file manipulation context.

= Mathematics
{wiki}

= Mathematical
{synonym}

= Mathematically
{synonym}

= Math
{synonym}

= Maths
{synonym}

= Mathy
{synonym}

The proper precise definition of mathematics can be found at: <formalization of mathematics>{full}.

The most beautiful things in mathematics are described at: <the beauty of mathematics>{full}.

\Image[https://web.archive.org/web/20220604093553im_/https://bird.trom.tf/pic/media%2FFToTqgKUEAAxdN9.jpg%3Fname%3Dsmall]
{title=Study <Hilbert spaces> https://knowyourmeme.com/memes/desert-dilemma[desert dilemma] meme}
{description=Applies to almost all of <mathematics> of course. But we don't care, do we!}
{height=600}
{source=https://bird.trom.tf/Lavoisierbug/status/1529556647290449921#m}

= The beauty of mathematics
{parent=Mathematics}

<Ciro Santilli> intends to move his beauty list here little by little: https://github.com/cirosantilli/mathematics/blob/master/beauty.md

The most beautiful things in mathematics are results that are:
* <simple to state but hard to prove>:
  * Fermat's Last Theorem
  * <number of unknown rationality>, e.g. is $e + \pi$ <rational>?
  * <transcendental number conjectures>, e.g. is $e + \pi$ transcendental?
  * basically any conjecture involving <prime numbers>:
    * <twin prime conjecture>
  * many combinatorial game questions, e.g.:
    * <first-move advantage in chess>
* surprising results: we had intuitive reasons to believe something as possible or not, but a theorem shatters that conviction and brings us on our knees, sometimes via <pathological (mathematics)> counter-examples. General surprise themes include:
  * <classification (mathematics)> of potentially <infinite> sets like: compact <manifolds>, etc.
    * <classification of finite simple groups>
    * <classification of regular polytopes>
    * <classification of closed surfaces>, and more <generalized Poincaré conjectures>
    * classification of <wallpaper groups> and <space groups>
  * problems that are more complicated in low dimensions than high like:
    * <generalized Poincaré conjectures>. It is also fun to see how in many cases complexity peaks out at 4 dimensions.
    * <classification of regular polytopes>
  * unpredictable magic constants:
    * why is the lowest dimension for an <exotic sphere> 7?
    * why is 4 the largest degree of an equation with explicit solution? <Abel-Ruffini theorem>
  * <undecidable problems>, especially simple to state ones:
    * <mortal matrix problem>
    * sharp frontiers between solvable and unsolvable are also cool:
      * attempts at determining <specific values of the Busy beaver function> for <Turing machines> with a given number of states and symbols
      * related to <Diophantine equations>:
        * <decidability of Hilbert's tenth problem of a given degree and number of variables>
        * <Hilbert's tenth problem over other rings>
  Lists:
  * https://math.stackexchange.com/questions/139699/what-are-some-examples-of-a-mathematical-result-being-counterintuitive
  * https://math.stackexchange.com/questions/2040811/what-are-some-counter-intuitive-results-in-mathematics-that-involve-only-finite/2055458#2055458
* applications: make life easier and/or modeling some phenomena well, e.g. in <physics>. See also: <how to teach/explain how to make money with the lesson>

Good lists of such problems <Lists of mathematical problems>.

Whenever <Ciro Santilli> learns a bit of <mathematics>, he always wonders to himself:
> Am I achieving insight, or am I just memorizing definitions?
Unfortunately, due to how man books are written, it is not really possible to reach insight without first doing a bit of memorization. The better the book, the more insight is spread out, and less you have to learn before reaching each insight.

= Simple to state but hard to prove
{parent=The beauty of mathematics}

One of the most beautiful things in mathematics are theorems of conjectures that are very simple to state and understand (e.g. for <K-12>, lower <undergrad> levels), but extremely hard to prove.

This is in contrast to conjectures in certain areas where you'd have to study for a few months just to precisely understand all the definitions and the interest of the problem statement.

Bibliography:
* https://mathoverflow.net/questions/75698/examples-of-seemingly-elementary-problems-that-are-hard-to-solve
* https://www.reddit.com/r/mathematics/comments/klev7b/whats_your_favorite_easy_to_state_and_understand/
* https://mathoverflow.net/questions/42512/awfully-sophisticated-proof-for-simple-facts this one is for proofs for which simpler proofs exist
* https://math.stackexchange.com/questions/415365/it-looks-straightforward-but-actually-it-isnt this one is for "there is some reason it looks easy", whatever that means

= The Hundred Greatest Theorems by Paul and Jack Abad (1999)
{parent=The beauty of mathematics}

Randomly reproduced at: http://web.archive.org/web/20080105074243/http://personal.stevens.edu/~nkahl/Top100Theorems.html

= Classification
{disambiguate=mathematics}
{parent=The beauty of mathematics}
{wiki}

= Classifying
{disambiguate=mathematics}
{synonym}

In <mathematics>, a "classification" means making a list of all possible objects of a given type.

Classification results are some of <Ciro Santilli>'s favorite: <the beauty of mathematics>{full}.

Examples:
* <classification of finite simple groups>
* <classification of regular polytopes>
* <classification of closed surfaces>, and more generalized <generalized Poincaré conjectures>
* <classification of associative real division algebras>
* <classification of finite fields>
* <classification of simple Lie groups>
* classification of the <wallpaper groups> and the <space groups>

= Pathological
{disambiguate=mathematics}
{parent=The beauty of mathematics}
{wiki}

= Exceptional object
{parent=Pathological (mathematics)}
{wiki}

Oh, and the dude who created the https://en.wikipedia.org/wiki/Exceptional_object <Wikipedia> page won an Oscar: https://www.youtube.com/watch?v=oF_FLN-TmCY[], Dan Piponi, aka `@sigfpe`. Cool dude.

Cool examples:
* <sporadic group>

= Exceptional isomorphism
{parent=Exceptional object}
{wiki}

= Lists of mathematical problems
{c}
{parent=The beauty of mathematics}
{wiki}

Good place to hunt for <the beauty of mathematics>.

= Hilbert's problems
{c}
{parent=Lists of mathematical problems}
{wiki}

He's a bit overly obsessed with <polynomials> for the taste of modern maths, but it's still fun.

= Landau's problems
{c}
{parent=Lists of mathematical problems}
{wiki}

= Millennium Prize Problems
{c}
{parent=Lists of mathematical problems}
{wiki}

<Ciro Santilli> would like to fully understand the statements and motivations of each the problems!

Easy to understand the motivation:
* <Navier-Stokes existence and smoothness> is basically the only problem that is really easy to understand the statement and motivation :-)
* <p versus NP problem>

Hard to understand the motivation!
* <Riemann hypothesis>: a bunch of results on prime numbers, and therefore possible applications to <cryptography>

  Of course, everything of interest has already been proved conditionally on it, and the likely "true" result will in itself not have any immediate applications.

  As is often the case, the only usefulness would be possible new ideas from the proof technique, and people being more willing to prove stuff based on it without the risk of the hypothesis being false.
* <Yang-Mills existence and mass gap>: this one has to do with finding/proving the existence of a more decent formalization of <quantum field theory> that does not resort to tricks like <perturbation theory> and <effective field theory> with a random cutoff value

  This is important because the best theory of light and electrons (and therefore chemistry and material science) that we have today, <quantum electrodynamics>, is a <quantum field theory>.

= Functional equation
{parent=Mathematics}
{wiki}

= Cauchy's functional equation
{parent=Functional equation}
{wiki}

Nice result on <Lebesgue measurable> required for uniqueness.

= Area of mathematics
{parent=Mathematics}

\Include[formalization-of-mathematics]{parent=Area of mathematics}
\Include[algebra]{parent=Area of mathematics}
\Include[calculus]{parent=Area of mathematics}
\Include[geometry]{parent=Area of mathematics}

= Number theory
{parent=Area of mathematics}
{wiki}

= Arithmetic
{parent=Number theory}
{wiki}

Definition: "easy" number theory learnt in <primary school>, notably the operations of <addition>, <subtraction>, <multiplication> and <division>.

= Computational number theory
{parent=Number theory}
{wiki}

= Modular arithmetic
{parent=Number theory}
{wiki}

= Modulo operation
{parent=Modular arithmetic}
{wiki}

= Modulo
{synonym}

= Modular multiplication
{parent=Modular arithmetic}

= Modular multiplicative inverse
{parent=Modular multiplication}

= Modular exponentiation
{parent=Modular arithmetic}
{wiki}

Can be calculated efficiently with the <Extended Euclidean algorithm>.

= Computational complexity of modular exponentiation
{parent=Modular exponentiation}

https://math.stackexchange.com/questions/2382011/computational-complexity-of-modular-exponentiation-from-rosens-discrete-mathem mentions:
$$
b^n mod m
$$
can be calculated in:
$$
log(m)^2 log(n)
$$
Remember that $log(m)$ and $log(n)$ are the lengths in bits of $m$ and $n$, so in terms of the length in bits $M$ and $N$ we'd get:
$$
M^2 N
$$

= Lowest common denominator
{parent=Number theory}
{title2=LCD}
{wiki}

= Prime number
{parent=Number theory}
{wiki}

= Prime
{synonym}

= Type of prime number
{parent=Prime number}
{wiki=List_of_prime_numbers}

This section is about <prime numbers> that satisfy further properties beyond just being a <prime>.

= Are there infinitely many primes with property X
{parent=Type of prime number}

There are infinitely many conjectures asking if such types of primes also form infinite families.

Usually the answer is yes, but no one was able to prove it yet.

Collaborative mega list: https://math.stackexchange.com/questions/4523193/are-there-infinitely-many-primes-of-the-form-x-we-probably-dont-know

Good section also at: https://en.wikipedia.org/wiki/List_of_unsolved_problems_in_mathematics#Prime_numbers

= Mersenne prime
{c}
{parent=Type of prime number}
{title2=$2^n - 1$}
{wiki}

= Are there infinitely many Mersenne primes?
{parent=Mersenne prime}
{tag=Famous conjecture}
{tag=Are there infinitely many primes with property X}

= Lucas-Lehmer primality test
{c}
{parent=Mersenne prime}
{tag=Primality test}
{wiki}

= Prime k-tuple
{parent=Type of prime number}
{title2=p, p+i, p+j...}
{wiki}

= Admissible prime k-tuple
{parent=Prime k-tuple}

= Prime k-tuple conjecture
{parent=Admissible prime k-tuple}

There are infinitely many <prime k-tuples> for every admissible tuple.

Generalization of the <Twin prime conjecture>.

As of 2023, there was no specific admissible tuple for which it had been proven that there infinite of, only bounds of type:
> there are infinitely 2-tuple instances with at most a finite bound
But these do not specify which specific tuple, e.g. <Yitang Zhang's theorem>.

= Yitang Zhang's theorem
{parent=Prime k-tuple conjecture}
{title2=2013}

There are infinitely many primes with a neighbor not further apart than 70 million. This was the first such finite bound to be proven, and therefore a major breakthrough.

This implies that for at least one value (or more) below 70 million there are infinitely many repetitions, but we don't know which e.g. we could have infinitely many:
$$
k, k + 2
$$
or infinitely many:
$$
k, k + 4
$$
or infinitely many:
$$
k, k + 6,999,999
$$
or infinitely many:
$$
k, k + 2 and k, k + 4
$$
but we don't know which of those.

The <Prime k-tuple conjecture> conjectures that it is all of them.

Also, if 70 million could be reduced down to 2, we would have a proof of the <Twin prime conjecture>, but this method would only work for (k, k + 2).

= Twin prime
{parent=Prime k-tuple}
{wiki}

= Twin prime conjecture
{parent=Twin prime}
{tag=Famous conjecture}
{tag=Prime k-tuple conjecture}
{wiki}

Let's show them how it's done with <primes (bsdgames)> + <awk>. Edit. They have a `-d` option which also shows gaps!!! Too strong:
``
sudo apt install bsdgames
primes -d 1 100 | awk '/\(2\)/{print $1 - 2, $1 }'
``
gives us the list of all twin primes up to 100:
``
0 2
3 5
5 7
11 13
17 19
29 31
41 43
59 61
71 73
``
Tested on <Ubuntu 22.10>.

= Goldbach's conjecture
{c}
{parent=Prime number}
{tag=Additive basis theorem}
{title2=Every even natural number greater than 2 is the sum of two prime numbers}
{wiki}

= Goldbach conjecture
{c}
{synonym}

= Sums of three cubes
{parent=Goldbach's conjecture}
{wiki}

= Prime number theorem
{parent=Prime number}
{wiki}

= Formal proof of the prime number theorem
{parent=Prime number theorem}
{tag=Formal proof}

Bibliography:
* https://mathoverflow.net/questions/488721/formal-proofs-of-the-prime-number-theorem

= prime-number-theorem
{file}
{parent=Prime number theorem}

Consider this is a study in failed <computational number theory>.

The $n/ln(n)$ approximation converges really slowly, and we can't easy go far enough to see that the ration converges to 1 with only <awk> and <primes (bsdgames)>:
``
sudo apt intsall bsdgames
cd prime-number-theorem
./main.py 100000000
``
Runs in 30 minutes tested on <Ubuntu 22.10> and <Ciro Santilli's hardware/P51>, producing:

\Image[https://raw.githubusercontent.com/cirosantilli/media/master/prime-number-theorem/pi.png]
{title=Linear $\pi(n)$ vs $n/ln(n)$ approximation plot}
{description=$f(n) = n$ and $f(n) = log(n)$ are added to give a better sense of scale. $log(n)$ is too close to 0 and not visible, and the approximation almost overlaps entirely with $pi$.}

\Image[https://raw.githubusercontent.com/cirosantilli/media/master/prime-number-theorem/pi-minus.png]
{title=$\pi(n) - n/ln(n)$}
{description=It is clear that the difference diverges, albeit very slowly.}

\Image[https://raw.githubusercontent.com/cirosantilli/media/master/prime-number-theorem/pi-over.png]
{title=$\pi(n)/(n/ln(n))$}
{id=image-pi-n-over-n-ln-n}
{description=We just don't have enough points to clearly see that it is converging to 1.0, the convergence truly is very slow. The <logarithm integral> approximation is much much better, but we can't calculate it in <awk>, sadface.}

But looking at: https://en.wikipedia.org/wiki/File:Prime_number_theorem_ratio_convergence.svg we see that it takes way longer to get closer to 1, even at $10^24$ it is still not super close. Inspecting the code there we see:
``
(* Supplement with larger known PrimePi values that are too large for \
Mathematica to compute *)
LargePiPrime = {{10^13, 346065536839}, {10^14, 3204941750802}, {10^15,
     29844570422669}, {10^16, 279238341033925}, {10^17,
    2623557157654233}, {10^18, 24739954287740860}, {10^19,
    234057667276344607}, {10^20, 2220819602560918840}, {10^21,
    21127269486018731928}, {10^22, 201467286689315906290}, {10^23,
    1925320391606803968923}, {10^24, 18435599767349200867866}};
``
so OK, it is not something doable on a <personal computer> just like that.

= Prime power
{parent=Prime number}
{wiki}

They come up a lot in many contexts, e.g.:
* <classification of finite fields>

= Primality test
{parent=Prime number}
{wiki}

= Elliptic curve primality
{parent=Primality test}
{tag=Elliptic curve}
{wiki}

= Elliptic curve primality testing
{synonym}

<Polynomial time> for most inputs, but not for some very rare ones. TODO can they be determined?

But it is better in practice than the <AKS primality test>, which is always <polynomial time>.

= AKS primality test
{c}
{parent=Primality test}
{tag=Polynomial time}
{title2=2002}
{title2=First polynomial time primality test discovered}
{wiki}

= Greatest common divisor
{parent=Prime number}
{title2=GCD}
{wiki}

The "greatest common divisor" of two <integers> $x$ and $y$, denoted $\gdc(x, y)$ is the largest <natural number> that divides both of the integers.

For example, $\gdc(8, 12)$ is 4, because:
* 4 divides both 8 and 12
* and this is not the case for any number larger than 4. E.g.:
  * 5 divides neither one
  * 6 divides 12
  * 7 divides neither
  * 8 divides only 8
  and so on.

= Greatest common divisor algorithm
{parent=Greatest common divisor}

= Algorithm to find the greatest common divisor
{synonym}

= Euclidean algorithm
{c}
{parent=Greatest common divisor}
{wiki}

= Extended Euclidean algorithm
{c}
{parent=Euclidean algorithm}
{wiki}

= Coprime
{parent=Greatest common divisor}
{wiki}

Two numbers such that the <greatest common divisor> is 1.

= Euler's totient function
{c}
{parent=Coprime}
{title2=$\varphi(n)$}
{title2=varphi}

= Totient function
{synonym}

TODO wtf is a "totient"? Where else is that word used besides in this concept?

= Totient summatory function
{parent=Euler's totient function}
{title2=$\Phi(n)$}
{title2=uppercase phi}
{wiki}

= Least common multiple
{c}
{parent=Prime number}
{title2=lcm}
{wiki}

= Numerical analysis
{parent=Area of mathematics}
{wiki}

Techniques to get numerical approximations to numeric <mathematical> problems.

The entire field comes down to estimating the true values with a known error bound, and creating algorithms that make those error bounds asymptotically smaller.

Not the most beautiful field of pure <mathematics>, but fundamentally useful since we can't solve almost any <computational physics>[useful equation] without computers!

The solution visualizations can also provide valuable intuition however.

Important numerical analysis problems include solving:
* <partial differential equations>

= Floating-point arithmetic
{parent=Numerical analysis}
{wiki}

= Floating-point number
{parent=Floating-point arithmetic}
{wiki}

= IEEE 754
{c}
{parent=Floating-point arithmetic}
{wiki}

Selected answers by <Ciro Santilli> on the subject:
* https://stackoverflow.com/questions/18118408/what-is-difference-between-quiet-nan-and-signaling-nan/55648118#55648118[What is difference between quiet NaN and signaling NaN?]
* https://stackoverflow.com/questions/2618059/in-java-what-does-nan-mean/55673220#55673220[In Java, what does NaN mean?]
* https://stackoverflow.com/questions/8341395/what-is-a-subnormal-floating-point-number/53203428#53203428[What is a subnormal floating point number?]

= Half-precision floating-point format
{parent=IEEE 754}
{wiki}

= 16-bit floating point
{synonym}
{title2}

= Numerical computing language
{parent=Numerical analysis}
{tag=Evil}

All those dedicated <applied mathematicians> languages are a waste of society's time, <Ciro Santilli> sure <applied mathematicians> are capable of writing a few extra braces in exchange for a sane general purpose language, we should instead just invest in good libraries with fast <C (programming language)> bindings for those languages like <NumPy> where needed, and powerful mainlined <integrated development environments>.

And when <Ciro Santilli> see the closed source ones like <MATLAB> being used, it makes him lose all hope on humanity. Why. As of 2020. Why? In the 1980s, maybe. But in the 2020s?

= Scilab
{c}
{parent=Numerical computing language}
{wiki}

= MATLAB
{c}
{parent=Numerical computing language}
{wiki}

= MATLAB methlab pun
{c}
{parent=MATLAB}

\Image[https://web.archive.org/web/20171026130800im_/http://www.allafinedelpalo.it/wp-content/uploads/2016/03/methlab2.png]
{title=MATLAB <Breaking Bad> crossover}
{source=http://www.allafinedelpalo.it/methlab-il-toolbox-di-matlab-ispirato-a-breaking-bad/}

= Perturbation theory
{parent=Numerical analysis}
{wiki}

Used a lot in <quantum mechanics>, where the equations are really hard to solve. There's even a dedicated wiki page for it: https://en.wikipedia.org/wiki/Perturbation_theory_(quantum_mechanics)[]. Notably, <Feynman diagrams> are a way to represent perturbation calculations in <quantum field theory>.

Let's gather some of the best results we come across here:
* <Dirac equation solution for the hydrogen atom>

= Probability
{parent=Area of mathematics}
{wiki}

= Expectation value
{parent=Probability}
{wiki}

= Stochastic process
{parent=Probability}
{wiki}

= Markov chain
{c}
{parent=Stochastic process}
{wiki}

A directed <weighted graph> where the sum of weights of all outgoing edges equals 1.

= Average number of steps until reaching a state of a Markov chain
{parent=Markov chain}
{wiki}

TODO how to calculate

= Average number of steps spent on a node of a Markov chain
{parent=Markov chain}
{wiki}

TODO how to calculate

= Absorbing Markov chain
{parent=Markov chain}
{wiki}

= Probability distribution
{parent=Probability}
{wiki}

= Cumulative distribution function
{parent=Probability}

= Standard deviation
{parent=Probability}
{wiki}

= Statistics
{parent=Probability}
{wiki}

= Bayes' theorem
{c}
{parent=Statistics}
{wiki}

\Video[https://www.youtube.com/watch?v=Zxm4Xxvzohk]
{title=Conditional probability by <#Art of the Problem>}

= Descriptive statistics
{parent=Statistics}
{wiki}

= Arithmetic mean
{parent=Descriptive statistics}
{wiki}

= Mean
{synonym}

= Mode
{disambiguate=statistics}
{parent=Descriptive statistics}
{wiki}

= Variance
{parent=Descriptive statistics}
{wiki}

= Applied mathematics
{parent=Area of mathematics}
{wiki}

= Applied mathematician
{synonym}

= Discrete mathematics
{parent=Area of mathematics}
{wiki}

= Graph
{disambiguate=discrete mathematics}
{parent=Discrete mathematics}
{wiki}

= Graph
{synonym}

= Graph representation
{parent=Graph (discrete mathematics)}

= Adjacency list
{parent=Graph representation}
{wiki}

= Adjacenty list
{synonym}

= Edge
{disambiguate=graph}
{parent=Graph (discrete mathematics)}
{wiki}

= Node
{disambiguate=graph}
{synonym}

= Vertex
{parent=Graph (discrete mathematics)}
{wiki}

= Graph software
{parent=Graph (discrete mathematics)}
{tag=Software}

= Graphviz
{c}
{parent=Graph software}
{wiki}

* https://stackoverflow.com/questions/61550137/using-graphviz-yed-to-produce-a-timeline-graph

= Graphviz example
{parent=Graphviz}

Under: \a[graphviz].

= graphviz/hello.dot
{file}
{parent=Graphviz example}

= graphviz/quotes.dot
{file}
{parent=Graphviz example}

= graphviz/node.dot
{file}
{parent=Graphviz example}

= graphviz/quotes-escape.dot
{file}
{parent=Graphviz example}

= WebGraph
{disambiguate=software}
{parent=Graph software}

A quick hands-on introduction to the software by <Ciro Santilli> can be found at: https://github.com/cirosantilli/cirosantilli.github.io/issues/198

= Graph file format
{parent=Graph (discrete mathematics)}

https://github.com/cirosantilli/cirosantilli.github.io/issues/198

= BVGraph
{parent=Graph file format}

The native file format of <WebGraph (software)>.

It is a binary format and highly storage efficient.

It is for example what <Common Crawl web graph> currently dumps to as of 2025, see e.g.: https://data.commoncrawl.org/projects/hyperlinkgraph/cc-main-2024-25-dec-jan-feb/index.html

TODO meaning of "BV"?

A quick hands-on introduction to the format by <Ciro Santilli> can be found at: https://github.com/cirosantilli/cirosantilli.github.io/issues/198

= Type of graph
{parent=Graph (discrete mathematics)}

= Acyclic graph
{parent=Type of graph}

= Tree
{disambiguate=data structure}
{parent=Type of graph}
{tag=Directed acyclic graph}
{wiki}

= Tree representation
{parent=Tree (data structure)}
{tag=Graph representation}
{wiki}

This section is about ways in which you can represent a <tree (data structure)>.

Trees are a specific type of <graph>, so any <graph representation> also provides a way to represent a tree.

Therefore this section will focus only on methods specific to tress, and which cannot be used for graphs in general.

= Nested set model
{parent=Tree representation}
{wiki}

This is particularly important in <SQL>: <Nested set model in SQL>, as it is an efficient way to transverse trees there, since querying parents every time would require multiple disk accesses.

The <ASCII art> visualizations from https://stackoverflow.com/questions/192220/what-is-the-most-efficient-elegant-way-to-parse-a-flat-table-into-a-tree/194031#194031 are worth reproducing.

As a tree:
* Root 1
  * Child 1.1
    * Child 1.1.1
    * Child 1.1.2
  * Child 1.2
    * Child 1.2.1
    * Child 1.2.2

As the sets:
``
 __________________________________________________________________________
|  Root 1                                                                  |
|   ________________________________    ________________________________   |
|  |  Child 1.1                     |  |  Child 1.2                     |  |
|  |   ___________    ___________   |  |   ___________    ___________   |  |
|  |  |  C 1.1.1  |  |  C 1.1.2  |  |  |  |  C 1.2.1  |  |  C 1.2.2  |  |  |
1  2  3___________4  5___________6  7  8  9___________10 11__________12 13 14
|  |________________________________|  |________________________________|  |
|__________________________________________________________________________|
``

Consider the following nested set:
``
0, 8, root
  1, 7, mathematics
    2, 3, geometry
      3, 6, calculus
        4, 5, derivative
        5, 6, integral
      6, 7, algebra
  7, 8, physics
``

When we want to insert one element, e.g. `limit`, normally under `calculus`, we have to specify:
* parent
* index within parent
so we have a method:
``
insert(parent, previousSibling)
``

= Tree type
{parent=Tree (data structure)}
{wiki}

= Binary tree
{parent=Tree type}
{wiki}

= K-ary tree
{parent=Binary tree}
{wiki}

= Ordered and unordered trees
{parent=Tree type}

= Ordered tree
{parent=Ordered and unordered trees}
{wiki=Tree_(data_structure)\#Ordered_tree}

= Unordered tree
{parent=Ordered and unordered trees}
{wiki=Tree_(data_structure)\#Ordered_tree}

= Tree traversal
{parent=Tree (data structure)}
{wiki}

The summary from https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/ is a winner:
``
    1
   / \
  2   3
 / \
4   5
``
* <inorder DFS>: 4 2 5 1 3
* <preorder DFS>: 1 2 4 5 3
* <postorder DFS>: 4 5 2 3 1
* <breadth-first search>: 1 2 3 4 5

In principle one could talk about tree traversal of <unordered trees> as a number of possible traversals without a fixed order. But we won't consider that under this section, only deterministic <ordered tree> traversals.

= Depth-first search
{parent=Tree traversal}
{wiki}

= Pre-order depth-first search
{parent=Depth-first search}
{title2=NLR}
{wiki}

= Preorder DFS
{synonym}
{title2}

This is the order in which you would want to transverse to read the chapters of a book.

Like <breadth-first search>, this also has the property of visiting parents before any children.

= Iterative pre-order
{parent=Pre-order depth-first search}

This is the easiest one to do iteratively:
* pop and visit
* push right to stack
* push left to stack

= In-order depth-first search
{parent=Depth-first search}
{title2=LNR}
{wiki}

= Inorder DFS
{synonym}
{title2}

This is the order in which a <binary search tree> should be traversed for ordered output, i.e.:
* everything to the left is smaller than parent
* everything to the right is larger than parent

This ordering makes sense for <binary trees> and not <k-ary trees> in general because if there are more than two nodes it is not clear what the top node should go in the middle of.

This is unlike <pre-order depth-first search> and <post-order depth-first search> which generalize obviously to general trees.

= Iterative in-order
{parent=In-order depth-first search}

This is a bit harder than <iterative pre-order>: now we have to check if there is a left or right element or not:
* (START) push current
* if there is left:
  * move left
* else:
  * (ELSE) pop
  * visit
  * if there is right
    * move right
    * GOTO START
  * else:
    * GOTO ELSE

The control flow can be slightly simplified if we allow NULLs: https://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion/

= Post-order depth-first search
{parent=Depth-first search}
{title2=LRN}
{wiki}

= Postorder DFS
{synonym}
{title2}

Has the property of visiting all descendants before the parent.

= Iterative post-order
{parent=Post-order depth-first search}

This is the hardest one to do iteratively.

Bibliography:
* https://stackoverflow.com/questions/1294701/post-order-traversal-of-binary-tree-without-recursion
* https://stackoverflow.com/questions/50645284/non-recursive-post-order-graph-traversal

= Iterative post-order with two stacks
{parent=Iterative post-order}

https://www.geeksforgeeks.org/iterative-postorder-traversal/

= Iterative post-order with one stack
{parent=Iterative post-order}

https://www.geeksforgeeks.org/iterative-postorder-traversal-using-stack/

= Breadth-first search
{parent=Tree traversal}
{wiki}

= Breadth-first
{synonym}

= Directed and undirected graphs
{parent=Type of graph}

= Directed graph
{parent=Directed and undirected graphs}

= Directed acyclic graph
{parent=Directed graph}
{wiki}

= Undirected graph
{parent=Directed and undirected graphs}

= Weighted graph
{parent=Type of graph}

= Game theory
{parent=Area of mathematics}
{wiki}

As mentioned at <Human Compatible by Stuart J. Russell (2019)>, <game theory> can be seen as the part of <artificial intelligence> that deas with scenarios where multiple intelligent agents are involved.

= Balance of power
{c}
{parent=Game theory}
{wiki}

= Game win predictor
{parent=Game theory}
{wiki}

= Elo rating system
{c}
{parent=Game win predictor}
{wiki}

= Nash equilibrium
{c}
{parent=Game theory}
{wiki}

The best example to look at first is the <penalty kick left right Nash equilibrium>.

Then, a much more interesting example is choosing a deck of a TCG competition: <Magic: The Gathering meta-based deck choice is a bimatrix game>, which is the exact same, but each player has N choices rather than 2.

The next case that should be analyzed is the <prisoner's dilemma>.

The key idea is that:
* imagine that the game will be played many times between two players
* if one player always chooses one deck, the other player will adapt by choosing the anti-deck
* therefore, the best strategy for both players, is to pick decks randomly, each with a certain probability. This type of probabilistic approach is called a <mixed strategy>
* if any player deviates from the equilibrium probability, then the other player can add more of the anti-deck to the deck that the other player deviated, and gain an edge

  Therefore, using equilibrium probabilities is the optimal way to play

= Penalty kick left right Nash equilibrium
{parent=Nash equilibrium}

When taking a penalty kick in <soccer>, the kicker must chose left or right.

And before he kicks, the goalkeeper must also decide left or right, because there is no time to see where the ball is going.

Because the kicker is right footed however, he kicker kicks better to one side than the other. So we have four probabilities:
* goal kick left keeper jumps left
* goal kick right keeper jumps right
* goal kick left keeper jumps right. Note that it is possible that this won't be a goal, even though the keeper is nowhere near the ball, as the ball might just miss the goal by a bit.
* kick right and keeper jumps left. Analogous to above

= Mixed strategy
{parent=Nash equilibrium}
{wiki}

= Prisoner's dilemma
{parent=Nash equilibrium}
{wiki}

https://en.wikipedia.org/wiki/Prisoner%27s_dilemma

= Bimatrix game
{parent=Nash equilibrium}

<Magic: The Gathering meta-based deck choice is a bimatrix game>.

= Tit for tat
{parent=Game theory}
{wiki}

Related ideas:
* <fight fire with fire>

= Recreational mathematics
{parent=Area of mathematics}
{wiki}

= Mathematician
{parent=Mathematics}
{wiki}

Poet, scientists and warriors all in one? https://en.wikipedia.org/wiki/180_Degrees_South:_Conquerors_of_the_Useless[Conquerors of the useless].

A wise teacher from <University of São Paulo> once told the class <Ciro Santilli> attended an anecdote about his life:
> I used to want to learn Mathematics.

  But it was very hard.

  So in the end, I became an engineer, and found an engineering solution to the problem, and married a Mathematician instead.
It turned out that, about 10 years later, Ciro <Ciro Santilli's wife>[ended up following this advice], unwittingly.

\Image[https://web.archive.org/web/20190925220347if_/https://imgs.xkcd.com/comics/purity.png]
{title=<xkcd> 435: Fields arranged by purity}
{disambiguate=mathematician}
{source=https://xkcd.com/435/}

= High flying bird vs gophers
{parent=Mathematician}
{tag=Essays by Ciro Santilli}

= Birds and frogs by Freeman Dyson (2009)
{c}
{synonym}
{title2}

Ciro once read that there are two types of mathematicians/scientists (he thinks it was comparing Einstein to some Jack of all trades polymath who didn't do any new discoveries):
* high flying birds, who know a bit of everything, feel the beauty of each field, but never dig deep in any of them
* gophers, who dig all the way down, on a single subject, until they either get the <Nobel Prize>, or work on the wrong problem and waste their lives

TODO long after Ciro forgot where he had read this from originally, someone later pointed him to: https://www.ams.org/notices/200902/rtx090200212p.pdf Birds and Frogs by <Freeman Dyson> (2009), which is analogous but about Birds and Frogs. So did <Ciro Santilli's bad old event memory>[Ciro's memory play a trick on him], or is there also a variant; of this metaphor with a gopher?

<Ciro Santilli's psychology and physiology>[Ciro is without a doubt the bird type]. Perhaps the ultimate scientist is the one who can combine both aspects in the right amount?

Ciro gets bored of things very quickly.

Once he understands the general principles, if the thing is not <the next big thing>, Ciro considers himself satisfied without all the nitty gritty detail, and moves on to the next attempt.

In the field of <mathematics> for example, Ciro is generally content with understanding cool theorem statements. More generally, one of Ciro's desires is for example to understand the significance of each <physics> <Nobel Prize>.

This is also very clear for example after Ciro achieved <Linux Kernel Module Cheat>: he now had the perfect setup to learn all the Linux kernel shady details but at the same time after all those years he finally felt that "he could do it, so that was enough", and soon moved to other projects.

If Ciro had become a scientist, he would write <the side effects of ambitious goals are often the most valuable thing achieved>[the best review papers ever], just like in the current reality he <Ciro Santilli's Stack Overflow contributions>[writes amazing programming tutorials on Stack Overflow].

Ciro has in his mind an overly large list of subjects that "he feels he should know the basics of", and whenever he finds something in one of those topics that he does not know enough about, he uncontrollably learns it, even if it is not the most urgent thing to be done. Or at least he puts a mention on his "list of sources" about the subject. Maybe everyone is like that. But Ciro feels that he feels this urge particularly strongly. Correspondingly, if a subject is not in that list, Ciro ignores it without thinking twice.

Ciro believes that high flying birds are the type of people better suited for <venture capital> investment management: you know a bit of what is hot on several fields to enough depth to decide where to place your bets and how to guide them. But you don't have the patience to actually go deeply into any one of them and deal with each individual <shit> that comes up.

<Cosmos: A Personal Voyage (1980)> episode 1 mentions as quoted by the https://en.wikipedia.org/w/index.php?title=Eratosthenes&oldid=1018676910[Wikipedia page] for <Eratosthenes>:
> According to an entry in the Suda (a 10th-century encyclopedia), his critics scorned him, calling him <beta> (the second letter of the <Greek alphabet>) because he always came in second in all his endeavours.
That's Ciro.

Some related ideas:
* <the Fox and the Cat (fable)>
* <The Hedgehog and the Fox by Isaiah Berlin (1953)>
* <jack of all trades, master of none>

= Mathematics Genealogy Project
{c}
{parent=Mathematician}
{wiki}

= Group of mathematicians
{parent=Mathematician}

= Nicolas Bourbaki
{c}
{parent=Group of mathematicians}
{wiki}

= Bourbaki group
{synonym}
{title2}

= Polymath project
{c}
{parent=Group of mathematicians}
{wiki}

= D.H.J Polymath
{c}
{synonym}
{title2}

Bibliography:
* https://www.galoisrepresentations.com/2013/10/20/who-is-d-h-j-polymath/

= List of mathematicians
{parent=Mathematician}

= Alexander Grothendieck
{c}
{parent=List of mathematicians}
{tag=God}
{wiki}

This dude looks like a <God>. <Ciro Santilli> does not understand his stuff, but just based on the names of his theories, e.g. "Yoga of anabelian algebraic geometry", and on his eccentric lifestyle, it is obvious that he was in fact a God.

= Blaise Pascal
{c}
{parent=List of mathematicians}
{title2=1623-1662}
{wiki}

Good film about him: <Blaise Pascal (1972)>.

Good quote from his https://en.wikipedia.org/wiki/Lettres_provinciales[Les Provinciales] (1656-57) Letter XII, p. 227:
> The war in which violence endeavors to crush truth is a strange and a long one.

  All the efforts of violence cannot weaken truth, but only serve to exalt it the more.

  The light of truth can do nothing to arrest violence; nay, it serves to provoke it still more.

  When force opposes force, the more powerful destroys the less; when words are opposed to words, those which are true and convincing destroy and scatter those which are vain and false; but violence and truth can do nothing against each other.

  Yet, let no one imagine that things are equal between them; for there is this final difference, that the course of violence is limited by the ordinance of God, who directs its workings to the glory of the truth, which it attacks; whereas truth subsists eternally, and triumphs finally over its enemies, because it is eternal, and powerful, like God Himself.
French version reproduced at: https://www.dicocitations.com/citation/auteurajout35106.php[].

= Euclid
{c}
{parent=List of mathematicians}
{wiki}

= Euclid's Elements
{c}
{parent=Euclid}
{wiki}

= Synthetic geometry
{parent=Euclid's Elements}
{wiki}

A way to defined geometry without talking about coordinates, i.e. like <Euclid's Elements>, notably <Euclid's postulates>, as opposed to <Descartes>'s <Real coordinate space>.

= Euclid's postulates
{c}
{parent=Euclid's Elements}

Postulates are what we now call <axioms>.

There are 5: https://en.wikipedia.org/w/index.php?title=Euclidean_geometry&oldid=1036511366#Axioms[], the <parallel postulate> being the most controversial/interesting.

= Parallel postulate
{parent=Euclid's postulates}
{wiki}

= Évariste Galois
{c}
{parent=List of mathematicians}
{wiki}

= Galois
{c}
{synonym}

= G. H. Hardy
{c}
{parent=List of mathematicians}
{wiki}

= A Mathematician's Apology
{c}
{parent=G. H. Hardy}
{title2=1940}
{wiki}

With major mathematicians holding ideas such as:
> Exposition, criticism, appreciation, is work for second-rate minds. \[...\] It is a melancholy experience for a professional mathematician to find himself writing about mathematics. The function of a mathematician is to do something, to prove new theorems, to add to mathematics, and not to talk about what he or other mathematicians have done.
it is not surprise that the state of <STEM> education is so shit as of 2020, especially at the <the missing link between basic and advanced>! This also implies that the number of people that can appreciate any advanced mathematics research is tiny, and consequently so is the funding.

= Henri Poincaré
{c}
{parent=List of mathematicians}
{tag=École Polytechnique alumnus}
{tag=Physicist}
{wiki}

= Poincaré
{synonym}

= Hugo Duminil-Copin
{c}
{parent=Henri Poincaré}
{tag=2022 Fields Medal winner}
{wiki}

Works on <percolation theory>.

= Jim Simons
{c}
{parent=List of mathematicians}
{wiki}

= James Harris Simons
{c}
{synonym}

<Ciro Santilli's wife>, who was frustrated with <academia> at some point, admires the fact that Simons managed to make infinite money, and then invested back in actual science, e.g. through the <Simons Foundation>.

\Image[https://web.archive.org/web/20240522140900im_/https://static01.nyt.com/images/2024/05/11/multimedia/10Simons--clqg-print2/10Simons--clqg-superJumbo.jpg?quality=75&auto=webp]
{title=<Jim Simons> in 2007}

= Joseph Fourier
{c}
{parent=List of mathematicians}
{wiki}

= Fourier
{c}
{synonym}

= Paul Erdos
{c}
{parent=List of mathematicians}
{wiki}

= Erdos number
{c}
{parent=Paul Erdos}
{wiki}

= René Descartes
{c}
{parent=List of mathematicians}
{wiki}

= Descartes
{c}
{synonym}

= Srinivasa Ramanujan
{c}
{parent=List of mathematicians}
{wiki}

= Ramanujan
{c}
{synonym}

The cool think about <Ramanujan> is how British mathematicians heard about him and then just went crazy that someone they had never heard of before had come up with so many <novel results>. It is as if <God> had come down from the clouds and handed them those results. Without proof. But in that field of research, the statements are not easy to come up with, so much so that <G. H. Hardy> commented that:
> they must be true, because, if they were not true, no one would have the imagination to invent them

\Image[https://upload.wikimedia.org/wikipedia/commons/d/d0/Srinivasa_Ramanujan-Add._MS_a94_version2_%28cropped%29.jpg]

= The man who loved numbers
{disambiguate=Nova episode}
{parent=Srinivasa Ramanujan}
{tag=Nova episode}
{title2=1988}

\Video[https://www.youtube.com/watch?v=PqP2c5xNaTU]
{title=The man who loved numbers by WGBH}
{description=Season 15 Episode 19 from their series <Nova (American TV program)> (1988)}

= Terence Tao
{c}
{parent=List of mathematicians}
{wiki}

The cool thing about Terrence Tao is that besides being a mathematical genius, he is also interested in modern technology such as <formal proof systems> and <automated theorem proving>. For that, kudos.

\Image[https://upload.wikimedia.org/wikipedia/commons/d/db/Terence_Tao%2C_PCAST_Member_%28cropped%29.jpg]
{title=Terence Tao}
{height=600}

= Mathematical notation
{parent=Mathematics}
{wiki}

It is hard to decide what makes <Ciro Santilli> more sad: the usage of <Greek letters>, the invention of new symbols, or the fifty million alternative font styles used.

Only <Chinese characters> could be worse than that!

= Mathematical symbol that looks like a Greek letter but isn't
{parent=Mathematical notation}

These are not in the <Greek alphabet>:
* <nabla>
* <partial derivative symbol>

= Mathematics bibliography
{parent=Mathematics}

= Open mathematics book
{parent=Mathematics bibliography}

= Infinite Napkin
{c}
{parent=Open mathematics book}

https://github.com/vEnhance/napkin

By <Evan Chen>.

800+ page PDF with source on <GitHub> claiming to try and teach the beauty of modern maths for high schoolers. Fantastic project!!!

= Evan Chen
{c}
{parent=Infinite Napkin}

= Evan Yiting Chen
{synonym}
{title2}

= vEnhance
{c}
{title2}
{synonym}

= 陳誼廷
{synonym}
{title2}

Author of <Infinite Napkin>.

Profiles:
* https://evanchen.cc
* https://www.youtube.com/@vEnhance
* https://www.instagram.com/evanchen.cc

He's also a <mathematical olympiad> coach.

\Video[https://www.youtube.com/watch?v=C9WhZldyMuc]
{title=Walkthrough of some recent Oly problems by vEnhance}
{description=He's <trans>. Cute.}

= Opera Magistris
{c}
{parent=Open mathematics book}

http://www.sciences.ch/

v3 <LaTeX> source code: https://github.com/OperaMagistris/Opera_Magistris_English_v3

Very unfortunate license "<public domain> license" with a "non religious" clause, whatever the fuck that is, which completely defeats the point of a public domain declaration: 
> The source code and text is under Public License and therefore can be used, translated and distributed at free will.

  It is only banned to use the text and content for religious propaganda.

= Stacks Project
{c}
{parent=Open mathematics book}
{wiki}

* Renders: https://stacks.math.columbia.edu/[]. HTML is one tiny section per page, making it unreadable.
* <LaTeX> source: https://github.com/stacks/stacks-project

The book is very dry, extremelly boring unfortunately. Definition and theorem only for the most part.

= Mathematics website
{parent=Mathematics bibliography}

= Visual math HTML book
{parent=Mathematics website}

When you see some tagged examples, you will immediately know what this means.

= Theorem of the Day
{parent=Mathematics website}

<Website>: https://www.theoremoftheday.org/

= Mathematics YouTube channel
{parent=Mathematics bibliography}

= 3Blue1Brown
{c}
{parent=Mathematics YouTube channel}
{wiki}

https://www.youtube.com/channel/UCYO_jab_esuFRV4b17AJtAw

Amazing graphs and formulas.

Python graphics engine open sourced at: https://github.com/3b1b/manim "Animation engine for explanatory math videos". But for some reason there is a community fork: https://github.com/ManimCommunity/manim/ "This repository is maintained by the Manim Community, and is not associated with Grant Sanderson or 3Blue1Brown in any way (though we are definitely indebted to him for providing his work to the world). If you want to study how Grant makes his videos, head over to his repository (3b1b/manim). This is a more frequently updated repository than that one, and is recommended if you want to use Manim for your own projects." what a mess.

= MathDoctorBob
{c}
{parent=Mathematics YouTube channel}
{title2=Robert Donley}

https://www.youtube.com/user/MathDoctorBob/videos

He got so old from 2012 to 2021 :-)

This dude did well. If only he had <OurBigBook.com>[written a hyperlinked wiki rather than making videos]! It would allow people to jump in at any point and just click back. It would be Godlike.

https://mathdoctorbob.org/About.html says:
> Robert Donley received his doctorate in Mathematics from Stony Brook University and has over two decades of teaching experience at the high school, undergraduate, and graduate levels.

= Numberphile
{c}
{parent=Mathematics YouTube channel}
{tag=Brady Haran production}
{wiki}

https://www.youtube.com/@numberphile

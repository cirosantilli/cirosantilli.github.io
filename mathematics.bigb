= Mathematics
{wiki}

= Mathematical
{synonym}

= Mathematically
{synonym}

= Math
{synonym}

= Maths
{synonym}

= Mathy
{synonym}

The proper precise definition of mathematics can be found at: <formalization of mathematics>{full}.

The most beautiful things in mathematics are described at: <the beauty of mathematics>{full}.

\Image[https://web.archive.org/web/20220604093553im_/https://bird.trom.tf/pic/media%2FFToTqgKUEAAxdN9.jpg%3Fname%3Dsmall]
{title=Study <Hilbert spaces> https://knowyourmeme.com/memes/desert-dilemma[desert dilemma] meme}
{description=Applies to almost all of <mathematics> of course. But we don't care, do we!}
{source=https://bird.trom.tf/Lavoisierbug/status/1529556647290449921#m}

= The beauty of mathematics
{parent=Mathematics}

<Ciro Santilli> intends to move his beauty list here little by little: https://github.com/cirosantilli/mathematics/blob/master/beauty.md

The most beautiful things in mathematics are results that are:
* <simple to state but hard to prove>:
  * Fermat's Last Theorem
  * <transcendental number conjectures>, e.g. is $e + \pi$ transcendental?
  * basically any conjecture involving <prime numbers>:
    * <twin prime conjecture>
  * many combinatorial game questions, e.g.:
    * <first-move advantage in chess>
* surprising results: we had intuitive reasons to believe something as possible or not, but a theorem shatters that conviction and brings us on our knees, sometimes via <pathological (mathematics)> counter-examples. General surprise themes include:
  * <classification (mathematics)> of potentially <infinite> sets like: compact <manifolds>, etc.
    * <classification of finite simple groups>
    * <classification of regular polytopes>
    * <classification of closed surfaces>, and more <generalized Poincaré conjectures>
    * classification of <wallpaper groups> and <space groups>
  * problems that are more complicated in low dimensions than high like:
    * <generalized Poincaré conjectures>. It is also fun to see how in many cases complexity peaks out at 4 dimensions.
    * <classification of regular polytopes>
  * unpredictable magic constants:
    * why is the lowest dimension for an <exotic sphere> 7?
    * why is 4 the largest degree of an equation with explicit solution? <Abel-Ruffini theorem>
  Lists:
  * https://math.stackexchange.com/questions/139699/what-are-some-examples-of-a-mathematical-result-being-counterintuitive
  * https://math.stackexchange.com/questions/2040811/what-are-some-counter-intuitive-results-in-mathematics-that-involve-only-finite/2055458#2055458
* applications: make life easier and/or modeling some phenomena well, e.g. in <physics>. See also: <how to teach/explain how to make money with the lesson>

Good lists of such problems <Lists of mathematical problems>.

Specific examples:
* from <computer science>:
  * the existence of <undecidable problems>, especially simple to state ones, e.g. <mortal matrix problem>

Whenever <Ciro Santilli> learns a bit of <mathematics>, he always wonders to himself:
\Q[Am I achieving insight, or am I just memorizing definitions?]
Unfortunately, due to how man books are written, it is not really possible to reach insight without first doing a bit of memorization. The better the book, the more insight is spread out, and less you have to learn before reaching each insight.

= Simple to state but hard to prove
{parent=The beauty of mathematics}

One of the most beautiful things in mathematics are theorems of conjectures that are very simple to state and understand (e.g. for <K-12>, lower <undergrad> levels), but extremely hard to prove.

This is in contrast to conjectures in certain areas where you'd have to study for a few months just to precisely understand all the definitions and the interest of the problem statement.

= The Hundred Greatest Theorems by Paul and Jack Abad (1999)
{parent=The beauty of mathematics}

Randomly reproduced at: http://web.archive.org/web/20080105074243/http://personal.stevens.edu/~nkahl/Top100Theorems.html

= Classification
{disambiguate=mathematics}
{parent=The beauty of mathematics}
{wiki}

= Classifying
{disambiguate=mathematics}
{synonym}

In <mathematics>, a "classification" means making a list of all possible objects of a given type.

Classification results are some of <Ciro Santilli>'s favorite: <the beauty of mathematics>{full}.

Examples:
* <classification of finite simple groups>{child}
* <classification of regular polytopes>{child}
* <classification of closed surfaces>{child}, and more generalized <generalized Poincaré conjectures>{child}
* <classification of associative real division algebras>{child}
* <classification of finite fields>{child}
* <classification of simple Lie groups>{child}
* classification of the <wallpaper groups> and the <space groups>

= Pathological
{disambiguate=mathematics}
{parent=The beauty of mathematics}
{wiki}

= Exceptional object
{parent=Pathological (mathematics)}
{wiki}

Oh, and the dude who created the https://en.wikipedia.org/wiki/Exceptional_object <Wikipedia> page won an Oscar: https://www.youtube.com/watch?v=oF_FLN-TmCY[], Dan Piponi, aka `@sigfpe`. Cool dude.

List:
* <sporadic group>{child}

= Exceptional isomorphism
{parent=Exceptional object}
{wiki}

= Lists of mathematical problems
{c}
{parent=The beauty of mathematics}
{wiki}

Good place to hunt for <the beauty of mathematics>.

= Hilbert's problems
{c}
{parent=Lists of mathematical problems}
{wiki}

He's a bit overly obsessed with <polynomials> for the taste of modern maths, but it's still fun.

= Millennium Prize Problems
{c}
{parent=Lists of mathematical problems}
{wiki}

<Ciro Santilli> would like to fully understand the statements and motivations of each the problems!

Easy to understand the motivation:
* <Navier-Stokes existence and smoothness> is basically the only problem that is really easy to understand the statement and motivation :-)
* <p versus NP problem>

Hard to understand the motivation!
* <Riemann hypothesis>: a bunch of results on prime numbers, and therefore possible applications to <cryptography>

  Of course, everything of interest has already been proved conditionally on it, and the likely "true" result will in itself not have any immediate applications.

  As is often the case, the only usefulness would be possible new ideas from the proof technique, and people being more willing to prove stuff based on it without the risk of the hypothesis being false.
* <Yang-Mills existence and mass gap>: this one has to do with findind/proving the existence of a more decent formalization of <quantum field theory> that does not resort to tricks like <perturbation theory> and <effective field theory> with a random cutoff value

  This is important because the best theory of light and electrons (and therefore chemistry and material science) that we have today, <quantum electrodynamics>, is a <quantum field theory>.

= Functional equation
{parent=Mathematics}
{wiki}

= Cauchy's functional equation
{parent=Functional equation}
{wiki}

Nice result on <Lebesgue measurable> required for unicity.

= Area of mathematics
{parent=Mathematics}

\Include[formalization-of-mathematics]{parent=Area of mathematics}
\Include[algebra]{parent=Area of mathematics}
\Include[calculus]{parent=Area of mathematics}
\Include[geometry]{parent=Area of mathematics}

= Applied mathematics
{parent=Area of mathematics}
{wiki}

= Applied mathematician
{synonym}

= Discrete mathematics
{parent=Area of mathematics}
{wiki}

= Graph
{disambiguate=discrete mathematics}
{parent=Discrete mathematics}
{wiki}

= Graph
{synonym}

= Graph representation
{parent=Graph (discrete mathematics)}

= Adjacenty list
{parent=Graph representation}
{wiki}

= Edge
{disambiguate=graph}
{parent=Graph (discrete mathematics)}
{wiki}

= Node
{disambiguate=graph}
{synonym}

= Vertex
{parent=Graph (discrete mathematics)}
{wiki}

= Graph software
{parent=Graph (discrete mathematics)}
{tag=Software}

= Graphviz
{c}
{parent=Graph software}
{wiki}

* https://stackoverflow.com/questions/61550137/using-graphviz-yed-to-produce-a-timeline-graph

= Type of graph
{parent=Graph (discrete mathematics)}

= Acyclic graph
{parent=Type of graph}

= Tree
{disambiguate=data structure}
{parent=Type of graph}
{tag=Directed acyclic graph}
{wiki}

= Tree representation
{parent=Tree (data-structure)}
{wiki}

= Adjacency list
{parent=Tree representation}
{wiki}

= Nested set model
{parent=Tree representation}
{wiki}

This is particularly important in <SQL>: <Nested set model in SQL>, as it is an efficient way to transverse trees there, since querrying parents every time would require multiple disk accesses.

The <ASCII ART> visualizations from https://stackoverflow.com/questions/192220/what-is-the-most-efficient-elegant-way-to-parse-a-flat-table-into-a-tree/194031#194031 are worth reproducing.

As a tree:
* Root 1
  * Child 1.1
    * Child 1.1.1
    * Child 1.1.2
  * Child 1.2
    * Child 1.2.1
    * Child 1.2.2

As the sets:
``
 __________________________________________________________________________
|  Root 1                                                                  |
|   ________________________________    ________________________________   |
|  |  Child 1.1                     |  |  Child 1.2                     |  |
|  |   ___________    ___________   |  |   ___________    ___________   |  |
|  |  |  C 1.1.1  |  |  C 1.1.2  |  |  |  |  C 1.2.1  |  |  C 1.2.2  |  |  |
1  2  3___________4  5___________6  7  8  9___________10 11__________12 13 14
|  |________________________________|  |________________________________|  |
|__________________________________________________________________________|
``

Consider the following nested set:
``
0, 8, root
  1, 7, mathematics
    2, 3, geometry
      3, 6, calculus
        4, 5, derivative
        5, 6, integral
      6, 7, algebra
  7, 8, physics
``

When we want to insert one element, e.g. `limit`, normally under `calculus`, we have to specify:
* parent
* index within parent
so we have a method:
``
insert(parent, previousSibling)
``

= Tree type
{parent=Tree (data-structure)}
{wiki}

= Binary tree
{parent=Tree type}
{wiki}

= K-ary tree
{parent=Binary tree}
{wiki}

= Ordered and unordered trees
{parent=Tree type}

= Ordered tree
{parent=Ordered and unordered trees}
{wiki=Tree_(data_structure)#Ordered_tree}

= Unordered tree
{parent=Ordered and unordered trees}
{wiki=Tree_(data_structure)#Ordered_tree}

= Tree traversal
{parent=Tree (data-structure)}
{wiki}

The summary from https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/ is a winner:
``
    1
   / \
  2   3
 / \
4   5
``
* <inorder DFS>: 4 2 5 1 3
* <preorder DFS>: 1 2 4 5 3
* <postorder DFS>: 4 5 2 3 1
* <breadth-first search>: 1 2 3 4 5

In principle one could talk about tree traversal of <unordered trees> as a number of possible traversals without a fixed order. But we won't consider that under this section, only deterministic <ordered tree> traversals.

= Depth-first search
{parent=Tree traversal}
{wiki}

= Pre-order depth-first search
{parent=Depth-first search}
{title2=NLR}
{wiki}

= Preorder DFS
{synonym}
{title2}

This is the order in which you would want to transverse

Like <breadth-first search>, this also has the property of visiting parents before any children.

= Iterative pre-order
{parent=Pre-order depth-first search}

This is the easiest one to do iteratively:
* pop and visit
* push right to stack
* push left to stack

= In-order depth-first search
{parent=Depth-first search}
{title2=LNR}
{wiki}

= Inorder DFS
{synonym}
{title2}

This is the order in which a <binary search tree> should be traversed for ordered output, i.e.:
* everything to the left is smaller than parent
* everything to the right is larger than parent

This ordering makes sense for <binary trees> and not <k-ary trees> in general because if there are more than two nodes it is not clear what the top node should go in the middle of.

This is unlike <pre-order depth-first search> and <post-order depth-first search> which generalize obviously to general trees.

= Iterative in-order
{parent=In-order depth-first search}

This is a bit harder than <iterative pre-order>: now we have to check if there is a left or right element or not:
* (START) push current
* if there is left:
  * move left
* else:
  * (ELSE) pop
  * visit
  * if there is right
    * move right
    * GOTO START
  * else:
    * GOTO ELSE

The control flow can be slightly simplified if we allow NULLs: https://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion/

= Post-order depth-first search
{parent=Depth-first search}
{title2=LRN}
{wiki}

= Postorder DFS
{synonym}
{title2}

Has the property of visiting all descendants before the parent.

= Iterative post-order
{parent=Post-order depth-first search}

This is the hardest one to do iteratively.

Bibliography:
* https://stackoverflow.com/questions/1294701/post-order-traversal-of-binary-tree-without-recursion
* https://stackoverflow.com/questions/50645284/non-recursive-post-order-graph-traversal

= Iterative post-order with two stacks
{parent=Iterative post-order}

https://www.geeksforgeeks.org/iterative-postorder-traversal/

= Iterative post-order with one stack
{parent=Iterative post-order}

https://www.geeksforgeeks.org/iterative-postorder-traversal-using-stack/

= Breadth-first search
{parent=Tree traversal}
{wiki}

= Directed and undirected graphs
{parent=Type of graph}

= Directed graph
{parent=Directed and undirected graphs}

= Directed acyclic graph
{parent=Directed graph}
{wiki}

= Undirected graph
{parent=Directed and undirected graphs}

= Weighted graph
{parent=Type of graph}

= Game theory
{parent=Area of mathematics}
{wiki}

As mentioned at <Human compatible by Stuart J. Russell (2019)>, <game theory> can be seen as the part of <artificial intelligence> that deas with scenarios where multiple intelligent agents are involved.

= Balance of power
{c}
{parent=Game theory}
{wiki}

= Game win predictor
{parent=Game theory}
{wiki}

= Elo rating system
{c}
{parent=Game win predictor}
{wiki}

= Nash equilibrium
{c}
{parent=Game theory}
{wiki}

The best example to look at first is the <penalty kick left right Nash equilibrium>.

Then, a much more interesting example is choosing a deck of a TCG competition: <Magic: The Gathering meta-based deck choice is a bimatrix game>, which is the exact same, but each player has N choices rather than 2.

The next case that should be analyzed is the <prisoner's dilemma>.

The key idea is that:
* imagine that the game will be played many times between two players
* if one player always chooses one deck, the other player will adapt by choosing the anti-deck
* therefore, the best strategy for both players, is to pick decks randomly, each with a certain probability. This type of probabilistic approach is called a <mixed strategy>
* if any player deviates from the equilibrium probability, then the other player can add more of the anti-deck to the deck that the other player deviated, and gain an edge

  Therefore, using equilibrium probabilities is the optimal way to play

= Penalty kick left right Nash equilibrium
{parent=Nash equilibrium}

When taking a penalty kick in <soccer>, the kicker must chose left or right.

And before he kicks, the goalkeeper must also decide left or right, because there is no time to see where the ball is going.

Because the kicker is right footed however, he kicker kicks better to one side than the other. So we have four probabilities:
* goal kick left keeper jumps left
* goal kick right keeper jumps right
* goal kick left keeper jumps right. Note that it is possible that this won't be a goal, even though the keeper is nowhere near the ball, as the ball might just miss the goal by a bit.
* kick right and keeper jumps left. Analogous to above

= Mixed strategy
{parent=Nash equilibrium}
{wiki}

= Prisoner's dilemma
{parent=Nash equilibrium}
{wiki}

https://en.wikipedia.org/wiki/Prisoner%27s_dilemma

= Bimatrix game
{parent=Nash equilibrium}

<Magic: The Gathering meta-based deck choice is a bimatrix game>.

= Tit for tat
{parent=Game theory}
{wiki}

Related ideas:
* <fight fire with fire>

= Recreational mathematics
{parent=Area of mathematics}
{wiki}

= Mathematician
{parent=Mathematics}
{wiki}

Poet, scientists and warriors all in one? https://en.wikipedia.org/wiki/180_Degrees_South:_Conquerors_of_the_Useless[Conquerors of the useless].

A wise teacher from <University of São Paulo> once told the class <Ciro Santilli> attended an anecdote about his life:
\Q[
I used to want to learn Mathematics.

But it was very hard.

So in the end, I became an engineer, and found an engineering solution to the problem, and married a Mathematician instead.
]
It turned out that, about 10 years later, Ciro <Ciro Santilli's wife>[ended up following this advice], unwittingly.

\Image[https://web.archive.org/web/20190925220347if_/https://imgs.xkcd.com/comics/purity.png]
{disambiguate=mathematician}
{title=<xkcd> 435: Fields arranged by purity}
{source=https://xkcd.com/435/}

= High flying bird vs gophers
{parent=Mathematician}
{tag=Essays by Ciro Santilli}

= Birds and frogs by Freeman Dyson (2009)
{c}
{synonym}
{title2}

Ciro once read that there are two types of mathematicians/scientists (he thinks it was comparing Einstein to some Jack of all trades polymath who didn't do any new discoveries):
* high flying birds, who know a bit of everything, feel the beauty of each field, but never dig deep in any of them
* gophers, who dig all the way down, on a single subject, until they either get the <Nobel Prize>, or work on the wrong problem and waste their lives

TODO long after Ciro forgot where he had read this from originally, someone later pointed him to: https://www.ams.org/notices/200902/rtx090200212p.pdf Birds and Frogs by <Freeman Dyson> (2009), which is analogous but about Birds and Frogs. So did <Ciro Santilli's bad old event memory>[Ciro's memory play a trick on him], or is there also a variant; of this metaphor with a gopher?

<Ciro Santilli's psychology and physiology>[Ciro is without a doubt the bird type]. Perhaps the ultimate scientist is the one who can combine both aspects in the right amount?

Ciro gets bored of things very quickly.

Once he understands the general principles, if the thing is not <the next big thing>, Ciro considers himself satisfied without all the nitty gritty detail, and moves on to the next attempt.

In the field of <mathematics> for example, Ciro is generally content with understanding cool theorem statements. More generally, one of Ciro's desires is for example to understand the significance of each <physics> <Nobel Prize>.

This is also very clear for example after Ciro achieved <Linux Kernel Module Cheat>: he now had the perfect setup to learn all the Linux kernel shady details but at the same time after all those years he finally felt that "he could do it, so that was enough", and soon moved to other projects.

If Ciro had become a scientist, he would write <the side effects of ambitious goals are often the most valuable thing achieved>[the best review papers ever], just like in the current reality he <Ciro Santilli's Stack Overflow contributions>[writes amazing programming tutorials on Stack Overflow].

Ciro has in his mind an overly large list of subjects that "he feels he should know the basics of", and whenever he finds something in one of those topics that he does not know enough about, he uncontrollably learns it, even if it is not the most urgent thing to be done. Or at least he puts a mention on his "list of sources" about the subject. Maybe everyone is like that. But Ciro feels that he feels this urge particularly strongly. Correspondingly, if a subject is not in that list, Ciro ignores it without thinking twice.

Ciro believes that high flying birds are the type of people better suited for <venture capital> investment management: you know a bit of what is hot on several fields to enough depth to decide where to place your bets and how to guide them. But you don't have the patience to actually go deeply into any one of them and deal with each individual <shit> that comes up.

<Cosmos: A Personal Voyage (1980)> episode 1 mentions as quoted by the https://en.wikipedia.org/w/index.php?title=Eratosthenes&oldid=1018676910[Wikipedia page] for <Eratosthenes>:
\Q[According to an entry in the Suda (a 10th-century encyclopedia), his critics scorned him, calling him <beta> (the second letter of the <Greek alphabet>) because he always came in second in all his endeavours.]
That's Ciro.

Some related ideas:
* <the Fox and the Cat (fable)>
* <The Hedgehog and the Fox by Isaiah Berlin (1953)>
* <jack of all trades, master of none>

= Mathematics Genealogy Project
{c}
{parent=Mathematician}
{wiki}

= Group of mathematicians
{parent=Mathematician}

= Nicolas Bourbaki
{c}
{parent=Group of mathematicians}
{wiki}

= Bourbaki group
{synonym}
{title2}

= Polymath project
{c}
{parent=Group of mathematicians}
{wiki}

= D.H.J Polymath
{c}
{synonym}
{title2}

Bibliography:
* https://www.galoisrepresentations.com/2013/10/20/who-is-d-h-j-polymath/

= List of mathematicians
{parent=Mathematician}

= Alexander Grothendieck
{c}
{parent=List of mathematicians}
{tag=God}
{wiki}

This dude looks like a <God>. <Ciro Santilli> does not understand his stuff, but just based on the names of his theories, e.g. "Yoga of anabelian algebraic geometry", and on his eccentric lifestyle, it is obvious that he was in fact a God.

= Blaise Pascal
{c}
{parent=List of mathematicians}
{title2=1623-1662}
{wiki}

Good film about him: <Blaise Pascal (1972)>.

Good quote from his https://en.wikipedia.org/wiki/Lettres_provinciales[Les Provinciales] (1656-57) Letter XII, p. 227:
\Q[
The war in which violence endeavours to crush truth is a strange and a long one.

All the efforts of violence cannot weaken truth, but only serve to exalt it the more.

The light of truth can do nothing to arrest violence; nay, it serves to provoke it still more.

When force opposes force, the more powerful destroys the less; when words are opposed to words, those which are true and convincing destroy and scatter those which are vain and false; but violence and truth can do nothing against each other.

Yet, let no one imagine that things are equal between them; for there is this final difference, that the course of violence is limited by the ordinance of God, who directs its workings to the glory of the truth, which it attacks; whereas truth subsists eternally, and triumphs finally over its enemies, because it is eternal, and powerful, like God Himself.
]
French version reproduced at: https://www.dicocitations.com/citation/auteurajout35106.php[].

= Euclid
{c}
{parent=List of mathematicians}
{wiki}

= Euclid's Elements
{c}
{parent=Euclid}
{wiki}

= Synthetic geometry
{parent=Euclid's Elements}
{wiki}

A way to defined geometry without talking about coordinates, i.e. like <Euclid's Elements>, notably <Euclid's postulates>, as opposed to <Descartes>'s <Real coordinate space>.

= Euclid's postulates
{c}
{parent=Euclid's Elements}

Postulates are what we now call <axioms>.

There are 5: https://en.wikipedia.org/w/index.php?title=Euclidean_geometry&oldid=1036511366#Axioms[], the <parallel postulate> being the most controversial/interesting.

= Parallel postulate
{parent=Euclid's postulates}
{wiki}

= Évariste Galois
{c}
{parent=List of mathematicians}
{wiki}

= Galois
{c}
{synonym}

= G. H. Hardy
{c}
{parent=List of mathematicians}
{wiki}

= A Mathematician's Apology
{c}
{parent=G. H. Hardy}
{title2=1940}
{wiki}

With major mathematicians holding ideas such as:
\Q[[Exposition, criticism, appreciation, is work for second-rate minds. [...] It is a melancholy experience for a professional mathematician to find himself writing about mathematics. The function of a mathematician is to do something, to prove new theorems, to add to mathematics, and not to talk about what he or other mathematicians have done.]]
it is not surprise that the state of <STEM> education is so shit as of 2020, especially at the <the missing link between basic and advanced>! This also implies that the number of people that can appreciate any advanced mathematics research is tiny, and consequently so is the funding.

= Henri Poincaré
{c}
{parent=List of mathematicians}
{tag=École Polytechnique alumnus}
{tag=Physicist}
{wiki}

= Poincaré
{synonym}

= James Harris Simons
{c}
{parent=List of mathematicians}
{wiki}

<Ciro Santilli's wife>, who was frustrated with <academia> at some point, admires the fact that Simons managed to make infinite money, and then invested back in actual science, e.g. through the <Simons Foundation>.

= Joseph Fourier
{c}
{parent=List of mathematicians}
{wiki}

= Fourier
{c}
{synonym}

= Paul Erdos
{c}
{parent=List of mathematicians}
{wiki}

= Erdos number
{c}
{parent=Paul Erdos}
{wiki}

= René Descartes
{c}
{parent=List of mathematicians}
{wiki}

= Descartes
{c}
{synonym}

= Mathematical notation
{parent=Mathematics}
{wiki}

It is hard to decide what makes <Ciro Santilli> more sad: the usage of <Greek letters>, the invention of new symbols, or the fifty million alternative font styles used.

Only <Chinese characters> could be worse than that!

= Mathematical symbol that looks like a Greek letter but isn't
{parent=Mathematical notation}

These are not in the <Greek alphabet>:
* <nabla>{child}
* <partial derivative symbol>{child}

= Number theory
{parent=Mathematics}
{wiki}

= Arithmetic
{parent=Number theory}
{wiki}

Definition: "easy" number theory learnt in <primary school>, notably the operations of <addition>, <subtraction>, <multiplication> and <division>.

= Computational number theory
{parent=Number theory}
{wiki}

= Modular arithmetic
{parent=Number theory}
{wiki}

= Modulo operation
{parent=Modular arithmetic}
{wiki}

= Modulo
{synonym}

= Modular multiplication
{parent=Modular arithmetic}

= Modular multiplicative inverse
{parent=Modular multiplication}

= Modular exponentiation
{parent=Modular arithmetic}
{wiki}

Can be calculated efficiently with the <extended Euclidean algorithm>.

= Computational complexity of modular exponentiation
{parent=Modular exponentiation}

https://math.stackexchange.com/questions/2382011/computational-complexity-of-modular-exponentiation-from-rosens-discrete-mathem mentions:
$$
b^n mod m
$$
can be calculated in:
$$
log(m)^2 log(n)
$$
Remember that $log(m)$ and $log(n)$ are the lengths in bits of $m$ and $n$, so in terms of the length in bits $M$ and $N$ we'd get:
$$
M^2 N
$$

= Lowest common denominator
{parent=Number theory}
{title2=LCD}
{wiki}

= Prime number
{parent=Number theory}
{wiki}

= Prime
{synonym}

= Prime k-tuple
{parent=Prime number}
{wiki}

= Admissible prime k-tuple
{parent=Prime k-tuple}

= Prime k-tuple conjecture
{parent=Admissible prime k-tuple}

There are infinitely many <prime k-tuples> for every admissible tuple.

Generalization of the <Twin prime conjecture>.

As of 2023, there was no specific admissible tuple for which it had been proven that there infinite of, only bounds of type:
\Q[there are infinitely 2-tuple instances with at most a finite bound]
But these do not specify which specific tuple, e.g. <Yitang Zhang's theorem>.

= Yitang Zhang's theorem
{parent=Prime k-tuple conjecture}
{title2=2013}

There are infinitely many primes with a neighbour not further apart than 70 million. This was the first such finite bound to be proven, and therefore a major breakthrough.

This implies that for at least one value (or more) below 70 million there are infinitely many repetitions, but we don't know which e.g. we could have infinitely many:
$$
k, k + 2
$$
or infinitely many:
$$
k, k + 4
$$
or infinitely many:
$$
k, k + 6,999,999
$$
or infinitely many:
$$
k, k + 2 and k, k + 4
$$
but we don't know which of those.

The <Prime k-tuple conjecture> conjectures that it is all of them.

Also, if 70 million could be reduced down to 2, we would have a proof of the <Twin prime conjecture>, but this method would only work for (k, k + 2).

= Twin prime
{parent=Prime k-tuple}
{wiki}

= Twin prime conjecture
{parent=Twin prime}
{tag=Famous conjecture}
{tag=Prime k-tuple conjecture}
{wiki}

Let's show them how it's done with <primes (bsdgames)> + <awk>. Edit. They have a `-d` option which also shows gaps!!! Too strong:
``
sudo apt install bsdgames
primes -d 1 100 | awk '/\(2\)/{print $1 - 2, $1 }'
``
gives us the list of all twin primes up to 100:
``
0 2
3 5
5 7
11 13
17 19
29 31
41 43
59 61
71 73
``
Tested on <Ubuntu 22.10>.

= Goldbach's conjecture
{c}
{parent=Prime number}
{tag=Additive basis theorem}
{title2=Every even natural number greater than 2 is the sum of two prime numbers}
{wiki}

= Goldbach conjecture
{c}
{synonym}

= Sums of three cubes
{parent=Goldbach's conjecture}
{wiki}

= Mersenne prime
{c}
{parent=Prime number}

= Are there infinitely many Mersenne primes?
{parent=Mersenne prime}
{tag=Famous conjecture}

= Lucas-Lehmer primality test
{c}
{parent=Mersenne prime}
{tag=Primality test}
{wiki}

= Prime number theorem
{parent=Prime number}
{wiki}

= prime-number-theorem
{file}
{parent=Prime number theorem}

Consider this is a study in failed <computational number theory>.

The $n/ln(n)$ approximation converges really slowly, and we can't easy go far enough to see that the ration converges to 1 with only <awk> and <primes (bsdgames)>:
``
sudo apt intsall bsdgames
cd prime-number-theorem
./main.py 100000000
``
Runs in 30 minutes tested on <Ubuntu 22.10> and <Ciro Santilli's hardware/p51>, producing:

\Image[https://raw.githubusercontent.com/cirosantilli/media/master/prime-number-theorem/pi.png]
{title=Linear $\pi(n)$ vs $n/ln(n)$ approximation plot}
{description=$f(n) = n$ and $f(n) = log(n)$ are added to give a better sense of scale. $log(n)$ is too close to 0 and not visible, and the approximation almost overlaps entirely with $pi$.}

\Image[https://raw.githubusercontent.com/cirosantilli/media/master/prime-number-theorem/pi-minus.png]
{title=$\pi(n) - n/ln(n)$}
{description=It is clear that the difference diverges, albeit very slowly.}

\Image[https://raw.githubusercontent.com/cirosantilli/media/master/prime-number-theorem/pi-over.png]
{title=$\pi(n)/(n/ln(n))$}
{id=image-pi-n-over-n-ln-n}
{description=We just don't have enough points to clearly see that it is converging to 1.0, the convergence truly is very slow. The <logarithm integral> approximation is much much better, but we can't calculate it in <awk>, sadface.}

But looking at: https://en.wikipedia.org/wiki/File:Prime_number_theorem_ratio_convergence.svg we see that it takes way longer to get closer to 1, even at $10^24$ it is still not super close. Inspecting the code there we see:
``
(* Supplement with larger known PrimePi values that are too large for \
Mathematica to compute *)
LargePiPrime = {{10^13, 346065536839}, {10^14, 3204941750802}, {10^15,
     29844570422669}, {10^16, 279238341033925}, {10^17,
    2623557157654233}, {10^18, 24739954287740860}, {10^19,
    234057667276344607}, {10^20, 2220819602560918840}, {10^21,
    21127269486018731928}, {10^22, 201467286689315906290}, {10^23,
    1925320391606803968923}, {10^24, 18435599767349200867866}};
``
so OK, it is not something doable on a <personal computer> just like that.

= Prime power
{parent=Prime number}
{wiki}

They come up a lot in many contexts, e.g.:
* <classification of finite fields>

= Primality test
{parent=Prime number}
{wiki}

= Elliptic curve primality
{parent=Primality test}
{tag=Elliptic curve}
{wiki}

= Elliptic curve primality testing
{synonym}

<Polynomial time> for most inputs, but not for some very rare ones. TODO can they be determined?

But it is better in practice than the <AKS primality test>, which is always <polynomial time>.

= AKS primality test
{c}
{parent=Primality test}
{title2=2002}
{title2=First polynomial time primality test discovered}
{tag=Polynomial time}
{wiki}

= Greatest common divisor
{parent=Prime number}
{title2=GCD}
{wiki}

= Coprime
{parent=Greatest common divisor}
{wiki}

Two numbers such that the <greatest common divisor> is 1.

= Euclidean algorithm
{c}
{parent=Greatest common divisor}
{wiki}

= Extended Euclidean algorithm
{c}
{parent=Euclidean algorithm}
{wiki}

= Least common multiple
{c}
{parent=Prime number}
{title2=lcm}
{wiki}

= Numerical analysis
{parent=Mathematics}
{wiki}

Techniques to get numerical approximations to numeric <mathematical> problems.

The entire field comes down to estimating the true values with a known error bound, and creating algorithms that make those error bounds asymptotically smaller.

Not the most beautiful field of pure <mathematics>, but fundamentally useful since we can't solve almost any <computational physics>[useful equation] without computers!

The solution visualizations can also provide valuable intuition however.

Important numerical analysis problems include solving:
* <partial differential equations>

= Floating-point arithmetic
{parent=Numerical analysis}
{wiki}

= Floating-point number
{parent=Floating-point arithmetic}
{wiki}

= IEEE 754
{c}
{parent=Floating-point arithmetic}
{wiki}

Selected answers by <Ciro Santilli> on the subject:
* https://stackoverflow.com/questions/18118408/what-is-difference-between-quiet-nan-and-signaling-nan/55648118#55648118[What is difference between quiet NaN and signaling NaN?]
* https://stackoverflow.com/questions/2618059/in-java-what-does-nan-mean/55673220#55673220[In Java, what does NaN mean?]
* https://stackoverflow.com/questions/8341395/what-is-a-subnormal-floating-point-number/53203428#53203428[What is a subnormal floating point number?]

= Half-precision floating-point format
{parent=IEEE 754}
{wiki}

= 16-bit floating point
{synonym}
{title2}

= Numerical computing language
{parent=Numerical analysis}

All those dedicated <applied mathematicians> languages are a waste of society's time, <Ciro Santilli> sure <applied mathematicians> are capable of writing a few extra braces in exchange for a sane general purpose language, we should instead just invest in good libraries with fast <C (programming language)> bindings for those languages like <NumPy> where needed, and powerful mainlined <integrated development environments>.

And when <Ciro Santilli> see the closed source ones like <MATLAB> being used, it makes him lose all hope on humanity. Why. As of 2020. Why? In the 1980s, maybe. But in the 2020s?

= Scilab
{c}
{parent=Numerical computing language}
{wiki}

= MATLAB
{c}
{parent=Numerical computing language}
{wiki}

= MATLAB methlab pun
{c}
{parent=MATLAB}

\Image[https://web.archive.org/web/20171026130800im_/http://www.allafinedelpalo.it/wp-content/uploads/2016/03/methlab2.png]
{title=MATLAB <Breaking Bad> crossover}
{source=http://www.allafinedelpalo.it/methlab-il-toolbox-di-matlab-ispirato-a-breaking-bad/}

= Perturbation theory
{parent=Numerical analysis}
{wiki}

Used a lot in <quantum mechanics>, where the equations are really hard to solve. There's even a dedicated wiki page for it: https://en.wikipedia.org/wiki/Perturbation_theory_(quantum_mechanics)[]. Notably, <Feynman diagrams> are a way to represent perturbation calculations in <quantum field theory>.

Let's gather some of the best results we come across here:
* <Dirac equation solution for the hydrogen atom>

= Polynomial
{parent=Mathematics}
{wiki}

= Degree of a polynomial
{parent=Polynomial}

= Degree of the polynomial
{synonym}

= Algebraic equation
{parent=Polynomial}
{tag=Functional equation}
{wiki}

= Polynomial equation
{synonym}
{title2}

= Named algebraic equation
{parent=Algebraic equation}

= Quadratic equation
{parent=Named algebraic equation}
{wiki}

= Quadratic formula
{parent=Quadratic equation}
{wiki}

= Cubic equation
{parent=Named algebraic equation}
{wiki}

= Quartic equation
{parent=Named algebraic equation}
{wiki}

= Quintic equation
{parent=Named algebraic equation}
{wiki}

= Abel-Ruffini theorem
{c}
{parent=Quintic equation}
{wiki}

= Algebraic number
{parent=Algebraic equation}
{tag=Number}
{title2=Root of a polynomial}
{wiki}

= Algebraic number field
{parent=Algebraic number}
{tag=Quadratically closed field}
{title2=$\overline{\Q}$}
{wiki=https://en.wikipedia.org/w/index.php?title=Algebraic_number&oldid=1168427661#Field}

The set of all <algebraic numbers> forms a <field>.

This field contains all of the <rational numbers>, but it is a <quadratically closed field>.

Like the <rationals>, this field also has the same <cardinality> as the <natural numbers>, because we can specify and enumerate each of its members by a fixed number of integers from the <polynomial equation> that defines them. So it is a bit like the <rationals>, but we use potentially arbitrary numbers of integers to specify each number (polynomial coefficients + index of which root we are talking about) instead of just always two as for the rationals.

Each <algebraic number> also has a degree associated to it, i.e. the <degree of the polynomial> used to define it.

= Algebraic function
{parent=Algebraic number}
{title2=Root of a polynomial}
{wiki}

TODO understand.

= Transcendental number
{parent=Algebraic number}
{wiki}

Sometimes <mathematicians> go a little overboard with their naming.

= Transcendental number conjecture
{parent=Transcendental number}
{tag=Simple to state but hard to prove}

Open as of 2020:
* $e + \pi$

\Video[https://www.youtube.com/watch?v=BdHFLfv-ThQ]
{title=Why π^π^π^π could be an integer by Stand-up Maths (2021)}
{description=Sponsored by Jane Street. <finance is a cancer of society>[Shame].}

= Diophantine equation
{c}
{parent=Polynomial}
{wiki}

<Polynomial> (possibly a <multivariate polynomial>) with <integer> coefficients.

Sometimes systems of <Diophantine equations> are considered.

Problems generally involve finding integer solutions to the equations, notably determining if any solution exists, and if infinitely solutions exist.

The general problem is known to be <undecidable>: <Hilbert's tenth problem>.

The <Pythagorean triples>, and its generalization <Fermat's last theorem>, are the quintessential examples.

= Pythagorean triple
{c}
{parent=Diophantine equation}
{title2=$a^2 + b^2 = c^2$}
{wiki}

\Image[https://web.archive.org/web/20220528162407im_/https://upload.wikimedia.org/wikipedia/commons/4/4c/Pythagorean_theorem_-_Ani.gif]
{source=https://en.wikipedia.org/wiki/File:Pythagorean_theorem_-_Ani.gif}

= Euclid's formula
{c}
{parent=Pythagorean triple}
{wiki=Pythagorean_triple#Generating_a_triple}

= There are infinitely many Pythagorean triples
{parent=Euclid's formula}

Direct consequence of <Euclid's formula>.

= Euclid's formula generates all Pythagorean triples
{parent=Euclid's formula}

= Classification of Pythagorean triples
{parent=Pythagorean triple}
{tag=Classification (mathematics)}

https://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple

= Taxicab number
{parent=Pythagorean triple}
{wiki}

= Fermat's last theorem
{c}
{parent=Pythagorean triple}
{wiki}

A generalization of the <Pythagorean triple> infinity question.

= Hilbert's tenth problem
{c}
{parent=Diophantine equation}
{tag=Undecidable problem}
{tag=Hilbert's problems}
{title2=Determine if one Diophantine equation has a solution}
{title2=1970}
{wiki}

Once you hear about the <uncomputability> of such problems, it makes you see that all <Diophantine equation> questions risk being <undecidable>, though in some simpler cases we manage to come up with answers. The feeling is similar to watching people trying to solve the <Halting problem>, e.g. in the effort to determine <BB(5)>.

= Undecidable Diophantine equation example
{parent=Hilbert's tenth problem}

= Undecidable Diophantine equation problems
{synonym}

https://mathoverflow.net/questions/11540/what-are-the-most-attractive-turing-undecidable-problems-in-mathematics/103415#103415 provides a specific single undecidable <Diophantine equation>.

= Hilbert's tenth problem over other fields
{c}
{parent=Hilbert's tenth problem}

https://mathoverflow.net/questions/11540/what-are-the-most-attractive-turing-undecidable-problems-in-mathematics/11557#11557 contains a good overview of the decidability status of variants over <fields> other than the <integers>.

= Additive number theory
{parent=Diophantine equation}
{wiki}

= Additive basis
{parent=Additive number theory}
{wiki}

= Additive basis theorem
{parent=Additive basis}

= Waring's problem
{c}
{parent=Additive basis theorem}
{title2=Every number is a sum of $g$ positive numbers to the power of $k$}
{wiki}

And when it can't, attempt to classify which subset of the <integers> can be reached. E.g. <Legendre's three-square theorem>.

= Waring's problem for squares
{c}
{parent=Waring's problem}

4 squares are sufficient by <Lagrange's four-square theorem>.

3 is not enough by <Legendre's three-square theorem>.

The subsets reachable with 2 and 3 squares are fully characterized by <Legendre's three-square theorem> and 

= Lagrange's four-square theorem
{c}
{parent=Waring's problem for squares}
{title2=Every natural number is a sum of four squares}
{title2=1770}
{wiki}

= Legendre's three-square theorem
{c}
{parent=Waring's problem for squares}
{title2=iff not of form $4^a(8b + 7)$}
{title2=1770}
{wiki}

= Sum of two squares theorem
{parent=Waring's problem for squares}
{wiki}

= Waring problem variant
{parent=Waring's problem}

= Waring problem with negative numbers allowed
{parent=Waring problem variant}

= Sum of three cubes
{parent=Waring problem with negative numbers allowed}
{title2=Every number has infinitely many representations as the sum of three cubes}
{tag=Open problem in mathematics}
{wiki}

Compared to <Waring's problem>, this is potentially much harder, as we can go infinitely negative in our attempts, there isn't a bound on how many tries we can have for each number.

In other words, it is unlikely to have a <conjecture reduction to a halting problem>.

\Video[https://www.youtube.com/watch?v=GXhzZAem7k0]
{title=3 as the sum of the 3 cubes by <Numberphile> (2019)}

= Waring-Goldbach problem
{c}
{parent=Waring problem variant}
{tag=Goldbach's conjecture}
{wiki}

It is exactly what you'd expect from the name, Waring was <Netflix and chill>[watching Netflix] with Goldbach, when they suddenly came up with this.

= Named small order polynomial
{parent=Polynomial}

= Linear polynomial
{parent=Named small order polynomial}

A <polynomial> of degree 1, i.e. of form $ax + b$.

= Galois theory
{c}
{parent=Polynomial}
{wiki}

= Irreducible polynomial
{parent=Polynomial}
{wiki}

= Multivariate polynomial
{parent=Polynomial}

A <polynomial> with multiple input arguments, e.g. with two inputs $x$ and $y$:
$$
f(x, y) = x^2 + 2x + y^3 + 1
$$
as opposed to a <polynomial> with a single argument e.g. one with just $x$:
$$
f(x) = x^2 + 2x + 1
$$

= Polynomial over a field
{parent=Polynomial}
{title2=$Field[X]$}
{wiki}

By default, we think of polynomials over the <real numbers> or <complex numbers>.

However, a polynomial can be defined over any other field just as well, the most notable example being that of a polynomial over a <finite field>.

For example, given the finite field of <order (algebra)> 9, $GP(3)$ and with elements $\{0, 1, 2\}$, we can denote polynomials over that ring as
$$
GP(3)[x]
$$
where $x$ is the variable name.

For example, one such polynomial could be:
$$
P(x) = 2x^4 + x^2 + 2
$$
and another one:
$$
Q(X) = x^3 + 2x^2 + 2
$$
Note how all the coefficients are members of the finite field we chose.

Given this, we could evaluate the polynomial for any element of the field, e.g.:
$$
P(0) = 2 (0 \times 0 \times 0 \times 0) + (0 \times 0) + 2 = 2
P(1) = 2 (1 \times 1 \times 1 \times 1) + (1 \times 1) + 2 = 2 (1) + 1 + 2 = 2
P(2) = 2 (2 \times 2 \times 2 \times 2) + (2 \times 2) + 2 = 2 (16 % 3) + (4 % 3) + 2 = 2 + 1 + 2 = 2
$$
and so on.

We can also add polynomials as usual over the field:
$$
P(x) + Q(x) = 2x^4 + x^3 + (1+2)x^2 + (2 + 2) = 2x^4 + x^3 + (0)x^2 + 1 = 2x^4 + x^3 + 1
$$
and multiplication works analogously.

= Polynomial over a ring
{parent=Polynomial over a field}
{wiki}

The usual definition of a <polynomial> is over a <field (mathematics)> as shown at <polynomial over a field>.

However, there is nothing in the immediate definition that prevents us from having a <ring (mathematics)> instead, i.e. a <field (mathematics)> but without the <commutative property> and <inverse elements>.

The only thing is that then we would need to differentiate between different orderings of the terms of <multivariate polynomial>, e.g. the following would all be potentially different terms:
$$
2xxy + 2xyx + 2yxx +
x2xy + x2yx + y2xx +
xx2y + xy2x + yx2x +
xxy2 + xyx2 + yxx2
$$
while for a field they would all go into a single term:
$$
12x^2y
$$
so when considering a polynomial over a <ring (mathematics)> we end up with a lot more more possible terms.

= Polynomial ring
{parent=Polynomial}
{wiki}

The polynomials together with polynomial addition and multiplication form a <commutative> <ring (mathematics)>.

= Probability
{parent=Mathematics}
{wiki}

= Expectation value
{parent=Probability}
{wiki}

= Stochastic process
{parent=Probability}
{wiki}

= Markov chain
{c}
{parent=Stochastic process}
{wiki}

A directed <weighted graph> where the sum of weights of all outgoing edges equals 1.

= Average number of steps until reaching a state of a Markov chain
{parent=Markov chain}
{wiki}

TODO how to calculate

= Average number of steps spent on a node of a Markov chain
{parent=Markov chain}
{wiki}

TODO how to calculate

= Absorbing Markov chain
{parent=Markov chain}
{wiki}

= Probability distribution
{parent=Probability}
{wiki}

= Cumulative distribution function
{parent=Probability}

= Standard deviation
{parent=Probability}
{wiki}

= Statistics
{parent=Probability}
{wiki}

= Descriptive statistics
{parent=Statistics}
{wiki}

= Arithmetic mean
{parent=Descriptive statistics}
{wiki}

= Mean
{synonym}

= Mode
{disambiguate=statistics}
{parent=Descriptive statistics}
{wiki}

= Variance
{parent=Descriptive statistics}
{wiki}

= Mathematics bibliography
{parent=Mathematics}

= Mathematics website
{parent=Mathematics bibliography}

= Visual math HTML book
{parent=Mathematics website}

When you see some tagged examples, you will immediately know what this means.

= Theorem of the Day
{parent=Mathematics website}

<Website>: https://www.theoremoftheday.org/

= Mathematics YouTube channel
{parent=Mathematics bibliography}

= 3Blue1Brown
{c}
{parent=Mathematics YouTube channel}
{wiki}

https://www.youtube.com/channel/UCYO_jab_esuFRV4b17AJtAw

Amazing graphs and formulas.

Python graphics engine open sourced at: https://github.com/3b1b/manim "Animation engine for explanatory math videos". But for some reason there is a community fork: https://github.com/ManimCommunity/manim/ "This repository is maintained by the Manim Community, and is not associated with Grant Sanderson or 3Blue1Brown in any way (though we are definitely indebted to him for providing his work to the world). If you want to study how Grant makes his videos, head over to his repository (3b1b/manim). This is a more frequently updated repository than that one, and is recommended if you want to use Manim for your own projects." what a mess.

= MathDoctorBob
{c}
{parent=Mathematics YouTube channel}
{title2=Robert Donley}

https://www.youtube.com/user/MathDoctorBob/videos

He got so old from 2012 to 2021 :-)

This dude did well. If only he had <OurBigBook.com>[written a hyperlinked wiki rather than making videos]! It would allow people to jump in at any point and just click back. It would be Godlike.

https://mathdoctorbob.org/About.html says:
\Q[Robert Donley received his doctorate in Mathematics from Stony Brook University and has over two decades of teaching experience at the high school, undergraduate, and graduate levels.]

= Numberphile
{c}
{parent=Mathematics YouTube channel}
{tag=Brady Haran production}
{wiki}

https://www.youtube.com/@numberphile

<!doctype html>
<html lang=en>
<head>
<meta charset=utf-8>
<title>x86 Paging Tutorial - Ciro Santilli</title>
<meta property="og:title" content="x86 Paging Tutorial - Ciro Santilli">
<meta property="og:type" content="website">
<meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/5/59/Funny_comparison_between_the_Linux_Kernel_and_The_Matrix_due_to_userland_memory_virtualization.png">
<meta property="og:url" content="https://cirosantilli.com/x86-paging">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.10.1/css/all.min.css" integrity="sha512-9my9Mb2+0YO+I4PUCSwUYO7sEK21Y0STBAiFEYoWtd2VzLEZZ4QARDrZ30hdM1GlioHJ8o8cWQiy8IAb1hy/Hg==" crossorigin="anonymous" referrerpolicy="no-referrer">
<link rel="canonical" href="https://ourbigbook.com/cirosantilli/x86-paging">
<style>@import "_obb/dist/ourbigbook.css";

</style>
<link rel="stylesheet" type="text/css" href="_raw/main.css">
<link rel="shortcut icon" type="image/x-icon" href="https://raw.githubusercontent.com/cirosantilli/media/master/ID_photo_of_Ciro_Santilli_taken_in_2013_square_398.jpg">
</head>
<body>
<header>
<div class="brand-group">
<a href="." class="brand"><img src="https://raw.githubusercontent.com/cirosantilli/media/master/ID_photo_of_Ciro_Santilli_taken_in_2013_right_eye_200_100.jpg" loading="lazy" alt="ID photo of Ciro Santilli taken in 2013 right eye">Ciro Santilli</a>
<a href="https://ourbigbook.com/cirosantilli"><img src="https://raw.githubusercontent.com/cirosantilli/media/master/ourbigbook-logo-v1.svg" loading="lazy" alt="OurBigBook logo">OurBigBook.com</a>
<a class="font-awesome-container" href="https://stackoverflow.com/users/895245"><i class="fab fa-stack-overflow fa-fw icon"></i></a>
<a class="font-awesome-container" href="https://github.com/cirosantilli"><i class="fab fa-github fa-fw icon"></i></a>
<a class="font-awesome-container" href="https://www.linkedin.com/in/cirosantilli"><i class="fab fa-linkedin fa-fw icon"></i></a>
<a class="font-awesome-container" href="https://www.youtube.com/c/CiroSantilli"><i class="fab fa-youtube fa-fw icon"></i></a>
<a class="font-awesome-container" href="https://twitter.com/cirosantilli"><i class="fab fa-twitter fa-fw icon"></i></a>
<a class="font-awesome-container" href="https://www.zhihu.com/people/cirosantilli/activities"><i class="fab fa-zhihu fa-fw icon"></i></a>
<a class="font-awesome-container" href="https://www.weibo.com/p/1005055601627311"><i class="fab fa-weibo fa-fw icon"></i></a>
<a href="sponsor"><span class="icon">$£</span>&nbsp;Sponsor</a>
<a href="https://github.com/cirosantilli/china-dictatorship"><span class="icon">中国</span>独裁统治&nbsp;China Dictatorship 新疆改造中心、六四事件、法轮功、郝海东、709大抓捕、2015巴拿马文件 邓家贵、低端人口、西藏骚乱</a>
</div>
</header>
<main class="ourbigbook">
<div class="h top" id="x86-paging"><div class="notnav"><h1><a href="x86-paging-split">x86 Paging Tutorial</a></h1></div><nav class="h-nav h-nav-toplevel"><div class="nav ancestors"><a  href="#_ancestors">&nbsp;...</a><a href="computer-hardware"> Computer hardware</a><a href="computer-hardware#computer-hardware-component-type"> Computer hardware component type</a><a href="computer-hardware#processor-computing"> Processor (computing)</a><a href="computer-hardware#instruction-set-architecture"> Instruction set architecture</a><a href="computer-hardware#list-of-instruction-set-architectures"> List of instruction set architectures</a><a href="computer-hardware#x86"> x86</a></div><div class="nav"><span class="pill" title="Created date"><span class="time-icon"></span> <span class="desktop-hide new-article-icon"></span><span class="mobile-hide">Created</span> <span>2014-12-16</span></span><a href="#_toc" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a><span class="tags"> Tags: <a href="articles">The best articles by Ciro Santilli</a></span><a class="split" href="x86-paging-split"></a><span class="metrics"><span class="wcntr"> Words: 6k</span><span class="dcnt"> Articles: 39</span></span></div></nav></div><div class="p" id="_2">This tutorial explains the very basics of how paging works, with focus on <a href="computer-hardware#x86">x86</a>, although most high level concepts will also apply to other <a href="computer-hardware#instruction-set-architecture">instruction set architectures</a>, e.g. <a href="computer-hardware#arm-architecture-family">ARM</a>.</div><div class="p" id="_3">The goals are to:<div class="list"><ul id="_4"><li id="_5">demonstrate minimal concrete simplified paging examples that will be useful to those learning paging for the first time</li><li id="_6">explain the motivation behind paging</li></ul></div></div><div class="p" id="_7">This tutorial was extracted and expanded from <a href="https://stackoverflow.com/a/18431262/895245">this Stack Overflow answer</a>.</div><div class="toc-container" id="_toc"><ul><li class="has-child toplevel"><div class="title-div"><div class="arrow"><div></div></div><span class="not-arrow"><a class="title toc" href="#_toc"> Table of contents</a><input class="search" placeholder="🔍 Search. Shortcut: / (slash)"><span class="hover-metadata"><span class="metrics"><span class="wcntr"> 6k</span><span class="dcnt"> 39</span></span></span></span></div><ul><li><div id="_toc/sample-code"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#sample-code"><i class="n">1. </i>Sample code</a><span class="hover-metadata"><a href="#_toc" class="u"> x86 Paging Tutorial</a><span class="metrics"><span class="wcntr"> 43</span></span></span></span></div></li><li><div id="_toc/intel-manual"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#intel-manual"><i class="n">2. </i>Intel manual</a><span class="hover-metadata"><a href="#_toc" class="u"> x86 Paging Tutorial</a><span class="metrics"><span class="wcntr"> 60</span></span></span></span></div></li><li><div id="_toc/application"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#application"><i class="n">3. </i>Application</a><span class="hover-metadata"><a href="#_toc" class="u"> x86 Paging Tutorial</a><span class="metrics"><span class="wcntr"> 341</span></span></span></span></div></li><li><div id="_toc/hardware-implementation"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#hardware-implementation"><i class="n">4. </i>Hardware implementation</a><span class="hover-metadata"><a href="#_toc" class="u"> x86 Paging Tutorial</a><span class="metrics"><span class="wcntr"> 275</span></span></span></span></div></li><li><div id="_toc/segmentation"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#segmentation"><i class="n">5. </i>Segmentation</a><span class="hover-metadata"><a href="#_toc" class="u"> x86 Paging Tutorial</a><span class="metrics"><span class="wcntr"> 126</span></span></span></span></div></li><li class="has-child"><div id="_toc/example-simplified-single-level-paging-scheme"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#example-simplified-single-level-paging-scheme"><i class="n">6. </i>Example: simplified single-level paging scheme</a><span class="hover-metadata"><a href="#_toc" class="u"> x86 Paging Tutorial</a><span class="metrics"><span class="wcntr"> 2k</span><span class="dcnt"> 7</span></span></span></span></div><ul><li><div id="_toc/single-level-paging-scheme-visualization"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#single-level-paging-scheme-visualization"><i class="n">6.1. </i>Single level paging scheme visualization</a><span class="hover-metadata"><a href="#_toc/example-simplified-single-level-paging-scheme" class="u"> Example: simplified single-level paging scheme</a><span class="metrics"><span class="wcntr"> 260</span></span></span></span></div></li><li><div id="_toc/single-level-paging-scheme-numerical-translation-example"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#single-level-paging-scheme-numerical-translation-example"><i class="n">6.2. </i>Single level paging scheme numerical translation example</a><span class="hover-metadata"><a href="#_toc/example-simplified-single-level-paging-scheme" class="u"> Example: simplified single-level paging scheme</a><span class="metrics"><span class="wcntr"> 563</span></span></span></span></div></li><li><div id="_toc/multiple-addresses-translate-to-a-single-physical-address"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#multiple-addresses-translate-to-a-single-physical-address"><i class="n">6.3. </i>Multiple addresses translate to a single physical address</a><span class="hover-metadata"><a href="#_toc/example-simplified-single-level-paging-scheme" class="u"> Example: simplified single-level paging scheme</a><span class="metrics"><span class="wcntr"> 82</span></span></span></span></div></li><li><div id="_toc/identity-mapping"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#identity-mapping"><i class="n">6.4. </i>Identity mapping</a><span class="hover-metadata"><a href="#_toc/example-simplified-single-level-paging-scheme" class="u"> Example: simplified single-level paging scheme</a><span class="metrics"><span class="wcntr"> 28</span></span></span></span></div></li><li><div id="_toc/page-faults"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#page-faults"><i class="n">6.5. </i>Page faults</a><span class="hover-metadata"><a href="#_toc/example-simplified-single-level-paging-scheme" class="u"> Example: simplified single-level paging scheme</a><span class="metrics"><span class="wcntr"> 300</span></span></span></span></div></li><li><div id="_toc/page-table-entries"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#page-table-entries"><i class="n">6.6. </i>Page table entries</a><span class="hover-metadata"><a href="#_toc/example-simplified-single-level-paging-scheme" class="u"> Example: simplified single-level paging scheme</a><span class="metrics"><span class="wcntr"> 211</span></span></span></span></div></li><li><div id="_toc/page-size-choice"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#page-size-choice"><i class="n">6.7. </i>Page size choice</a><span class="hover-metadata"><a href="#_toc/example-simplified-single-level-paging-scheme" class="u"> Example: simplified single-level paging scheme</a><span class="metrics"><span class="wcntr"> 118</span></span></span></span></div></li></ul><li class="has-child"><div id="_toc/example-multi-level-paging-scheme"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#example-multi-level-paging-scheme"><i class="n">7. </i>Example: multi-level paging scheme</a><span class="hover-metadata"><a href="#_toc" class="u"> x86 Paging Tutorial</a><span class="metrics"><span class="wcntr"> 1k</span><span class="dcnt"> 5</span></span></span></span></div><ul><li><div id="_toc/the-problem-with-single-level-paging"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#the-problem-with-single-level-paging"><i class="n">7.1. </i>The problem with single-level paging</a><span class="hover-metadata"><a href="#_toc/example-multi-level-paging-scheme" class="u"> Example: multi-level paging scheme</a><span class="metrics"><span class="wcntr"> 109</span></span></span></span></div></li><li><div id="_toc/k-ary-trees-to-the-rescue"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#k-ary-trees-to-the-rescue"><i class="n">7.2. </i>K-ary trees to the rescue</a><span class="hover-metadata"><a href="#_toc/example-multi-level-paging-scheme" class="u"> Example: multi-level paging scheme</a><span class="metrics"><span class="wcntr"> 309</span></span></span></span></div></li><li><div id="_toc/why-not-a-balanced-tree"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#why-not-a-balanced-tree"><i class="n">7.3. </i>Why not a balanced tree</a><span class="hover-metadata"><a href="#_toc/example-multi-level-paging-scheme" class="u"> Example: multi-level paging scheme</a><span class="metrics"><span class="wcntr"> 65</span></span></span></span></div></li><li><div id="_toc/how-the-k-ary-tree-is-used-in-x86"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#how-the-k-ary-tree-is-used-in-x86"><i class="n">7.4. </i>How the K-ary tree is used in x86</a><span class="hover-metadata"><a href="#_toc/example-multi-level-paging-scheme" class="u"> Example: multi-level paging scheme</a><span class="metrics"><span class="wcntr"> 352</span></span></span></span></div></li><li><div id="_toc/multi-level-paging-scheme-numerical-translation-example"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#multi-level-paging-scheme-numerical-translation-example"><i class="n">7.5. </i>Multi-level paging scheme numerical translation example</a><span class="hover-metadata"><a href="#_toc/example-multi-level-paging-scheme" class="u"> Example: multi-level paging scheme</a><span class="metrics"><span class="wcntr"> 460</span></span></span></span></div></li></ul><li><div id="_toc/64-bit-architectures"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#64-bit-architectures"><i class="n">8. </i>64-bit architectures</a><span class="hover-metadata"><a href="#_toc" class="u"> x86 Paging Tutorial</a><span class="metrics"><span class="wcntr"> 182</span></span></span></span></div></li><li><div id="_toc/pae"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#pae"><i class="n">9. </i>PAE</a><span class="hover-metadata"><a href="#_toc" class="u"> x86 Paging Tutorial</a><span class="metrics"><span class="wcntr"> 114</span></span></span></span></div></li><li><div id="_toc/pse"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#pse"><i class="n">10. </i>PSE</a><span class="hover-metadata"><a href="#_toc" class="u"> x86 Paging Tutorial</a><span class="metrics"><span class="wcntr"> 33</span></span></span></span></div></li><li><div id="_toc/pae-and-pse-page-table-schemes"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#pae-and-pse-page-table-schemes"><i class="n">11. </i>PAE and PSE page table schemes</a><span class="hover-metadata"><a href="#_toc" class="u"> x86 Paging Tutorial</a><span class="metrics"><span class="wcntr"> 300</span></span></span></span></div></li><li class="has-child"><div id="_toc/tlb"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#tlb"><i class="n">12. </i>TLB</a><span class="hover-metadata"><a href="#_toc" class="u"> x86 Paging Tutorial</a><span class="metrics"><span class="wcntr"> 677</span><span class="dcnt"> 4</span></span></span></span></div><ul><li><div id="_toc/basic-tlb-operation"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#basic-tlb-operation"><i class="n">12.1. </i>Basic TLB operation</a><span class="hover-metadata"><a href="#_toc/tlb" class="u"> TLB</a><span class="metrics"><span class="wcntr"> 166</span></span></span></span></div></li><li><div id="_toc/tlb-replacement-policy"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#tlb-replacement-policy"><i class="n">12.2. </i>TLB replacement policy</a><span class="hover-metadata"><a href="#_toc/tlb" class="u"> TLB</a><span class="metrics"><span class="wcntr"> 85</span></span></span></span></div></li><li><div id="_toc/cam"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#cam"><i class="n">12.3. </i>CAM</a><span class="hover-metadata"><a href="#_toc/tlb" class="u"> TLB</a><span class="metrics"><span class="wcntr"> 181</span></span></span></span></div></li><li><div id="_toc/invalidating-tlb-entries"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#invalidating-tlb-entries"><i class="n">12.4. </i>Invalidating TLB entries</a><span class="hover-metadata"><a href="#_toc/tlb" class="u"> TLB</a><span class="metrics"><span class="wcntr"> 188</span></span></span></span></div></li></ul><li class="has-child"><div id="_toc/linux-kernel-usage"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#linux-kernel-usage"><i class="n">13. </i>Linux kernel usage</a><span class="hover-metadata"><a href="#_toc" class="u"> x86 Paging Tutorial</a><span class="metrics"><span class="wcntr"> 685</span><span class="dcnt"> 5</span></span></span></span></div><ul><li><div id="_toc/play-with-physical-addresses-in-linux"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#play-with-physical-addresses-in-linux"><i class="n">13.1. </i>Play with physical addresses in Linux</a><span class="hover-metadata"><a href="#_toc/linux-kernel-usage" class="u"> Linux kernel usage</a><span class="metrics"><span class="wcntr"> 40</span></span></span></span></div></li><li><div id="_toc/kernel-vs-process-memory-layout"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#kernel-vs-process-memory-layout"><i class="n">13.2. </i>Kernel vs process memory layout</a><span class="hover-metadata"><a href="#_toc/linux-kernel-usage" class="u"> Linux kernel usage</a><span class="metrics"><span class="wcntr"> 141</span></span></span></span></div></li><li><div id="_toc/process-memory-layout"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#process-memory-layout"><i class="n">13.3. </i>Process memory layout</a><span class="hover-metadata"><a href="#_toc/linux-kernel-usage" class="u"> Linux kernel usage</a><span class="metrics"><span class="wcntr"> 256</span></span></span></span></div></li><li><div id="_toc/copy-on-write"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#copy-on-write"><i class="n">13.4. </i>Copy-on-write</a><span class="hover-metadata"><a href="#_toc/linux-kernel-usage" class="u"> Linux kernel usage</a><span class="metrics"><span class="wcntr"> 120</span></span></span></span></div></li><li><div id="_toc/linux-source-tree"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#linux-source-tree"><i class="n">13.5. </i>Linux source tree</a><span class="hover-metadata"><a href="#_toc/linux-kernel-usage" class="u"> Linux kernel usage</a><span class="metrics"><span class="wcntr"> 74</span></span></span></span></div></li></ul><li><div id="_toc/memory-management-unit"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#memory-management-unit"><i class="n">14. </i>Memory management unit</a><span class="hover-metadata"><a href="#_toc" class="u"> x86 Paging Tutorial</a><span class="metrics"><span class="wcntr"> 45</span></span></span></span></div></li><li><div id="_toc/second-level-address-translation"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#second-level-address-translation"><i class="n">15. </i>Second Level Address Translation</a><span class="hover-metadata"><a href="#_toc" class="u"> x86 Paging Tutorial</a><span class="metrics"><span class="wcntr"> 10</span></span></span></span></div></li><li class="has-child"><div id="_toc/other-architectures"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#other-architectures"><i class="n">16. </i>Other architectures</a><span class="hover-metadata"><a href="#_toc" class="u"> x86 Paging Tutorial</a><span class="metrics"><span class="wcntr"> 57</span><span class="dcnt"> 1</span></span></span></span></div><ul><li><div id="_toc/arm"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#arm"><i class="n">16.1. </i>ARM</a><span class="hover-metadata"><a href="#_toc/other-architectures" class="u"> Other architectures</a><span class="metrics"><span class="wcntr"> 8</span></span></span></span></div></li></ul><li><div id="_toc/bibliography"><div class="arrow"><div></div></div><span class="not-arrow"><a href="#bibliography"><i class="n">17. </i>Bibliography</a><span class="hover-metadata"><a href="#_toc" class="u"> x86 Paging Tutorial</a><span class="metrics"><span class="wcntr"> 35</span></span></span></span></div></li></ul></li></ul></div><div class="h" id="sample-code"><div class="notnav"><h2><a href="x86-paging/sample-code"><span class="number">1. </span>Sample code</a></h2><span class="hover-meta"> <a class="split" href="x86-paging/sample-code"></a><span class="metrics"><span class="wcntr"> Words: 43</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="" class="u"> x86 Paging Tutorial</a><a href="#_toc/sample-code" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/sample-code"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_8">Minimal example: <a href="https://github.com/cirosantilli/x86-bare-metal-examples/blob/5c672f73884a487414b3e21bd9e579c67cd77621/paging.S">github.com/cirosantilli/x86-bare-metal-examples/blob/5c672f73884a487414b3e21bd9e579c67cd77621/paging.S</a></div><div class="p" id="_9">Like everything else in programming, the only way to really understand this is to play with minimal examples.</div><div class="p" id="_10">What makes this a "hard" subject is that the minimal example is large because you need to make your own small <a href="systems-programming#operating-system">OS</a>.</div><div class="h" id="intel-manual"><div class="notnav"><h2><a href="x86-paging/intel-manual"><span class="number">2. </span>Intel manual</a></h2><span class="hover-meta"> <a class="split" href="x86-paging/intel-manual"></a><span class="metrics"><span class="wcntr"> Words: 60</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="" class="u"> x86 Paging Tutorial</a><a href="#_toc/intel-manual" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/intel-manual"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_11">Although it is impossible to understand without examples in mind, try to get familiar with the manuals as soon as possible.</div><div class="p" id="_12">Intel describes paging in the <a href="https://web.archive.org/web/20151025081259/http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-system-programming-manual-325384.pdf">Intel Manual Volume 3 System Programming Guide - 325384-056US September 2015</a> Chapter 4 "Paging".</div><div class="p" id="_13">Specially interesting is Figure 4-4 "Formats of CR3 and Paging-Structure Entries with 32-Bit Paging", which gives the key data structures.</div><div class="h" id="application"><div class="notnav"><h2><a href="x86-paging/application"><span class="number">3. </span>Application</a></h2><span class="hover-meta"> <a class="split" href="x86-paging/application"></a><span class="metrics"><span class="wcntr"> Words: 341</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="" class="u"> x86 Paging Tutorial</a><a href="#_toc/application" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/application"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_14">Paging makes it easier to compile and run two programs or threads at the same time on a single computer.</div><div class="p" id="_15">For example, when you compile two programs, the compiler does not know if they are going to be running at the same time or not.</div><div class="p" id="_16">So nothing prevents it from using the same <a href="computer-hardware#random-access-memory">RAM</a> address, say, <code>0x1234</code>, to store a global variable.</div><div class="p" id="_17">And thread <a href="https://stackoverflow.com/questions/4584089/what-is-the-function-of-the-push-pop-instructions-used-on-registers-in-x86-ass/33583134#33583134">stacks</a>, that must be contiguous and keep growing down until they overwrite each other, are an even bigger issue!</div><div class="p" id="_18">But if two programs use the same address and run at the same time, this is obviously going to break them!</div><div class="p" id="_19">Paging solves this problem beautifully by adding one degree of indirection:</div><div class="code" id="_20"><div><pre><code>(logical) ------------&gt; (physical)
             paging</code></pre></div></div><div class="p" id="_21">Where:<div class="list"><ul id="_22"><li id="_23"><div class="p" id="_24">logical addresses are what userland programs see, e.g. the contents of <code>rsi</code> in <code>mov eax, [rsi]</code>.</div><div class="p" id="_25">They are often called "virtual" addresses as well.</div></li><li id="_26"><div class="p" id="_27">physical addresses can be though of the values that go to physical RAM index wires.</div><div class="p" id="_28">But keep in mind that this is not 100% true because of further indirections such as:</div><div class="list"><ul id="_29"><li id="_30"><a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">memory-mapped I/O regions</a></li><li id="_31"><a href="https://en.wikipedia.org/wiki/Multi-channel_memory_architecture">multi channel memory</a></li></ul></div></li></ul></div></div><div class="p" id="_32"><a href="software#compiler">Compilers</a> don't need to worry about other programs: they just use simple logical addresses.</div><div class="p" id="_33">As far as programs are concerned, they think they can use any address between 0 and 4 GiB (2^32, <code>FFFFFFFF</code>) on 32-bit systems.</div><div class="p" id="_34">The OS then sets up paging so that identical logical addresses will go into different physical addresses and not overwrite each other.</div><div class="p" id="_35">This makes it much simpler to compile programs and run them at the same time.</div><div class="p" id="_36">Paging achieves that goal, and in addition:<div class="list"><ul id="_37"><li id="_38">the switch between programs is very fast, because it is implemented by hardware</li><li id="_39">the memory of both programs can grow and shrink as needed without too much fragmentation</li><li id="_40"><div class="p" id="_41">one program can never access the memory of another program, even if it wanted to.</div><div class="p" id="_42">This is good both for security, and to prevent bugs in one program from crashing other programs.</div></li></ul></div></div><div class="p" id="_43">Or if you like non-funny jokes:</div><div class="figure"><figure id="image-comparison-between-the-linux-kernel-userland-memory-virtualization-and-the-matrix"><div class="float-wrap"><a href="https://upload.wikimedia.org/wikipedia/commons/5/59/Funny_comparison_between_the_Linux_Kernel_and_The_Matrix_due_to_userland_memory_virtualization.png"><img src="https://upload.wikimedia.org/wikipedia/commons/5/59/Funny_comparison_between_the_Linux_Kernel_and_The_Matrix_due_to_userland_memory_virtualization.png" loading="lazy" height="315"></a></div><figcaption><a href="#image-comparison-between-the-linux-kernel-userland-memory-virtualization-and-the-matrix"><span class="caption-prefix">Figure 1. </span></a><div class="title">Comparison between the Linux kernel userland memory virtualization and The Matrix</div>. <a href="https://commons.wikimedia.org/wiki/File:Funny_comparison_between_the_Linux_Kernel_and_The_Matrix_due_to_userland_memory_virtualization.png">Source</a>. Is this RAM real?</figcaption></figure></div><div class="h" id="hardware-implementation"><div class="notnav"><h2><a href="x86-paging/hardware-implementation"><span class="number">4. </span>Hardware implementation</a></h2><span class="hover-meta"> <a class="split" href="x86-paging/hardware-implementation"></a><span class="metrics"><span class="wcntr"> Words: 275</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="" class="u"> x86 Paging Tutorial</a><a href="#_toc/hardware-implementation" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/hardware-implementation"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_44">Paging is implemented by the <a href="computer-hardware#central-processing-unit">CPU</a> hardware itself.</div><div class="p" id="_45">Paging could be implemented in software, but that would be too slow, because every single RAM memory access uses it!</div><div class="p" id="_46">Operating systems must setup and control paging by communicating to the CPU hardware. This is done mostly via:<div class="list"><ul id="_47"><li id="_48">the CR3 register, which tells the CPU where the page table is in RAM memory</li><li id="_49"><div class="p" id="_50">writing the correct paging data structures to the RAM pointed to the CR3 register.</div><div class="p" id="_51">Using RAM data structures is a common technique when lots of data must be transmitted to the CPU as it would cost too much to have such a large CPU register.</div><div class="p" id="_52">The format of the configuration data structures is fixed by the hardware, but it is up to the OS to set up and manage those data structures on RAM correctly, and to tell the hardware where to find them (via <code>cr3</code>).</div><div class="p" id="_53">Then some heavy caching is done to ensure that the RAM access will be fast, in particular using the TLB.</div><div class="p" id="_54">Another notable example of RAM data structure used by the CPU is the <a href="https://en.wikipedia.org/wiki/Interrupt_descriptor_table">IDT</a> which sets up interrupt handlers.</div><div class="p" id="_55">The OS makes it impossible for programs to change the paging setup directly without going through the OS:</div></li><li id="_56">CR3 cannot be modified in ring 3. The OS runs in ring 0. See also:<div class="list"><ul id="_57"><li id="_58"><a href="https://stackoverflow.com/questions/5957570/what-is-the-difference-between-the-kernel-space-and-the-user-space/44285809#44285809">stackoverflow.com/questions/5957570/what-is-the-difference-between-the-kernel-space-and-the-user-space/44285809#44285809</a></li><li id="_59"><a href="https://stackoverflow.com/questions/18717016/what-are-ring-0-and-ring-3-in-os">stackoverflow.com/questions/18717016/what-are-ring-0-and-ring-3-in-os</a></li></ul></div></li><li id="_60">the page table structures are made invisible to the process using paging itself!</li></ul></div></div><div class="p" id="_61">Processes can however make requests to the OS that cause the page tables to be modified, notably:<div class="list"><ul id="_62"><li id="_63">stack size changes</li><li id="_64"><code>brk</code> and <code>mmap</code> calls, see also: <a href="https://stackoverflow.com/questions/6988487/what-does-brk-system-call-do/31082353#31082353">stackoverflow.com/questions/6988487/what-does-brk-system-call-do/31082353#31082353</a></li></ul></div></div><div class="p" id="_65">The kernel then decides if the request will be granted or not in a controlled manner.</div><div class="h" id="segmentation"><div class="notnav"><h2><a href="x86-paging/segmentation"><span class="number">5. </span>Segmentation</a></h2><span class="hover-meta"> <a class="split" href="x86-paging/segmentation"></a><span class="metrics"><span class="wcntr"> Words: 126</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="" class="u"> x86 Paging Tutorial</a><a href="#_toc/segmentation" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/segmentation"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_66">In x86 systems, there may actually be 2 address translation steps:<div class="list"><ul id="_67"><li id="_68">first segmentation</li><li id="_69">then paging</li></ul></div>like this:<div class="code" id="_70"><div><pre><code>(logical) ------------------&gt; (linear) ------------&gt; (physical)
             segmentation                 paging</code></pre></div></div></div><div class="p" id="_71">The major difference between paging and segmentation is that:<div class="list"><ul id="_72"><li id="_73">paging splits RAM into equal sized chunks called pages</li><li id="_74">segmentation splits memory into chunks of arbitrary sizes</li></ul></div></div><div class="p" id="_75">This is the main advantage of paging, since equal sized chunks make things more manageable by reducing memory fragmentation problems. See also:<div class="list"><ul id="_76"><li id="_77"><a href="https://stackoverflow.com/questions/16643180/differences-or-similarities-between-segmented-paging-and-paged-segmentation">stackoverflow.com/questions/16643180/differences-or-similarities-between-segmented-paging-and-paged-segmentation</a></li><li id="_78"><a href="https://softwareengineering.stackexchange.com/questions/100047/why-not-segmentation">softwareengineering.stackexchange.com/questions/100047/why-not-segmentation</a></li><li id="_79"><a href="https://www.quora.com/What-is-the-difference-between-paging-and-segment-in-memory-management">www.quora.com/What-is-the-difference-between-paging-and-segment-in-memory-management</a></li></ul></div></div><div class="p" id="_80">Paging came after segmentation historically, and largely replaced it for the implementation of virtual memory in modern OSs.</div><div class="p" id="_81">Paging has become so much more popular that support for segmentation was dropped in x86-64 in 64-bit mode, the main mode of operation for new software, where it only exists in compatibility mode, which emulates IA-32.</div><div class="h" id="example-simplified-single-level-paging-scheme"><div class="notnav"><h2><a href="x86-paging/example-simplified-single-level-paging-scheme"><span class="number">6. </span>Example: simplified single-level paging scheme</a></h2><span class="hover-meta"> <a class="split" href="x86-paging/example-simplified-single-level-paging-scheme"></a><span class="metrics"><span class="wcntr"> Words: 2k</span><span class="dcnt"> Articles: 7</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="" class="u"> x86 Paging Tutorial</a><a href="#_toc/example-simplified-single-level-paging-scheme" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/example-simplified-single-level-paging-scheme"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_82">This is an example of how paging operates on a simplified version of a x86 architecture to implement a virtual memory space with a <code>20 | 12</code> address split (4 KiB page size).</div><div class="h" id="single-level-paging-scheme-visualization"><div class="notnav"><h3><a href="x86-paging/single-level-paging-scheme-visualization"><span class="number">6.1. </span>Single level paging scheme visualization</a></h3><span class="hover-meta"> <a class="split" href="x86-paging/single-level-paging-scheme-visualization"></a><span class="metrics"><span class="wcntr"> Words: 260</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="#example-simplified-single-level-paging-scheme" class="u"> Example: simplified single-level paging scheme</a><a href="#_toc/single-level-paging-scheme-visualization" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/single-level-paging-scheme-visualization"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_83">This is how the memory could look like in a single level paging scheme:<div class="code" id="_84"><div><pre><code>Links   Data                    Physical address

      +-----------------------+ 2^32 - 1
      |                       |
      .                       .
      |                       |
      +-----------------------+ page0 + 4k
      | data of page 0        |
+----&gt;+-----------------------+ page0
|     |                       |
|     .                       .
|     |                       |
|     +-----------------------+ pageN + 4k
|     | data of page N        |
|  +-&gt;+-----------------------+ pageN
|  |  |                       |
|  |  .                       .
|  |  |                       |
|  |  +-----------------------+ CR3 + 2^20 * 4
|  +--| entry[2^20-1] = pageN |
|     +-----------------------+ CR3 + 2^20 - 1 * 4
|     |                       |
|     .    many entires       .
|     |                       |
|     +-----------------------+ CR3 + 2 * 4
|  +--| entry[1] = page1      |
|  |  +-----------------------+ CR3 + 1 * 4
+-----| entry[0] = page0      |
   |  +-----------------------+ &lt;--- CR3
   |  |                       |
   |  .                       .
   |  |                       |
   |  +-----------------------+ page1 + 4k
   |  | data of page 1        |
   +-&gt;+-----------------------+ page1
      |                       |
      .                       .
      |                       |
      +-----------------------+  0</code></pre></div></div></div><div class="p" id="_85">Notice that:<div class="list"><ul id="_86"><li id="_87">the CR3 register points to the first entry of the page table</li><li id="_88">the page table is just a large array with 2^20 page table entries</li><li id="_89">each entry is 4 bytes big, so the array takes up 4 MiB</li><li id="_90">each page table contains the physical address a page</li><li id="_91">each page is a 4 KiB aligned 4 KiB chunk of memory that user processes may use</li><li id="_92">we have 2^20 table entries. Since each page is 4 KiB == 2^12, this covers the whole 4 GiB (2^32) of 32-bit memory</li></ul></div></div><div class="h" id="single-level-paging-scheme-numerical-translation-example"><div class="notnav"><h3><a href="x86-paging/single-level-paging-scheme-numerical-translation-example"><span class="number">6.2. </span>Single level paging scheme numerical translation example</a></h3><span class="hover-meta"> <a class="split" href="x86-paging/single-level-paging-scheme-numerical-translation-example"></a><span class="metrics"><span class="wcntr"> Words: 563</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="#example-simplified-single-level-paging-scheme" class="u"> Example: simplified single-level paging scheme</a><a href="#_toc/single-level-paging-scheme-numerical-translation-example" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/single-level-paging-scheme-numerical-translation-example"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_93">Suppose that the OS has setup the following page tables for process 1:<div class="code" id="_94"><div><pre><code>entry index   entry address       page address   present
-----------   ------------------  ------------   -------
0             CR3_1 + 0      * 4  0x00001        1
1             CR3_1 + 1      * 4  0x00000        1
2             CR3_1 + 2      * 4  0x00003        1
3             CR3_1 + 3      * 4                 0
...
2^20-1        CR3_1 + 2^20-1 * 4  0x00005        1</code></pre></div></div>and for process 2:<div class="code" id="_95"><div><pre><code>entry index   entry address       page address   present
-----------   -----------------   ------------   -------
0             CR3_2 + 0      * 4  0x0000A        1
1             CR3_2 + 1      * 4  0x12345        1
2             CR3_2 + 2      * 4                 0
3             CR3_2 + 3      * 4  0x00003        1
...
2^20-1        CR3_2 + 2^20-1 * 4  0xFFFFF        1</code></pre></div></div></div><div class="p" id="_96">Before process 1 starts running, the OS sets its <code>cr3</code> to point to the page table 1 at <code>CR3_1</code>.</div><div class="p" id="_97">When process 1 tries to access a linear address, this is the physical addresses that will be actually accessed:<div class="code" id="_98"><div><pre><code>linear     physical
---------  ---------
00000 001  00001 001
00000 002  00001 002
00000 003  00001 003
00000 FFF  00001 FFF
00001 000  00000 000
00001 001  00000 001
00001 FFF  00000 FFF
00002 000  00003 000
FFFFF 000  00005 000</code></pre></div></div></div><div class="p" id="_99">To switch to process 2, the OS simply sets <code>cr3</code> to <code>CR3_2</code>, and now the following translations would happen:<div class="code" id="_100"><div><pre><code>linear     physical
---------  ---------
00000 002  0000A 002
00000 003  0000A 003
00000 FFF  0000A FFF
00001 000  12345 000
00001 001  12345 001
00001 FFF  12345 FFF
00004 000  00003 000
FFFFF 000  FFFFF 000</code></pre></div></div></div><div class="p" id="_101">Step-by-step translation for process 1 of logical address <code>0x00000001</code> to physical address <code>0x00001001</code>:<div class="list"><ul id="_102"><li id="_103"><div class="p" id="_104">split the linear address into two parts:</div><div class="code" id="_105"><div><pre><code>| page (20 bits) | offset (12 bits) |</code></pre></div></div><div class="p" id="_106">So in this case we would have:<br>*page = 0x00000. This part must be translated to a physical location.<br>*offset = 0x001. This part is added directly to the page address, and is not translated: it contains the position within the page.</div></li><li id="_107">look into Page table 1 because <code>cr3</code> points to it.</li><li id="_108">The hardware knows that this entry is located at RAM address <code>CR3 + 0x00000 * 4 = CR3</code>:<br>*<code>0x00000</code> because the page part of the logical address is <code>0x00000</code><br>*<code>4</code> because that is the fixed size in bytes of every page table entry</li><li id="_109">since it is present, the access is valid</li><li id="_110">by the page table, the location of page number <code>0x00000</code> is at <code>0x00001 * 4K = 0x00001000</code>.</li><li id="_111"><div class="p" id="_112">to find the final physical address we just need to add the offset:</div><div class="code" id="_113"><div><pre><code>  00001 000
+ 00000 001
  ---------
  00001 001</code></pre></div></div><div class="p" id="_114">because <code>00001</code> is the physical address of the page looked up on the table and <code>001</code> is the offset.</div><div class="p" id="_115">We shift <code>00001</code> by 12 bits because the pages are always aligned to 4 KiB.</div><div class="p" id="_116">The offset is always simply added the physical address of the page.</div></li><li id="_117">the hardware then gets the memory at that physical location and puts it in a register.</li></ul></div></div><div class="p" id="_118">Another example: for logical address <code>0x00001001</code>:<div class="list"><ul id="_119"><li id="_120">the page part is <code>00001</code>, and the offset part is <code>001</code></li><li id="_121">the hardware knows that its page table entry is located at RAM address: <code>CR3 + 1 * 4</code> (<code>1</code> because of the page part), and that is where it will look for it</li><li id="_122">it finds the page address <code>0x00000</code> there</li><li id="_123">so the final address is <code>0x00000 * 4k + 0x001 = 0x00000001</code></li></ul></div></div><div class="h" id="multiple-addresses-translate-to-a-single-physical-address"><div class="notnav"><h3><a href="x86-paging/multiple-addresses-translate-to-a-single-physical-address"><span class="number">6.3. </span>Multiple addresses translate to a single physical address</a></h3><span class="hover-meta"> <a class="split" href="x86-paging/multiple-addresses-translate-to-a-single-physical-address"></a><span class="metrics"><span class="wcntr"> Words: 82</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="#example-simplified-single-level-paging-scheme" class="u"> Example: simplified single-level paging scheme</a><a href="#_toc/multiple-addresses-translate-to-a-single-physical-address" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/multiple-addresses-translate-to-a-single-physical-address"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_124">The same linear address can translate to different physical addresses for different processes, depending only on the value inside <code>cr3</code>.</div><div class="p" id="_125">Both linear addresses <code>00002 000</code> from process 1 and <code>00004 000</code> from process 2 point to the same physical address <code>00003 000</code>. This is completely allowed by the hardware, and it is up to the operating system to handle such cases.</div><div class="p" id="_126">This often in normal operation because of Copy-on-write (COW), which be explained elsewhere.</div><div class="p" id="_127">Such mappings are sometime called "aliases".</div><div class="h" id="identity-mapping"><div class="notnav"><h3><a href="x86-paging/identity-mapping"><span class="number">6.4. </span>Identity mapping</a></h3><span class="hover-meta"> <a class="split" href="x86-paging/identity-mapping"></a><span class="metrics"><span class="wcntr"> Words: 28</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="#example-simplified-single-level-paging-scheme" class="u"> Example: simplified single-level paging scheme</a><a href="#_toc/identity-mapping" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/identity-mapping"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_128"><code>FFFFF 000</code> points to its own physical address <code>FFFFF 000</code>. This kind of translation is called an "identity mapping", and can be very convenient for OS-level debugging.</div><div class="h" id="page-faults"><div class="notnav"><h3><a href="x86-paging/page-faults"><span class="number">6.5. </span>Page faults</a></h3><span class="hover-meta"> <a class="split" href="x86-paging/page-faults"></a><span class="metrics"><span class="wcntr"> Words: 300</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="#example-simplified-single-level-paging-scheme" class="u"> Example: simplified single-level paging scheme</a><a href="#_toc/page-faults" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/page-faults"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_129">What if Process 1 tries to access <code>0x00003000</code>, which is not present?</div><div class="p" id="_130">The hardware notifies the software via a Page Fault Exception.</div><div class="p" id="_131">When an exception happens, the CPU jumps to an address that the OS had previously registered as the fault handler. This is usually done at boot time by the OS.</div><div class="p" id="_132">This could happen for example due to a programming error:<div class="code" id="_133"><div><pre><code>int *is = malloc(1);
is[2] = 1;</code></pre></div></div>but there are cases where it is not a bug, for example in Linux when:<div class="list"><ul id="_134"><li id="_135"><div class="p" id="_136">the program wants to increase its stack.</div><div class="p" id="_137">It just tries to accesses a certain byte in a given possible range, and if the OS is happy it adds that page to the process address space, otherwise, it sends a signal to the process.</div></li><li id="_138"><div class="p" id="_139">the page was swapped to disk.</div><div class="p" id="_140">The OS will need to do some work behind the processes back to get the page back into RAM.</div><div class="p" id="_141">The OS can discover that this is the case based on the contents of the rest of the page table entry, since if the present flag is clear, the other entries of the page table entry are completely left for the OS to to what it wants.</div><div class="p" id="_142">On Linux for example, when present = 0:<div class="list"><ul id="_143"><li id="_144">if all the fields of the page table entry are 0, invalid address.</li><li id="_145">else, the page has been swapped to disk, and the actual values of those fields encode the position of the page on the disk.</li></ul></div></div></li></ul></div></div><div class="p" id="_146">In any case, the OS needs to know which address generated the Page Fault to be able to deal with the problem. This is why the nice IA32 developers set the value of <code>cr2</code> to that address whenever a Page Fault occurs. The exception handler can then just look into <code>cr2</code> to get the address.</div><div class="h" id="page-table-entries"><div class="notnav"><h3><a href="x86-paging/page-table-entries"><span class="number">6.6. </span>Page table entries</a></h3><span class="hover-meta"> <a class="split" href="x86-paging/page-table-entries"></a><span class="metrics"><span class="wcntr"> Words: 211</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="#example-simplified-single-level-paging-scheme" class="u"> Example: simplified single-level paging scheme</a><a href="#_toc/page-table-entries" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/page-table-entries"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_147">The exact format of table entries is fixed by the hardware.</div><div class="p" id="_148">Each page entry can be seen as a <code>struct</code> with many fields.</div><div class="p" id="_149">The page table is then an array of <code>struct</code>.</div><div class="p" id="_150">On this simplified example, the page table entries contain only two fields:<div class="code" id="_151"><div><pre><code>bits   function
-----  -----------------------------------------
20     physical address of the start of the page
1      present flag</code></pre></div></div>so in this example the hardware designers could have chosen the size of the page table to b <code>21</code> instead of <code>32</code> as we've used so far.</div><div class="p" id="_152">All real page table entries have other fields, notably fields to set pages to read-only for Copy-on-write. This will be explained elsewhere.</div><div class="p" id="_153">It would be impractical to align things at 21 bits since memory is addressable by bytes and not bits. Therefore, even in only 21 bits are needed in this case, hardware designers would probably choose 32 to make access faster, and just reserve bits the remaining bits for later usage. The actual value on x86 is 32 bits.</div><div class="p" id="_154">Here is a screenshot from the Intel manual image "Formats of CR3 and Paging-Structure Entries with 32-Bit Paging" showing the structure of a page table in all its glory: <a href="#image-x86-page-entry-format">Figure 2. "x86 page entry format"</a>.</div><div class="figure"><figure id="image-x86-page-entry-format"><div class="float-wrap"><a href="https://raw.githubusercontent.com/cirosantilli/media/master/x86_page_entry_format.png"><img src="https://raw.githubusercontent.com/cirosantilli/media/master/x86_page_entry_format.png" loading="lazy" height="300"></a></div><figcaption><a href="#image-x86-page-entry-format"><span class="caption-prefix">Figure 2. </span></a><div class="title">x86 page entry format</div>. </figcaption></figure></div><div class="p" id="_155">The fields are explained in the manual just after.</div><div class="h" id="page-size-choice"><div class="notnav"><h3><a href="x86-paging/page-size-choice"><span class="number">6.7. </span>Page size choice</a></h3><span class="hover-meta"> <a class="split" href="x86-paging/page-size-choice"></a><span class="metrics"><span class="wcntr"> Words: 118</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="#example-simplified-single-level-paging-scheme" class="u"> Example: simplified single-level paging scheme</a><a href="#_toc/page-size-choice" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/page-size-choice"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_156">Why are pages 4 KiB anyways?</div><div class="p" id="_157">There is a trade-off between memory wasted in:<div class="list"><ul id="_158"><li id="_159">page tables</li><li id="_160">extra padding memory within pages</li></ul></div></div><div class="p" id="_161">This can be seen with the extreme cases:<div class="list"><ul id="_162"><li id="_163">if the page size were 1 byte:<div class="list"><ul id="_164"><li id="_165">granularity would be great, and the OS would never have to allocate unneeded padding memory</li><li id="_166">but the page table would have 2^32 entries, and take up the entire memory!</li></ul></div></li><li id="_167">if the page size were 4 GiB:<div class="list"><ul id="_168"><li id="_169">we would need to swap 4 GiB to disk every time a new process becomes active</li><li id="_170">the page size would be a single entry, so it would take almost no memory at all</li></ul></div></li></ul></div></div><div class="p" id="_171">x86 designers have found that 4 KiB pages are a good middle ground.</div><div class="h" id="example-multi-level-paging-scheme"><div class="notnav"><h2><a href="x86-paging/example-multi-level-paging-scheme"><span class="number">7. </span>Example: multi-level paging scheme</a></h2><span class="hover-meta"> <a class="split" href="x86-paging/example-multi-level-paging-scheme"></a><span class="metrics"><span class="wcntr"> Words: 1k</span><span class="dcnt"> Articles: 5</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="" class="u"> x86 Paging Tutorial</a><a href="#_toc/example-multi-level-paging-scheme" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/example-multi-level-paging-scheme"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="h" id="the-problem-with-single-level-paging"><div class="notnav"><h3><a href="x86-paging/the-problem-with-single-level-paging"><span class="number">7.1. </span>The problem with single-level paging</a></h3><span class="hover-meta"> <a class="split" href="x86-paging/the-problem-with-single-level-paging"></a><span class="metrics"><span class="wcntr"> Words: 109</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="#example-multi-level-paging-scheme" class="u"> Example: multi-level paging scheme</a><a href="#_toc/the-problem-with-single-level-paging" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/the-problem-with-single-level-paging"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_172">The problem with a single-level paging scheme is that it would take up too much RAM: 4G / 4K = 1M entries per process.</div><div class="p" id="_173">If each entry is 4 bytes long, that would make 4M per process, which is too much even for a desktop computer: <code>ps -A | wc -l</code> says that I am running 244 processes right now, so that would take around 1GB of my RAM!</div><div class="p" id="_174">For this reason, x86 developers decided to use a multi-level scheme that reduces RAM usage.</div><div class="p" id="_175">The downside of this system is that is has a slightly higher access time, as we need to access RAM more times for each translation.</div><div class="h" id="k-ary-trees-to-the-rescue"><div class="notnav"><h3><a href="x86-paging/k-ary-trees-to-the-rescue"><span class="number">7.2. </span>K-ary trees to the rescue</a></h3><span class="hover-meta"> <a class="split" href="x86-paging/k-ary-trees-to-the-rescue"></a><span class="metrics"><span class="wcntr"> Words: 309</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="#example-multi-level-paging-scheme" class="u"> Example: multi-level paging scheme</a><a href="#_toc/k-ary-trees-to-the-rescue" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/k-ary-trees-to-the-rescue"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_176">The algorithmically minded will have noticed that paging requires <a href="computer-science#associative-array">associative array</a> (like Java <code>Map</code> of Python <code>dict()</code>) abstract data structure where:<div class="list"><ul id="_177"><li id="_178">the keys are linear pages addresses, thus of integer type</li><li id="_179">the values are physical page addresses, also of integer type</li></ul></div></div><div class="p" id="_180">The single level paging scheme uses a simple array implementation of the associative array:<div class="list"><ul id="_181"><li id="_182">the keys are the array index</li><li id="_183">this implementation is very fast in time</li><li id="_184">but it is too inefficient in memory</li></ul></div>and in C pseudo-code it looks like this:<div class="code" id="_185"><div><pre><code>linear_address[0]      = physical_address_0
linear_address[1]      = physical_address_1
linear_address[2]      = physical_address_2
...
linear_address[2^20-1] = physical_address_N</code></pre></div></div></div><div class="p" id="_186">But there another simple associative array implementation that overcomes the memory problem: an (unbalanced) <a href="mathematics#k-ary-tree">k-ary tree</a>.</div><div class="p" id="_187">A K-ary tree, is just like a <a href="mathematics#binary-tree">binary tree</a>, but with K children instead of 2.</div><div class="p" id="_188">Using a K-ary tree instead of an array implementation has the following trade-offs:<div class="list"><ul id="_189"><li id="_190">it uses way less memory</li><li id="_191">it is slower since we have to de-reference extra pointers</li></ul></div></div><div class="p" id="_192">In C-pseudo code, a 2-level K-ary tree with <code>K = 2^10</code> looks like this:<div class="code" id="_193"><div><pre><code>level0[0] = &amp;level1_0[0]
    level1_0[0]      = physical_address_0_0
    level1_0[1]      = physical_address_0_1
    ...
    level1_0[2^10-1] = physical_address_0_N
level0[1] = &amp;level1_1[0]
    level1_1[0]      = physical_address_1_0
    level1_1[1]      = physical_address_1_1
    ...
    level1_1[2^10-1] = physical_address_1_N
...
level0[N] = &amp;level1_N[0]
    level1_N[0]      = physical_address_N_0
    level1_N[1]      = physical_address_N_1
    ...
    level1_N[2^10-1] = physical_address_N_N</code></pre></div></div>and we have the following arrays:<div class="list"><ul id="_194"><li id="_195">one <code>directory</code>, which has <code>2^10</code> elements. Each element contains a pointer to a page table array.</li><li id="_196">up to 2^10 <code>pagetable</code> arrays. Each one has <code>2^10</code> 4 byte page entries.</li></ul></div>and it still contains <code>2^10 * 2^10 = 2^20</code> possible keys.</div><div class="p" id="_197">K-ary trees can save up a lot of space, because if we only have one key, then we only need the following arrays:<div class="list"><ul id="_198"><li id="_199">one <code>directory</code> with 2^10 entries</li><li id="_200">one <code>pagetable</code> at <code>directory[0]</code> with 2^10 entries</li><li id="_201">all other <code>directory[i]</code> are marked as invalid, don't point to anything, and we don't allocate <code>pagetable</code> for them at all</li></ul></div></div><div class="h" id="why-not-a-balanced-tree"><div class="notnav"><h3><a href="x86-paging/why-not-a-balanced-tree"><span class="number">7.3. </span>Why not a balanced tree</a></h3><span class="hover-meta"> <a class="split" href="x86-paging/why-not-a-balanced-tree"></a><span class="metrics"><span class="wcntr"> Words: 65</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="#example-multi-level-paging-scheme" class="u"> Example: multi-level paging scheme</a><a href="#_toc/why-not-a-balanced-tree" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/why-not-a-balanced-tree"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_202">Learned readers will ask themselves: so why use an unbalanced tree instead of balanced one, which offers better asymptotic times <a href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree?">en.wikipedia.org/wiki/Self-balancing_binary_search_tree?</a></div><div class="p" id="_203">Likely:<div class="list"><ul id="_204"><li id="_205">the maximum number of entries is small enough due to memory size limitations, that we won't waste too much memory with the root directory entry</li><li id="_206">different entries would have different levels, and thus different access times</li><li id="_207">tree rotations would likely make caching more complicated</li></ul></div></div><div class="h" id="how-the-k-ary-tree-is-used-in-x86"><div class="notnav"><h3><a href="x86-paging/how-the-k-ary-tree-is-used-in-x86"><span class="number">7.4. </span>How the K-ary tree is used in x86</a></h3><span class="hover-meta"> <a class="split" href="x86-paging/how-the-k-ary-tree-is-used-in-x86"></a><span class="metrics"><span class="wcntr"> Words: 352</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="#example-multi-level-paging-scheme" class="u"> Example: multi-level paging scheme</a><a href="#_toc/how-the-k-ary-tree-is-used-in-x86" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/how-the-k-ary-tree-is-used-in-x86"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_208">x86's multi-level paging scheme uses a 2 level K-ary tree with 2^10 bits on each level.</div><div class="p" id="_209">Addresses are now split as:<div class="code" id="_210"><div><pre><code>| directory (10 bits) | table (10 bits) | offset (12 bits) |</code></pre></div></div></div><div class="p" id="_211">Then:<div class="list"><ul id="_212"><li id="_213"><div class="p" id="_214">the top 10 bits are used to walk the top level of the K-ary tree (<code>level0</code>)</div><div class="p" id="_215">The top table is called a "directory of page tables".</div><div class="p" id="_216"><code>cr3</code> now points to the location on RAM of the page directory of the current process instead of page tables.</div><div class="p" id="_217">Page directory entries are very similar to page table entries except that they point to the physical addresses of page tables instead of physical addresses of pages.</div><div class="p" id="_218">Each directory entry also takes up 4 bytes, just like page entries, so that makes 4 KiB per process minimum.</div><div class="p" id="_219">Page directory entries also contain a valid flag: if invalid, the OS does not allocate a page table for that entry, and saves memory.</div><div class="p" id="_220">Each process has one and only one page directory associated to it (and pointed to by <code>cr3</code>), so it will contain at least <code>2^10 = 1K</code> page directory entries, much better than the minimum 1M entries required on a single-level scheme.</div></li><li id="_221"><div class="p" id="_222">the next 10 bits are used to walk the second level of the K-ary tree (<code>level1</code>)</div><div class="p" id="_223">Second level entries are also called page tables like the single level scheme.</div><div class="p" id="_224">Page tables are only allocated only as needed by the OS.</div><div class="p" id="_225">Each page table has only <code>2^10 = 1K</code> page table entries instead of <code>2^20</code> for the single paging scheme.</div><div class="p" id="_226">Each process can now have up to <code>2^10</code> page tables instead of <code>2^20</code> for the single paging scheme.</div></li><li id="_227">the offset is again not used for translation, it only gives the offset within a page</li></ul></div></div><div class="p" id="_228">One reason for using 10 bits on the first two levels (and not, say, <code>12 | 8 | 12</code> ) is that each Page Table entry is 4 bytes long. Then the 2^10 entries of Page directories and Page Tables will fit nicely into 4Kb pages. This means that it faster and simpler to allocate and deallocate pages for that purpose.</div><div class="h" id="multi-level-paging-scheme-numerical-translation-example"><div class="notnav"><h3><a href="x86-paging/multi-level-paging-scheme-numerical-translation-example"><span class="number">7.5. </span>Multi-level paging scheme numerical translation example</a></h3><span class="hover-meta"> <a class="split" href="x86-paging/multi-level-paging-scheme-numerical-translation-example"></a><span class="metrics"><span class="wcntr"> Words: 460</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="#example-multi-level-paging-scheme" class="u"> Example: multi-level paging scheme</a><a href="#_toc/multi-level-paging-scheme-numerical-translation-example" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/multi-level-paging-scheme-numerical-translation-example"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_229">Page directory given to process by the OS:<div class="code" id="_230"><div><pre><code>entry index   entry address      page table address  present
-----------   ----------------   ------------------  --------
0             CR3 + 0      * 4   0x10000             1
1             CR3 + 1      * 4                       0
2             CR3 + 2      * 4   0x80000             1
3             CR3 + 3      * 4                       0
...
2^10-1        CR3 + 2^10-1 * 4                       0</code></pre></div></div></div><div class="p" id="_231">Page tables given to process by the OS at <code>PT1 = 0x10000000</code> (<code>0x10000</code> * 4K):<div class="code" id="_232"><div><pre><code>entry index   entry address      page address  present
-----------   ----------------   ------------  -------
0             PT1 + 0      * 4   0x00001       1
1             PT1 + 1      * 4                 0
2             PT1 + 2      * 4   0x0000D       1
...                                  ...
2^10-1        PT1 + 2^10-1 * 4   0x00005       1</code></pre></div></div></div><div class="p" id="_233">Page tables given to process by the OS at <code>PT2  = 0x80000000</code> (<code>0x80000</code> * 4K):<div class="code" id="_234"><div><pre><code>entry index   entry address     page address  present
-----------   ---------------   ------------  ------------
0             PT2 + 0     * 4   0x0000A       1
1             PT2 + 1     * 4   0x0000C       1
2             PT2 + 2     * 4                 0
...
2^10-1        PT2 + 0x3FF * 4   0x00003       1</code></pre></div></div>where <code>PT1</code> and <code>PT2</code>: initial position of page table 1 and page table 2 for process 1 on RAM.</div><div class="p" id="_235">With that setup, the following translations would happen:<div class="code" id="_236"><div><pre><code>linear    10 10 12 split  physical
--------  --------------  ----------
00000001  000 000 001     00001001
00001001  000 001 001     page fault
003FF001  000 3FF 001     00005001
00400000  001 000 000     page fault
00800001  002 000 001     0000A001
00801004  002 001 004     0000C004
00802004  002 002 004     page fault
00B00001  003 000 000     page fault</code></pre></div></div></div><div class="p" id="_237">Let's translate the linear address <code>0x00801004</code> step by step:<div class="list"><ul id="_238"><li id="_239">In binary the linear address is:<div class="code" id="_240"><div><pre><code>0    0    8    0    1    0    0    4
0000 0000 1000 0000 0001 0000 0000 0100</code></pre></div></div></li><li id="_241">Grouping as <code>10 | 10 | 12</code> gives:<div class="code" id="_242"><div><pre><code>0000000010 0000000001 000000000100
0x2        0x1        0x4</code></pre></div></div>which gives:<div class="code" id="_243"><div><pre><code>page directory entry = 0x2
page table     entry = 0x1
offset               = 0x4</code></pre></div></div>So the hardware looks for entry 2 of the page directory.</li><li id="_244"><div class="p" id="_245">The page directory table says that the page table is located at <code>0x80000 * 4K = 0x80000000</code>. This is the first RAM access of the process.</div><div class="p" id="_246">Since the page table entry is <code>0x1</code>, the hardware looks at entry 1 of the page table at <code>0x80000000</code>, which tells it that the physical page is located at address <code>0x0000C * 4K = 0x0000C000</code>. This is the second RAM access of the process.</div></li><li id="_247">Finally, the paging hardware adds the offset, and the final address is <code>0x0000C004</code>.</li></ul></div></div><div class="p" id="_248">Page faults occur if either a page directory entry or a page table entry is not present.</div><div class="p" id="_249">The Intel manual gives a picture of this translation process in the image "Linear-Address Translation to a 4-KByte Page using 32-Bit Paging": <a href="#image-x86-page-translation-process">Figure 3. "x86 page translation process"</a></div><div class="figure"><figure id="image-x86-page-translation-process"><div class="float-wrap"><a href="https://raw.githubusercontent.com/cirosantilli/media/master/x86_page_translation_process.png"><img src="https://raw.githubusercontent.com/cirosantilli/media/master/x86_page_translation_process.png" loading="lazy" height="300"></a></div><figcaption><a href="#image-x86-page-translation-process"><span class="caption-prefix">Figure 3. </span></a><div class="title">x86 page translation process</div>. </figcaption></figure></div><div class="h" id="64-bit-architectures"><div class="notnav"><h2><a href="x86-paging/64-bit-architectures"><span class="number">8. </span>64-bit architectures</a></h2><span class="hover-meta"> <a class="split" href="x86-paging/64-bit-architectures"></a><span class="metrics"><span class="wcntr"> Words: 182</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="" class="u"> x86 Paging Tutorial</a><a href="#_toc/64-bit-architectures" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/64-bit-architectures"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_250">64 bits is still too much address for current RAM sizes, so most architectures will use less bits.</div><div class="p" id="_251">x86_64 uses 48 bits (256 TiB), and legacy mode's PAE already allows 52-bit addresses (4 PiB). 56-bits is a likely future candidate.</div><div class="p" id="_252">12 of those 48 bits are already reserved for the offset, which leaves 36 bits.</div><div class="p" id="_253">If a 2 level approach is taken, the best split would be two 18 bit levels.</div><div class="p" id="_254">But that would mean that the page directory would have <code>2^18 = 256K</code> entries, which would take too much RAM: close to a single-level paging for 32 bit architectures!</div><div class="p" id="_255">Therefore, 64 bit architectures create even further page levels, commonly 3 or 4.</div><div class="p" id="_256">x86_64 uses 4 levels in a <code>9 | 9 | 9 | 9</code> scheme, so that the upper level only takes up only <code>2^9</code> higher level entries.</div><div class="p" id="_257">The 48 bits are split equally into two disjoint parts:<div class="code" id="_258"><div><pre><code>----------------- FFFFFFFF FFFFFFFF
Top half
----------------- FFFF8000 00000000


Not addressable


----------------- 00007FFF FFFFFFFF
Bottom half
----------------- 00000000 00000000</code></pre></div></div></div><div class="p" id="_259">A 5-level scheme is emerging in 2016: <a href="https://software.intel.com/sites/default/files/managed/2b/80/5-level_paging_white_paper.pdf">software.intel.com/sites/default/files/managed/2b/80/5-level_paging_white_paper.pdf</a> which allows 52-bit addresses with 4k pagetables.</div><div class="h" id="pae"><div class="notnav"><h2><a href="x86-paging/pae"><span class="number">9. </span>PAE</a></h2><span class="hover-meta"> <a class="split" href="x86-paging/pae"></a><span class="metrics"><span class="wcntr"> Words: 114</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="" class="u"> x86 Paging Tutorial</a><a href="#_toc/pae" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/pae"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_260">Physical address extension.</div><div class="p" id="_261">With 32 bits, only 4GB RAM can be addressed.</div><div class="p" id="_262">This started becoming a limitation for large servers, so Intel introduced the PAE mechanism to Pentium Pro.</div><div class="p" id="_263">To relieve the problem, Intel added 4 new address lines, so that 64GB could be addressed.</div><div class="p" id="_264">Page table structure is also altered if PAE is on. The exact way in which it is altered depends on weather PSE is on or off.</div><div class="p" id="_265">PAE is turned on and off via the <code>PAE</code> bit of <code>cr4</code>.</div><div class="p" id="_266">Even if the total addressable memory is 64GB, individual process are still only able to use up to 4GB. The OS can however put different processes on different 4GB chunks.</div><div class="h" id="pse"><div class="notnav"><h2><a href="x86-paging/pse"><span class="number">10. </span>PSE</a></h2><span class="hover-meta"> <a class="split" href="x86-paging/pse"></a><span class="metrics"><span class="wcntr"> Words: 33</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="" class="u"> x86 Paging Tutorial</a><a href="#_toc/pse" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/pse"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_267">Page size extension.</div><div class="p" id="_268">Allows for pages to be 4M (or 2M if PAE is on) in length instead of 4K.</div><div class="p" id="_269">PSE is turned on and off via the <code>PSE</code> bit of <code>cr4</code>.</div><div class="h" id="pae-and-pse-page-table-schemes"><div class="notnav"><h2><a href="x86-paging/pae-and-pse-page-table-schemes"><span class="number">11. </span>PAE and PSE page table schemes</a></h2><span class="hover-meta"> <a class="split" href="x86-paging/pae-and-pse-page-table-schemes"></a><span class="metrics"><span class="wcntr"> Words: 300</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="" class="u"> x86 Paging Tutorial</a><a href="#_toc/pae-and-pse-page-table-schemes" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/pae-and-pse-page-table-schemes"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_270">If either PAE and PSE are active, different paging level schemes are used:<div class="list"><ul id="_271"><li id="_272">no PAE and no PSE: <code>10 | 10 | 12</code></li><li id="_273"><div class="p" id="_274">no PAE and PSE: <code>10 | 22</code>.</div><div class="p" id="_275">22 is the offset within the 4Mb page, since 22 bits address 4Mb.</div></li><li id="_276"><div class="p" id="_277">PAE and no PSE: <code>2 | 9 | 9 | 12</code></div><div class="p" id="_278">The design reason why 9 is used twice instead of 10 is that now entries cannot fit anymore into 32 bits, which were all filled up by 20 address bits and 12 meaningful or reserved flag bits.</div><div class="p" id="_279">The reason is that 20 bits are not enough anymore to represent the address of page tables: 24 bits are now needed because of the 4 extra wires added to the processor.</div><div class="p" id="_280">Therefore, the designers decided to increase entry size to 64 bits, and to make them fit into a single page table it is necessary reduce the number of entries to 2^9 instead of 2^10.</div><div class="p" id="_281">The starting 2 is a new Page level called Page Directory Pointer Table (PDPT), since it points to page directories and fill in the 32 bit linear address. PDPTs are also 64 bits wide.</div><div class="p" id="_282"><code>cr3</code> now points to PDPTs which must be on the fist four 4GB of memory and aligned on 32 bit multiples for addressing efficiency. This means that now <code>cr3</code> has 27 significative bits instead of 20: 2^5 for the 32 multiples * 2^27 to complete the 2^32 of the first 4GB.</div></li><li id="_283"><div class="p" id="_284">PAE and PSE: <code>2 | 9 | 21</code></div><div class="p" id="_285">Designers decided to keep a 9 bit wide field to make it fit into a single page.</div><div class="p" id="_286">This leaves 23 bits. Leaving 2 for the PDPT to keep things uniform with the PAE case without PSE leaves 21 for offset, meaning that pages are 2M wide instead of 4M.</div></li></ul></div></div><div class="h" id="tlb"><div class="notnav"><h2><a href="x86-paging/tlb"><span class="number">12. </span>TLB</a></h2><span class="hover-meta"> <a class="split" href="x86-paging/tlb"></a><span class="metrics"><span class="wcntr"> Words: 677</span><span class="dcnt"> Articles: 4</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="" class="u"> x86 Paging Tutorial</a><a href="#_toc/tlb" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/tlb"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_287">The Translation Lookahead Buffer (TLB) is a cache for paging addresses.</div><div class="p" id="_288">Since it is a cache, it shares many of the design issues of the CPU cache, such as associativity level.</div><div class="p" id="_289">This section shall describe a simplified fully associative TLB with 4 single address entries. Note that like other caches, real TLBs are not usually fully associative.</div><div class="h" id="basic-tlb-operation"><div class="notnav"><h3><a href="x86-paging/basic-tlb-operation"><span class="number">12.1. </span>Basic TLB operation</a></h3><span class="hover-meta"> <a class="split" href="x86-paging/basic-tlb-operation"></a><span class="metrics"><span class="wcntr"> Words: 166</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="#tlb" class="u"> TLB</a><a href="#_toc/basic-tlb-operation" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/basic-tlb-operation"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_290">After a translation between linear and physical address happens, it is stored on the TLB. For example, a 4 entry TLB starts in the following state:<div class="code" id="_291"><div><pre><code>  valid  linear  physical
  -----  ------  --------
&gt; 0      00000   00000
  0      00000   00000
  0      00000   00000
  0      00000   00000</code></pre></div></div></div><div class="p" id="_292">The <code>&gt;</code> indicates the current entry to be replaced.</div><div class="p" id="_293">And after a page linear address <code>00003</code> is translated to a physical address <code>00005</code>, the TLB becomes:<div class="code" id="_294"><div><pre><code>  valid  linear  physical
  -----  ------  --------
  1      00003   00005
&gt; 0      00000   00000
  0      00000   00000
  0      00000   00000</code></pre></div></div>and after a second translation of <code>00007</code> to <code>00009</code> it becomes:<div class="code" id="_295"><div><pre><code>  valid  linear  physical
  -----  ------  --------
  1      00003   00005
  1      00007   00009
&gt; 0      00000   00000
  0      00000   00000</code></pre></div></div></div><div class="p" id="_296">Now if <code>00003</code> needs to be translated again, hardware first looks up the TLB and finds out its address with a single RAM access <code>00003 --&gt; 00005</code>.</div><div class="p" id="_297">Of course, <code>00000</code> is not on the TLB since no valid entry contains <code>00000</code> as a key.</div><div class="h" id="tlb-replacement-policy"><div class="notnav"><h3><a href="x86-paging/tlb-replacement-policy"><span class="number">12.2. </span>TLB replacement policy</a></h3><span class="hover-meta"> <a class="split" href="x86-paging/tlb-replacement-policy"></a><span class="metrics"><span class="wcntr"> Words: 85</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="#tlb" class="u"> TLB</a><a href="#_toc/tlb-replacement-policy" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/tlb-replacement-policy"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_298">When TLB is filled up, older addresses are overwritten. Just like CPU cache, the replacement policy is a potentially complex operation, but a simple and reasonable heuristic is to remove the least recently used entry (LRU).</div><div class="p" id="_299">With LRU, starting from state:<div class="code" id="_300"><div><pre><code>  valid  linear  physical
  -----  ------  --------
&gt; 1      00003   00005
  1      00007   00009
  1      00009   00001
  1      0000B   00003</code></pre></div></div>adding <code>0000D -&gt; 0000A</code> would give:<div class="code" id="_301"><div><pre><code>  valid  linear  physical
  -----  ------  --------
  1      0000D   0000A
&gt; 1      00007   00009
  1      00009   00001
  1      0000B   00003</code></pre></div></div></div><div class="h" id="cam"><div class="notnav"><h3><a href="x86-paging/cam"><span class="number">12.3. </span>CAM</a></h3><span class="hover-meta"> <a class="split" href="x86-paging/cam"></a><span class="metrics"><span class="wcntr"> Words: 181</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="#tlb" class="u"> TLB</a><a href="#_toc/cam" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/cam"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_302">Using the TLB makes translation faster, because the initial translation takes one access per TLB level, which means 2 on a simple 32 bit scheme, but 3 or 4 on 64 bit architectures.</div><div class="p" id="_303">The TLB is usually implemented as an expensive type of RAM called content-addressable memory (CAM). CAM implements an associative map on hardware, that is, a structure that given a key (linear address), retrieves a value.</div><div class="p" id="_304">Mappings could also be implemented on RAM addresses, but CAM mappings may required much less entries than a RAM mapping.</div><div class="p" id="_305">For example, a map in which:<div class="list"><ul id="_306"><li id="_307">both keys and values have 20 bits (the case of a simple paging schemes)</li><li id="_308">at most 4 values need to be stored at each time</li></ul></div>could be stored in a TLB with 4 entries:</div><div class="code" id="_309"><div><pre><code>linear  physical
------  --------
00000   00001
00001   00010
00010   00011
FFFFF   00000</code></pre></div></div><div class="p" id="_310">However, to implement this with RAM, it would be necessary to have 2^20 addresses:<div class="code" id="_311"><div><pre><code>linear  physical
------  --------
00000   00001
00001   00010
00010   00011
... (from 00011 to FFFFE)
FFFFF   00000</code></pre></div></div>which would be even more expensive than using a TLB.</div><div class="h" id="invalidating-tlb-entries"><div class="notnav"><h3><a href="x86-paging/invalidating-tlb-entries"><span class="number">12.4. </span>Invalidating TLB entries</a></h3><span class="hover-meta"> <a class="split" href="x86-paging/invalidating-tlb-entries"></a><span class="metrics"><span class="wcntr"> Words: 188</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="#tlb" class="u"> TLB</a><a href="#_toc/invalidating-tlb-entries" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/invalidating-tlb-entries"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_312">When the process changes, <code>cr3</code> change to point to the page table of the new current process.</div><div class="p" id="_313">This creates a problem: the TLB is now filled with a bunch of cached entries for the old process.</div><div class="p" id="_314">A simple and naive solution would be to completely invalidate the TLB whenever the <code>cr3</code> changes.</div><div class="p" id="_315">However, this is would not be very efficient, because it often happens that we switch back to process 1 before process 2 has completely used up the entire TLB cache entries.</div><div class="p" id="_316">The solution for this is to use so called "Address Space Identifiers" (ASID) as mentioned in sources such as:<div class="list"><ul id="_317"><li id="_318"><a href="https://stackoverflow.com/questions/52813239/how-many-bits-there-are-in-a-tlb-asid-tag-for-intel-processors-and-how-to-handl">stackoverflow.com/questions/52813239/how-many-bits-there-are-in-a-tlb-asid-tag-for-intel-processors-and-how-to-handl</a></li><li id="_319"><a href="https://stackoverflow.com/questions/52713940/purpose-of-address-spaced-identifiersasids">stackoverflow.com/questions/52713940/purpose-of-address-spaced-identifiersasids</a></li><li id="_320"><a href="https://www.inf.ed.ac.uk/teaching/courses/os/slides/10-paging16.pdf">www.inf.ed.ac.uk/teaching/courses/os/slides/10-paging16.pdf</a></li></ul></div></div><div class="p" id="_321">Basically, the OS assigns a different ASID for each process, and then TLB entries are automatically also tagged with that ASID. This way when the process makes an access, the TLB can determine if a hit is actually for the current process, or if it is an old address coincidence with another process.</div><div class="p" id="_322">The x86 also offers the <code>invlpg</code> instruction which explicitly invalidates a single TLB entry. Other architectures offer even more instructions to invalidated TLB entries, such as invalidating all entries on a given range.</div><div class="h" id="linux-kernel-usage"><div class="notnav"><h2><a href="x86-paging/linux-kernel-usage"><span class="number">13. </span>Linux kernel usage</a></h2><span class="hover-meta"> <a class="split" href="x86-paging/linux-kernel-usage"></a><span class="metrics"><span class="wcntr"> Words: 685</span><span class="dcnt"> Articles: 5</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="" class="u"> x86 Paging Tutorial</a><a href="#_toc/linux-kernel-usage" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/linux-kernel-usage"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_323">The Linux kernel makes extensive usage of the paging features of x86 to allow fast process switches with small data fragmentation.</div><div class="p" id="_324">There are also however some features that the Linux kernel might not use, either because they are only for backwards compatibility, or because the Linux devs didn't feel it was worth it yet.</div><div class="h" id="play-with-physical-addresses-in-linux"><div class="notnav"><h3><a href="x86-paging/play-with-physical-addresses-in-linux"><span class="number">13.1. </span>Play with physical addresses in Linux</a></h3><span class="hover-meta"> <a class="split" href="x86-paging/play-with-physical-addresses-in-linux"></a><span class="metrics"><span class="wcntr"> Words: 40</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="#linux-kernel-usage" class="u"> Linux kernel usage</a><a href="#_toc/play-with-physical-addresses-in-linux" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/play-with-physical-addresses-in-linux"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_325">Convert virtual addresses to physical from user space with <code>/proc/&lt;pid&gt;/pagemap</code> and from kernel space with <code>virt_to_phys</code>:<div class="list"><ul id="_326"><li id="_327"><a href="https://stackoverflow.com/questions/5748492/is-there-any-api-for-determining-the-physical-address-from-virtual-address-in-li/45128487#45128487">stackoverflow.com/questions/5748492/is-there-any-api-for-determining-the-physical-address-from-virtual-address-in-li/45128487#45128487</a></li><li id="_328"><a href="https://github.com/cirosantilli/linux-kernel-module-cheat/blob/1f4f7faebacca75267cc1d63bfeffc30080d017d/kernel_module/user/virt_to_phys_user.c">github.com/cirosantilli/linux-kernel-module-cheat/blob/1f4f7faebacca75267cc1d63bfeffc30080d017d/kernel_module/user/virt_to_phys_user.c</a></li><li id="_329"><code>virt_to_phys</code>:<div class="list"><ul id="_330"><li id="_331"><a href="https://github.com/cirosantilli/linux-kernel-module-cheat/blob/0677dbd4b582d1a913462d75caad0abf21e87f32/kernel_module/virt_to_phys.c">github.com/cirosantilli/linux-kernel-module-cheat/blob/0677dbd4b582d1a913462d75caad0abf21e87f32/kernel_module/virt_to_phys.c</a></li><li id="_332"><a href="https://github.com/cirosantilli/linux-kernel-module-cheat/blob/1f4f7faebacca75267cc1d63bfeffc30080d017d/kernel_module/user/virt_to_phys_user.c">github.com/cirosantilli/linux-kernel-module-cheat/blob/1f4f7faebacca75267cc1d63bfeffc30080d017d/kernel_module/user/virt_to_phys_user.c</a></li></ul></div></li></ul></div></div><div class="p" id="_333">Dump all page tables from userspace with <code>/proc/&lt;pid&gt;/maps</code> and <code>/proc/&lt;pid&gt;/pagemap</code>:<div class="list"><ul id="_334"><li id="_335"><a href="https://github.com/cirosantilli/linux-kernel-module-cheat/blob/1f4f7faebacca75267cc1d63bfeffc30080d017d/kernel_module/user/virt_to_phys_user.c">github.com/cirosantilli/linux-kernel-module-cheat/blob/1f4f7faebacca75267cc1d63bfeffc30080d017d/kernel_module/user/virt_to_phys_user.c</a></li><li id="_336"><a href="https://stackoverflow.com/questions/6284810/proc-pid-pagemaps-and-proc-pid-maps-linux/45500208#45500208">stackoverflow.com/questions/6284810/proc-pid-pagemaps-and-proc-pid-maps-linux/45500208#45500208</a></li></ul></div></div><div class="p" id="_337">Read and write physical addresses from userspace with <code>/dev/mem</code>:<div class="list"><ul id="_338"><li id="_339"><a href="https://stackoverflow.com/questions/12040303/accessing-physical-address-from-user-space/45127890#45127890">stackoverflow.com/questions/12040303/accessing-physical-address-from-user-space/45127890#45127890</a></li><li id="_340"><a href="https://free-electrons.com/pub/mirror/devmem2.c">free-electrons.com/pub/mirror/devmem2.c</a></li></ul></div></div><div class="h" id="kernel-vs-process-memory-layout"><div class="notnav"><h3><a href="x86-paging/kernel-vs-process-memory-layout"><span class="number">13.2. </span>Kernel vs process memory layout</a></h3><span class="hover-meta"> <a class="split" href="x86-paging/kernel-vs-process-memory-layout"></a><span class="metrics"><span class="wcntr"> Words: 141</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="#linux-kernel-usage" class="u"> Linux kernel usage</a><a href="#_toc/kernel-vs-process-memory-layout" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/kernel-vs-process-memory-layout"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_341">The Linux Kernel reserves two zones of virtual memory:<div class="list"><ul id="_342"><li id="_343">one for kernel memory</li><li id="_344">one for programs</li></ul></div></div><div class="p" id="_345">The exact split is configured by <code>CONFIG_VMSPLIT_...</code>. By default:<div class="list"><ul id="_346"><li id="_347">on 32-bit:<div class="list"><ul id="_348"><li id="_349">the bottom 3/4 is program space: <code>00000000</code> to <code>BFFFFFFF</code></li><li id="_350">the top 1/4 is kernel memory: <code>C0000000</code> to <code>FFFFFFFF</code>, like this:<div class="code" id="_351"><div><pre><code>------------------ FFFFFFFF
Kernel
------------------ C0000000
------------------ BFFFFFFF


Process


------------------ 00000000</code></pre></div></div></li></ul></div></li><li id="_352">on 64-bit: currently only 48-bits are actually used, split into two equally sized disjoint spaces. The Linux kernel just assigns:<div class="list"><ul id="_353"><li id="_354">the bottom part to processes <code>00000000 00000000</code> to <code>008FFFFF FFFFFFFF</code></li><li id="_355"><div class="p" id="_356">the top part to the kernel: <code>FFFF8000 00000000</code> to <code>FFFFFFFF FFFFFFFF</code>, like this:</div><div class="code" id="_357"><div><pre><code>------------------ FFFFFFFF
Kernel
------------------ C0000000


(not addressable)


------------------ BFFFFFFF
Process
------------------ 00000000</code></pre></div></div></li></ul></div></li></ul></div></div><div class="p" id="_358">Kernel memory <a href="https://stackoverflow.com/questions/18953598/is-it-true-that-whole-system-space-address-space-in-linux-does-not-use-demand-pa">is also paged</a>.</div><div class="p" id="_359">In previous versions, <a href="https://stackoverflow.com/questions/1658757/linux-3-1-virtual-address-split">the paging was continuous, but with HIGHMEM this changed</a>.</div><div class="p" id="_360">There is no clear physical memory split: <a href="https://stackoverflow.com/questions/30471742/physical-memory-userspace-kernel-split-on-linux-x86-64">stackoverflow.com/questions/30471742/physical-memory-userspace-kernel-split-on-linux-x86-64</a></div><div class="h" id="process-memory-layout"><div class="notnav"><h3><a href="x86-paging/process-memory-layout"><span class="number">13.3. </span>Process memory layout</a></h3><span class="hover-meta"> <a class="split" href="x86-paging/process-memory-layout"></a><span class="metrics"><span class="wcntr"> Words: 256</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="#linux-kernel-usage" class="u"> Linux kernel usage</a><a href="#_toc/process-memory-layout" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/process-memory-layout"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_361">For each process, the virtual address space looks like this:<div class="code" id="_362"><div><pre><code>------------------ 2^32 - 1
Stack (grows down)
v v v v v v v v v
------------------

(unmapped)

------------------ Maximum stack size.


(unmapped)


-------------------
mmap
-------------------


(unmapped)


-------------------
^^^^^^^^^^^^^^^^^^^
brk (grows up)
-------------------
BSS
-------------------
Data
-------------------
Text
-------------------

------------------- 0</code></pre></div></div></div><div class="p" id="_363">The kernel maintains a list of pages that belong to each process, and synchronizes that with the paging.</div><div class="p" id="_364">If the program accesses memory that does not belong to it, the kernel handles a page-fault, and decides what to do:<div class="list"><ul id="_365"><li id="_366">if it is above the maximum stack size, allocate those pages to the process</li><li id="_367">otherwise, send a SIGSEGV to the process, which usually kills it</li></ul></div></div><div class="p" id="_368">When an ELF file is loaded by the kernel to start a program with the <code>exec</code> system call, the kernel automatically registers text, data, BSS and stack for the program.</div><div class="p" id="_369">The <code>brk</code> and <code>mmap</code> areas can be modified by request of the program through the <a href="https://stackoverflow.com/questions/6988487/what-does-brk-system-call-do/31082353#31082353"><code>brk</code></a> and <code>mmap</code> system calls. But the kernel can also deny the program those areas if there is not enough memory.</div><div class="p" id="_370"><code>brk</code> and <code>mmap</code> can be used to implement <code>malloc</code>, or the so called "heap".</div><div class="p" id="_371"><code>mmap</code> is also used to load dynamically loaded libraries into the program's memory so that it can access and run it.</div><div class="p" id="_372">Stack allocation: <a href="https://stackoverflow.com/questions/17671423/stack-allocation-for-process">stackoverflow.com/questions/17671423/stack-allocation-for-process</a></div><div class="p" id="_373">Calculating exact addresses Things are complicated by:<div class="list"><ul id="_374"><li id="_375"><a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">Address Space Layout Randomization</a>.</li><li id="_376">the fact that environment variables, CLI arguments, and some ELF header data take up initial stack space: <a href="https://unix.stackexchange.com/questions/145557/how-does-stack-allocation-work-in-linux/239323#239323">unix.stackexchange.com/questions/145557/how-does-stack-allocation-work-in-linux/239323#239323</a></li></ul></div></div><div class="p" id="_377">Why the text does not start at 0: <a href="https://stackoverflow.com/questions/14795164/why-do-linux-program-text-sections-start-at-0x0804800-and-stack-tops-start-at-0">stackoverflow.com/questions/14795164/why-do-linux-program-text-sections-start-at-0x0804800-and-stack-tops-start-at-0</a></div><div class="h" id="copy-on-write"><div class="notnav"><h3><a href="x86-paging/copy-on-write"><span class="number">13.4. </span>Copy-on-write <span class="meta">(COW)</span></a></h3><span class="hover-meta"> <a class="split" href="x86-paging/copy-on-write"></a><span class="metrics"><span class="wcntr"> Words: 120</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="#linux-kernel-usage" class="u"> Linux kernel usage</a><a href="#_toc/copy-on-write" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/copy-on-write"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_379"><a href="https://en.wikipedia.org/wiki/Copy-on-write">en.wikipedia.org/wiki/Copy-on-write</a></div><div class="p" id="_380">Besides a missing page, a very common source of page faults is copy-on-write (COW).</div><div class="p" id="_381">Page tables have extra flags that allow the OS to mark a page a read-only.</div><div class="p" id="_382">Those page faults only happen when a process tries to write to the page, and not read from it.</div><div class="p" id="_383">When Linux forks a process:<div class="list"><ul id="_384"><li id="_385">instead of copying all the pages, which is unnecessarily costly, it makes the page tables of the two process point to the same physical address.</li><li id="_386">it marks those linear addresses as read-only</li><li id="_387">whenever one of the processes tries to write to a page, the makes a copy of the physical memory, and updates the pages of the two process to point to the two different physical addresses</li></ul></div></div><div class="h" id="linux-source-tree"><div class="notnav"><h3><a href="x86-paging/linux-source-tree"><span class="number">13.5. </span>Linux source tree</a></h3><span class="hover-meta"> <a class="split" href="x86-paging/linux-source-tree"></a><span class="metrics"><span class="wcntr"> Words: 74</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="#linux-kernel-usage" class="u"> Linux kernel usage</a><a href="#_toc/linux-source-tree" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/linux-source-tree"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_388">In <code>v4.2</code>, look under <code>arch/x86/</code>:<div class="list"><ul id="_389"><li id="_390"><code>include/asm/pgtable*</code></li><li id="_391"><code>include/asm/page*</code></li><li id="_392"><code>mm/pgtable*</code></li><li id="_393"><code>mm/page*</code></li></ul></div></div><div class="p" id="_394">There seems to be no structs defined to represent the pages, only macros: <code>include/asm/page_types.h</code> is specially interesting. Excerpt:<div class="code" id="_395"><div><pre><code>#define _PAGE_BIT_PRESENT   0   /* is present */
#define _PAGE_BIT_RW        1   /* writeable */
#define _PAGE_BIT_USER      2   /* userspace addressable */
#define _PAGE_BIT_PWT       3   /* page write through */</code></pre></div></div></div><div class="p" id="_396"><code>arch/x86/include/uapi/asm/processor-flags.h</code> defines <code>CR0</code>, and in particular the <code>PG</code> bit position:<div class="code" id="_397"><div><pre><code>#define X86_CR0_PG_BIT      31 /* Paging */</code></pre></div></div></div><div class="h" id="memory-management-unit"><div class="notnav"><h2><a href="x86-paging/memory-management-unit"><span class="number">14. </span>Memory management unit</a></h2><span class="hover-meta"> <a class="split" href="x86-paging/memory-management-unit"></a><span class="metrics"><span class="wcntr"> Words: 45</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="" class="u"> x86 Paging Tutorial</a><a href="#_toc/memory-management-unit" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/memory-management-unit"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_398">Paging is done by the <a href="https://en.wikipedia.org/wiki/Memory_management_unit">Memory Management Unit</a> (MMU) part of the CPU.</div><div class="p" id="_399">Like many others (e.g. <a href="https://en.wikipedia.org/wiki/X87">x87 co-processor</a>, <a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">APIC</a>), this used to be by separate chip on early days.</div><div class="p" id="_400">It was later integrated into the CPU, but the term MMU still used.</div><div class="h" id="second-level-address-translation"><div class="notnav"><h2><a href="x86-paging/second-level-address-translation"><span class="number">15. </span>Second Level Address Translation</a></h2><span class="hover-meta"> <a class="split" href="x86-paging/second-level-address-translation"></a><span class="metrics"><span class="wcntr"> Words: 10</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="" class="u"> x86 Paging Tutorial</a><a href="#_toc/second-level-address-translation" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/second-level-address-translation"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_401"><a href="https://en.wikipedia.org/wiki/Second_Level_Address_Translation">en.wikipedia.org/wiki/Second_Level_Address_Translation</a></div><div class="p" id="_402">Two level address translation to make OS emulation more efficient.</div><div class="h" id="other-architectures"><div class="notnav"><h2><a href="x86-paging/other-architectures"><span class="number">16. </span>Other architectures</a></h2><span class="hover-meta"> <a class="split" href="x86-paging/other-architectures"></a><span class="metrics"><span class="wcntr"> Words: 57</span><span class="dcnt"> Articles: 1</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="" class="u"> x86 Paging Tutorial</a><a href="#_toc/other-architectures" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/other-architectures"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_403"><a href="https://stackoverflow.com/a/32258855/895245">Peter Cordes mentions</a> that some architectures like MIPS leave paging almost completely in the hands of software: a TLB miss runs an OS-supplied function to walk the page tables, and insert the new mapping into the TLB. In such architectures, the OS can use whatever data structure it wants.</div><div class="h" id="arm"><div class="notnav"><h3><a href="x86-paging/arm"><span class="number">16.1. </span>ARM</a></h3><span class="hover-meta"> <a class="split" href="x86-paging/arm"></a><span class="metrics"><span class="wcntr"> Words: 8</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="#other-architectures" class="u"> Other architectures</a><a href="#_toc/arm" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/arm"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_404">Information about ARM paging can be found at: <a href="https://cirosantilli.com/linux-kernel-module-cheat#arm-paging">cirosantilli.com/linux-kernel-module-cheat#arm-paging</a></div><div class="h" id="bibliography"><div class="notnav"><h2><a href="x86-paging/bibliography"><span class="number">17. </span>Bibliography</a></h2><span class="hover-meta"> <a class="split" href="x86-paging/bibliography"></a><span class="metrics"><span class="wcntr"> Words: 35</span></span></span></div><nav class="h-nav h-nav-toplevel"><div class="nav"><a href="" class="u"> x86 Paging Tutorial</a><a href="#_toc/bibliography" class="toc"></a><a href="https://ourbigbook.com/cirosantilli/x86-paging/bibliography"><img src="_obb/logo.svg" class="logo" alt=""> OurBigBook.com</a></div></nav></div><div class="p" id="_405">Free:<div class="list"><ul id="_406"><li id="_407"><div class="p" id="_408"><a href="https://www.cs.rutgers.edu/~pxk/416/notes/">rutgers-pxk-416</a> chapter "Memory management: lecture notes"</div><div class="p" id="_409">Good historical review of memory organization techniques used by older OS.</div></li></ul></div></div><div class="p" id="_410">Non-free:<div class="list"><ul id="_411"><li id="_412"><div class="p" id="_413"><a href="https://www.amazon.com/books/dp/0596005652">bovet05</a> chapter "Memory addressing"</div><div class="p" id="_414">Reasonable intro to x86 memory addressing. Missing some good and simple examples.</div></li></ul></div></div><h2 id="_ancestors"><a href="#_ancestors"><span class="fa-solid-900 icon"></span> Ancestors <span class="meta">(11)</span></a></h2><div class="list"><ol><li><a href="computer-hardware#x86">x86</a></li><li><a href="computer-hardware#list-of-instruction-set-architectures">List of instruction set architectures</a></li><li><a href="computer-hardware#instruction-set-architecture">Instruction set architecture</a></li><li><a href="computer-hardware#processor-computing">Processor (computing)</a></li><li><a href="computer-hardware#computer-hardware-component-type">Computer hardware component type</a></li><li><a href="computer-hardware">Computer hardware</a></li><li><a href="computer">Computer</a></li><li><a href="technology#information-technology">Information technology</a></li><li><a href="technology#area-of-technology">Area of technology</a></li><li><a href="technology">Technology</a></li><li><a href="."><span title="Home" class="fa-solid-900 icon"></span> Home</a></li></ol></div><h2 id="_incoming-links"><a href="#_incoming-links"><span title="Incoming links" class="fa-solid-900 icon"></span> Incoming links <span class="meta">(2)</span></a></h2><div class="list"><ul><li><a href="articles">The best articles by Ciro Santilli</a></li><li><a href="skills#programming-languages">Programming languages</a></li></ul></div>
</main>
<footer>
<div>Powered by <a href="https://docs.ourbigbook.com">OurBigBook</a></div>
<div>License: <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> unless noted</div>
<div><a href="https://github.com/cirosantilli/cirosantilli.github.io/issues">Suggestions and corrections</a></div>
<div><a href="contact">Contact Ciro Santilli</a></div>
<div><a href="_dir">Website source code</a></div>
<div><a href="https://github.com/cirosantilli/cirosantilli.github.io">Website source code on GitHub</a></div>
<div><a href="_file/x86-paging.bigb">Source code for this page: x86-paging.bigb</a></div>
<div><a href="https://github.com/cirosantilli/cirosantilli.github.io/blob/f7dac29d5224c15015eee520ccee15a3adb07b98/x86-paging.bigb">Source code for this page on GitHub</a></div>
<div>Cite with: <a href="https://zenodo.org/badge/latestdoi/16453261">this DOI</a></div>
<div><img src="https://raw.githubusercontent.com/cirosantilli/media/master/ID_photo_of_Ciro_Santilli_taken_in_2013_left_eye_200_100.jpg" loading="lazy" alt="ID photo of Ciro Santilli taken in 2013 right eye"></div>
</footer>
<script>
window.ourbigbook_split_headers = true;
window.ourbigbook_html_x_extension = false;
window.ourbigbook_redirect_prefix = "x86-paging/";
</script>
<script src="_obb/dist/ourbigbook_runtime.js"></script><script>ourbigbook_runtime.ourbigbook_runtime()</script><script src="_raw/main.js"></script>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-47867706-1', 'auto');
ga('send', 'pageview');
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-DEE2HEJW9X"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-DEE2HEJW9X');
</script>
<script src="https://giscus.app/client.js"
        data-repo="cirosantilli/cirosantilli.github.io"
        data-repo-id="MDEwOlJlcG9zaXRvcnkxNjQ1MzI2MQ=="
        data-category="giscus"
        data-category-id="DIC_kwDOAPsOjc4CZ6zZ"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="dark_high_contrast"
        data-lang="en"
        crossorigin="anonymous"
        async>
</script>
</body>
</html>

#!/usr/bin/env node

// https://cirosantilli.com/sequelize-example

const assert = require('assert');
const path = require('path');
const { DataTypes } = require('sequelize');
const common = require('./common')
const sequelize = common.sequelize(__filename, process.argv[2], { define: { timestamps: false } })
;(async () => {

// Create the tables.
const User = sequelize.define('User', {
  name: { type: DataTypes.STRING },
}, {});
User.belongsToMany(User, {through: 'UserFollowUser', as: 'Follows'});
await sequelize.sync({force: true});

// Create some users.

const user0 = await User.create({name: 'user0'})
const user1 = await User.create({name: 'user1'})
const user2 = await User.create({name: 'user2'})
const user3 = await User.create({name: 'user3'})

// Make user0 follow user1 and user2
await user0.addFollows([user1, user2])
// Make user2 and user3 follow user0
await user2.addFollow(user0)
await user3.addFollow(user0)

let rows

// Get users followed by user0.
rows = await user0.getFollows({order: [['name', 'ASC']]})
common.assertEqual(rows, [
  { name: 'user1' },
  { name: 'user2' },
])

// Reverse order.
rows = await user0.getFollows({order: [['name', 'DESC']]})
common.assertEqual(rows, [
  { name: 'user2' },
  { name: 'user1' },
])

// Get users followed by user1.
rows = await user1.getFollows({order: [['name', 'ASC']]})
common.assertEqual(rows, [])

// Get users followed by user2.
rows = await user2.getFollows({order: [['name', 'ASC']]})
common.assertEqual(rows, [
  { name: 'user0' },
])

// Get users followed by user3.
rows = await user3.getFollows({order: [['name', 'ASC']]})
common.assertEqual(rows, [
  { name: 'user0' },
])

// Get users followed by an user but by ID instead of user object.
// Also get rid of all useless fields from the trough table.
//
// Super many to many allows us to get rid of the ugly findOne,
// and instead use findAll. This makes it much easier to reuse a single sequelize call
// for multiple API calls.
rows = (await User.findOne({
  where: {id: user0.id},
  attributes: [],
  include: [{
    model: User,
    as: 'Follows',
    through: {attributes: []},
  }],
  order: [['Follows', 'name', 'ASC']]
})).Follows
common.assertEqual(rows, [
  { name: 'user1'},
  { name: 'user2'},
])

// Same in reverse order.
rows = (await User.findOne({
  where: {id: user0.id},
  attributes: [],
  include: [{
    model: User,
    as: 'Follows',
    through: {attributes: []},
  }],
  order: [['Follows', 'name', 'DESC']]
})).Follows
common.assertEqual(rows, [
  { name: 'user2'},
  { name: 'user1'},
])

//// Yet another method with the many-to-many reversed.
//// TODO close to working, but on is being ignored...
//{
//  const user0Follows = await User.findAll({
//    include: [{
//      model: User,
//      as: 'Follows',
//      on: {
//        '$User.UserFollowUser.FollowIdasdf$': { [Sequelize.Op.col]: 'User.user_id' },
//        '$User.UserFollowUser.UserId$': user0.id,
//      },
//      attributes: [],
//      through: {attributes: []},
//    }],
//    order: [['name', 'ASC']],
//  })
//  // TODO
//  //assert.strictEqual(user0Follows[0].name, 'user1');
//  //assert.strictEqual(user0Follows[1].name, 'user2');
//  //assert.strictEqual(user0Follows.length, 2);
//}

// Find users that follow user0
// TODO any way with the nicer autogenerated methods?
// https://github.com/sequelize/sequelize/issues/8263
// https://stackoverflow.com/questions/27065154/how-to-get-all-children-or-parents-in-a-many-to-many-association-if-one-model-re
rows = await User.findAll({
  include: [{
    model: User,
    as: 'Follows',
    where: {id: user0.id},
    attributes: [],
    through: {attributes: []}
  }],
  order: [['name', 'ASC']],
})
common.assertEqual(rows, [
  { name: 'user2'},
  { name: 'user3'},
])

// has methods
assert(!await user0.hasFollow(user0))
assert(!await user0.hasFollow(user0.id))
assert( await user0.hasFollow(user1))
assert( await user0.hasFollow(user2))
assert(!await user0.hasFollow(user3))

// Count method
assert.strictEqual(await user0.countFollows(), 2)

})().finally(() => { return sequelize.close() });

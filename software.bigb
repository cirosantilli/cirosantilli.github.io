= Software
{wiki}

= Cloud computing
{parent=Software}
{wiki}

= Platform as a service
{parent=Cloud computing}
{title2=PaaS}
{wiki}

Highly managed, you don't even see the <Docker (software)> images, only some higher level <JSON> configuration file.

These setups are really convenient and cheap, and form a decent way to try out a new website with simple requirements.

= AWS Elastic Beanstalk
{c}
{parent=Platform as a service}
{wiki}

= Heroku
{c}
{parent=Platform as a service}
{wiki}

This feels good.

One problem though is that Heroku is very opinionated, a likely like other PaaSes. So if you are trying something that is slightly off the mos common use case, you might be fucked.

Another problem with Heroku is that it is extremely difficult to debug a build that is broken on Heroku but not locally. We needed a way to be able to drop into a shell in the middle of build in case of failure. Otherwise it is impossible.

Deployment:
``
git push heroku HEAD:master
``

View <stdout> logs:
``
heroku logs --tail
``

<PostgreSQL> database, it seems to be delegated to <AWS>. How to browse database: https://stackoverflow.com/questions/20410873/how-can-i-browse-my-heroku-database
``
heroku pg:psql
``

Drop and recreate database:
``
heroku pg:reset --confirm <app-name>
``
All tables are destroyed.

Restart app:
``
heroku restart
``

= Send free emails from Heroku
{parent=Heroku}

Arghh, why so hard... tested 2021:
* <Sendgrid>: this one is the first one I got working on free tier!
* Mailgun: the Heroku add-on creates a free plan. This is smaller than the flex plan and does not allow custom domains, and is not available when signing up on mailgun.com directly: https://help.mailgun.com/hc/en-us/articles/203068914-What-Are-the-Differences-Between-the-Free-and-Flex-Plans- And without custom domains you cannot send emails to anyone, only to people in the 5 manually whitelisted list, thus making this worthless. Also, gmail is not able to verify the DNS of the sandbox emails, and they go to spam.

  Mailgun does feel good otherwise if you are willing to pay. Their Heroku integration feels great, exposes everything you need on environment variables straight away.
* CloudMailin: does not feel as well developed as Mailgun. More focus on receiving. Tried adding TXT xxx._domainkey.ourbigbook.com and CNAME mta.ourbigbook.com entires with custom domain to see if it works, took forever to find that page... https://www.cloudmailin.com/outbound/domains/xxx Domain verification requires a bit of human contact via email.

  They also don't document their Heroku usage well. The envvars generated on Heroku are useless, only to login on their web UI. The send username and password must be obtained on their confusing web ui.

= Compiler
{parent=Software}
{wiki}

= Compile
{synonym}

= Compiles
{synonym}

= Compiler toolchain
{parent=Compiler}
{wiki}

<Compiler> + other closely related crap like <linker (computing)>.

= Linker
{disambiguate=computing}
{parent=Compiler toolchain}
{wiki}

Some linker related ansewrs by <Ciro Santilli>:
* https://stackoverflow.com/questions/3322911/what-do-linkers-do/33690144#33690144[How do linkers and address relocation work?]
* https://stackoverflow.com/questions/29391965/what-is-partial-linking-in-gnu-linker/53959624#53959624[What is incremental linking or partial linking?]
* https://stackoverflow.com/questions/3476093/replacing-ld-with-gold-any-experience/53921263#53921263[GOLD (`-fuse-ld=gold`) linker vs the traditional GNU ld and LLVM ldd]
* https://stackoverflow.com/questions/2463150/what-is-the-fpie-option-for-position-independent-executables-in-gcc-and-ld/51308031#51308031[What is the -fPIE option for position-independent executables in GCC and ld?]

= Binutils
{c}
{parent=Compiler}

= Automatic programming
{parent=Compiler}
{wiki}

"automatic programming has always been a euphemism for programming in a higher-level language than was then available to the programmer" sums it up.

The ultimate high level is of course to program with: "computer, make <money>", which is the goal of <artificial general intelligence>.

= Automatic code generation
{parent=Automatic programming}

= Code generation
{synonym}

= GNU Compiler Collection
{c}
{parent=Compiler}

= gcc
{c}
{synonym}
{title2}

= Reproducible builds
{c}
{parent=Compiler}
{wiki}

Reproducible builds allow anyone to verify that a <binary large object> contains what it claims to contain!

Bibliography:
* https://stackoverflow.com/questions/14653874/how-to-produce-deterministic-binary-output-with-g/31019307#31019307
* https://stackoverflow.com/questions/19511356/how-to-make-android-applications-with-reproducible-builds

= Source-to-source compiler
{parent=Compiler}
{wiki}

= Transpiler
{synonym}

= Transpilation
{synonym}

= Transpile
{synonym}

= Transpiles
{synonym}

= Computer-aided design
{parent=Software}
{wiki}

= CAD
{c}
{synonym}
{title2}

= Open source CAD software
{parent=Computer-aided design}

= FreeCAD
{c}
{parent=Open source CAD software}
{wiki}

= Computer graphics
{parent=Software}
{wiki}

https://en.wikipedia.org/wiki/List_of_information_graphics_software

= Mathematics illustration software
{parent=Computer graphics}

= Software for drawing geometry diagrams
{synonym}
{title2}

Survey by <Ciro Santilli>: https://math.stackexchange.com/questions/1985/software-for-drawing-geometry-diagrams/3938216#3938216

Many <plotting software> can be used to create <mathematics> illustrations. They just tend to have more data-oriented rather than explanatory-oriented output.

Some notable ones:
* <Inkscape>{child}

= Graphics library
{c}
{parent=Computer graphics}
{wiki}

= OpenGL
{c}
{parent=Graphics library}
{wiki}

<Ciro Santilli> has some good related articles listed under: <articles>.

= Freetype GL
{c}
{parent=OpenGL}

https://github.com/rougier/freetype-gl

Good library to render text in <OpenGL>, see also: https://stackoverflow.com/questions/8847899/opengl-how-to-draw-text-using-only-opengl-methods/36065835#36065835

= Khronos Group
{c}
{parent=OpenGL}
{wiki}

= Khronos
{c}
{synonym}

The fact that they kept the standard <open source> makes them huge heroes, see also: <closed standard>.

= opengl-tutorial.org
{parent=OpenGL}

https://github.com/opengl-tutorials/ogl/

Good modern <OpenGL> tutorial in retained mode with shaders, see also: https://stackoverflow.com/questions/6733934/what-does-immediate-mode-mean-in-opengl/36166310#36166310

= Direct3D
{c}
{parent=Graphics library}
{tag=Evil}
{wiki}

= JavaScript graphics library
{parent=Graphics library}

= Paper.js
{c}
{parent=JavaScript graphics library}

https://github.com/paperjs/paper.js

= Pixi.js
{c}
{parent=JavaScript graphics library}

https://github.com/pixijs/pixi.js

= Two.js
{c}
{parent=JavaScript graphics library}

https://github.com/jonobr1/two.js

Examples at: \a[two-js/].

<JavaScript> library, works both on browser and headless with <Node.js> to <SVG>.

Feels good. Maybe not ultra featured, and could have more simple examples in docs, but still good.

Vs <Paper.js> https://github.com/jonobr1/two.js/issues/319

One of the main features of Two.js appears to be the fact that it can natively render to either SVG and canvas, rather than creating SVG through DOM hacks as done by other projects.

= Computer program
{parent=Software}
{wiki}

= Program
{synonym}

One specific <software> project, typically with a single <executable file format> entry point.

= Computer security
{parent=Software}
{wiki}

As mentioned at <computer security researcher>{full}, <Ciro Santilli> really tends to like people from this area.

Also, the type of programming Ciro used to do, <systems programming>, is particularly useful to security researchers, e.g. <Linux Kernel Module Cheat>.

The reason he does not go into this is that Ciro would rather fight against the more eternal <laws of physics> rather than with some typo some dude at <Apple> did last week and which will be patched in a month.

= Arbitrary code execution
{parent=Computer security}
{title2=ACE}
{wiki}

= Computer security conference
{parent=Computer security}

= DEF CON
{c}
{parent=Computer security conference}
{title2=1993-}
{wiki}

= Black Hat Briefings
{c}
{parent=DEF CON}
{title2=1997-}
{wiki}

= BlackHat
{c}
{synonym}

= Computer security researcher
{parent=Computer security}
{wiki}

<Ciro Santilli> found out that he likes computer security researchers and vice versa.

It's a bit the same reason why he likes <physicists>: you can't bullshit with security.

You can't just talk nice and hope for people to belive you.

You can't not try to break things and just <security through obscurity>[keep everyone happy in their false illusion of safety].

You can't do a half job.

If you do any of that, you \i[will] get your ass handed to you in a little gift bag.

All of this is closely linked to <Ciro Santilli's self perceived creative personality> and <being naughty and creative are correlated>.

= Dan Kaminsky
{c}
{parent=Computer security researcher}
{title2=1979-2021}
{wiki}

A superstar security researcher with some major exploits from in the 2000's.

= Dan Kaminsky approves Linux Kernel Module Cheat
{c}
{parent=Dan Kaminsky}

https://twitter.com/dakami/status/1344853681749934080

Oh yeah, that felt good. A few months before he died.

= Len Sassaman
{c}
{parent=Computer security researcher}
{wiki}

= Data erasure
{parent=Computer security}
{wiki}

= Multi-factor authentication
{parent=Computer security}
{wiki}

= 2FA
{c}
{synonym}
{title2}

= 2FA app
{parent=Multi-factor authentication}

= Google 2FA app token can be updated without checking the old 2FA
{parent=Multi-factor authentication}

Ermm, as of February 2021, I was able to update my 2FA app token with the password alone, it did not ask for the old 2FA.

So what's the fucking point of 2FA then? An attacker with my password would be able to login by doing that!

Is it that Google trusts that particular action because I used the same phone/known IP or something like that?

= OAuth
{c}
{parent=Computer security}
{wiki}

= Password
{parent=Computer security}
{wiki}

= Password manager
{parent=Password}
{wiki}

= Plausible deniability
{parent=Computer security}
{wiki}

= Privacy
{parent=Computer security}
{wiki}

= Security through obscurity
{parent=Computer security}
{wiki}

https://stackoverflow.com/questions/533965/why-is-security-through-obscurity-a-bad-idea

Do as I say, not as I do: <Ciro Santilli's Stack Overflow suspension for vote fraud script 2019>, https://meta.stackoverflow.com/questions/381577/is-it-ok-to-have-links-on-how-to-create-sock-puppets-and-gain-rep-fraudulently-i/381635#381635[].

\Video[https://www.youtube.com/watch?v=IH0GXWQDk0Q]
{title=LockPickingLawyer SAINTCON keynote (2021)}
{description=
SAINTCON is "Utah's Premiere Security Conference".
* https://youtu.be/IH0GXWQDk0Q?t=900 mentions that https://en.wikipedia.org/wiki/Alfred_Charles_Hobbs[Alfred Charles Hobbs] commented in 1853:
  \Q[Rogues are very keen in their profession, and know already much more than we can teach them]
}
= Kerckhoffs's principle
{c}
{parent=Security through obscurity}
{wiki}

Basically the opposite of <security through obscurity>, though slightly more focused on <cryptography>.

= Malware
{parent=Computer security}
{wiki}

= Ransomware
{parent=Computer security}
{wiki}

= Data breach
{parent=Computer security}
{wiki}

= WikiLeaks
{c}
{parent=Data breach}
{tag=Wiki}
{wiki}

= List of data breaches
{parent=Data breach}

= United States diplomatic cables leak
{c}
{parent=List of data breaches}
{title2=2010}
{wiki}

= Cablegate
{c}
{synonym}

= Computer user-interface
{parent=Software}

= Application programming interface
{parent=Computer user-interface}
{wiki}

= API
{c}
{synonym}
{title2}

= REST API
{c}
{parent=Application programming interface}
{wiki}

= GraphQL
{c}
{parent=Application programming interface}
{wiki}

This is really good.

It allows the client to prepare a single request that gets all the data it wants to fill up a given webpage, rather than doing several separate requests.

So it only gets exactly what it needs, and in a single request.

Very sweet. This is the future of the web.

= Command-line interface
{parent=Computer user-interface}
{title2=CLI}
{wiki}

= Desktop environment
{parent=Command-line interface}
{wiki}

<tmux> for newbs.

= Graphical user interface
{parent=Computer user-interface}
{wiki}

= GUI
{c}
{synonym}
{title2}

= Splash screen
{parent=Graphical user interface}
{wiki}

= Qt
{disambiguate=software}
{c}
{parent=Graphical user interface}
{wiki}

= Data compression
{parent=Software}
{wiki}

= Lossless compression
{parent=Data compression}
{wiki}

= Database
{parent=Software}
{wiki}

= ACID
{disambiguate=database}
{c}
{parent=Database}
{wiki}

= Atomicity
{disambiguate=database systems}
{parent=ACID (database)}

This means that e.g. if you do an `UPDATE` query on multiple rows, and power goes out half way, either all update, or none update.

This is different from <isolation (database systems)>, which considers instead what can or cannot happen when multiple queries are running in parallel.

= Isolation
{disambiguate=database systems}
{parent=ACID (database)}

Determines what can or cannot happen when multiple queries are running in parallel.

See <SQL transaction isolation level>{full} for the most common context under which this is discussed: <SQL>.

= Database management system
{parent=Database}
{wiki}

= DBMS
{c}
{synonym}

A <software> that implements some database system, e.g. <PostgreSQL> or <MySQL> are two (widely extended) <SQL> implementations.

= NoSQL
{c}
{parent=Database}
{wiki}

= MongoDB
{c}
{parent=Database}
{wiki}

List databases:
``
echo 'show dbs' | mongo
``

Delete database:
``
use mydb
db.dropDatabase()
``
or:
``
echo 'db.dropDatabase()' | mongo mydb
``

View collections within a database:
``
echo 'db.getCollectionNames()' | mongo mydb
``

Show all data from one of the collections: https://stackoverflow.com/questions/24985684/mongodb-show-all-contents-from-all-collections
``
echo 'db.collectionName.find()' | mongo mydb
``

= Install MongoDB on Ubuntu
{parent=MongoDB}

Tested as of Ubuntu 20.04, there is no Mongo package available by default due to their change to <Server Side Public License>, which Debian opposed. Therefore, you have to add their custom PPA as mentioned at: https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/

= Object-relational mapping
{parent=Database}
{wiki=Object–relational_mapping}

= ORM
{c}
{synonym}
{title2}

Per language:
* <node.js ORM library>

= How to decide if an ORM is good?
{parent=Object-relational mapping}

How to decide if an ORM is decent? Just try to replicate every <SQL> query from \a[nodejs/sequelize/raw/many_to_many.js] on <PostgreSQL> and <SQLite>.

There is only a very finite number of possible reasonable queries on a two table many to many relationship with a join table. A decent ORM \i[has] to be able to do them all.

If it can do all those queries, then the ORM can actually do a good subset of SQL and is decent. If not, it can't, and this will make you suffer. E.g. <Sequelize> v5 is such an ORM that makes you suffer.

The next thing to check are transactions.

Basically, all of those come up if you try to implement a blog <hello world> world such as <gothinkster realworld> \i[correctly], i.e. without unnecessary inefficiencies due to your ORM on top of underlying SQL, and dealing with concurrency.

= Relational database
{parent=Database}
{wiki}

= Relational database management system
{parent=Relational database}
{tag=Database management system}

= RDBMS
{c}
{synonym}
{title2}

\Include[sql]{parent=relational-database-management-system}

= Table relationship
{parent=Database}
{wiki=Associative_entity}

= One-to-one
{disambiguate=data-model}
{parent=Table relationship}
{wiki}

= One-to-many
{parent=Table relationship}
{wiki=One-to-many_(data_model)}

= Many-to-one
{synonym}
{title2}

= Many-to-many
{parent=Table relationship}
{wiki=Many-to-many_(data_model)}

= Many-to-many relation
{synonym}

= File manager
{parent=Software}
{wiki}

<Ciro Santilli> used to use file managers in the past.

But he finally converted to a shell `cd` aliases that auto-`ls`: https://github.com/cirosantilli/dotfiles/blob/a51bcc324f0cff0eddd4c3bb8654ec223a0adb7b/home/.bashrc#L1058

= Krusader
{parent=File manager}
{wiki}

The most powerful <GUI> <file manager> ever?? Infinite configurability??

<Ciro Santilli> wasted some time on it before he gave up on file managers altogether.

= Ranger
{disambiguate=file manager}
{parent=File manager}
{wiki}

<Ciro Santilli> considered it before he stopped using file managers altogether, it is not bad.

= File sharing
{parent=Software}
{wiki}

= BitTorrent
{c}
{parent=File sharing}
{wiki}

= Game engine
{parent=Software}
{wiki}

A library to make <games>{parent}.

= Cocos2d
{c}
{parent=Game engine}
{wiki}

<Ciro Santilli> considered this as the basis for <Ciro's 2D reinforcement learning games>, but ultimately decided it was a bit too messy. Nice overall though.

= Urho3D
{c}
{parent=Game engine}
{wiki}

Their project lead as of 2018 was pro-CCP: https://github.com/cirosantilli/china-dictatorship/blob/aa1176c57fc2929465294e520b43b50d44e202ba/communities-that-censor-politics.md

= Geographic information system
{parent=Software}
{title2=GIS}
{wiki}

= Geographic information system file format
{parent=Geographic information system}

= Keyhole Markup Language
{c}
{parent=Geographic information system file format}
{title2=KML}
{wiki}

Originally by <Keyhole Inc.>, which the nbecame <Google Maps>, but the format seems standardized and has non-Google support, so should be OK.

= List of geographic information systems
{parent=Geographic information system}

= Google Maps
{c}
{parent=List of geographic information systems}
{tag=Google product}
{wiki}

Owned/developed by <Google>{parent} as of 2020.

Early on jumpstarted from several acquisitions, notably <Keyhole Inc.>.

= Keyhole Inc.
{c}
{parent=Google Maps}

= Google Street View
{c}
{parent=Google Maps}
{wiki}

Street View's go into the past mode is the dream of every archaeologist. Ciro can only dream of a magic street view that allows going back to earlier centuries and beyond... isn't it amazing to think that people in the future will have that ability to time travel back to around the year 2006? Ciro wonders how long <Google> will be able to keep storing data like that.

Thanks, <Keyhole Inc.>[CIA].

= OpenStreetMaps
{c}
{parent=List of geographic information systems}
{title2=OSM}
{wiki}

It is rare to find a project with such a ridiculously high importance over funding ratio.

E.g., as of 2020, their help login https://help.openstreetmap.org/ shows MyOpenID as an option, which was discontinued in 2014, and not <Google> <OAuth>.

They do still seem to have a bit more activity than https://gis.stackexchange.com/questions/tagged/openstreetmap on <Stack Exchange>.

Complaints:
* <Transliteration> is off by default!...... https://wiki.openstreetmap.org/wiki/Translation You just have to learn all scripts ever. Good luck with the <Chinese characters>. Genius.
* In order to see information about places, you have to click "Query features" on the toolbar first. Who made such a terrible UI? Direct click is a much, and so easy to implement?
* It is impossible to discern different types of paths and other walking path symbols, the symbols are too small, and just scale down to a line no matter how much you zoom in.
* Power lines are way too visible. While that is kind of cool, it is useless and distracting to most people most of the time.
* No street-level imagery...: https://help.openstreetmap.org/questions/1178/adding-photos
* No aerial imagery: https://help.openstreetmap.org/questions/6849/how-can-i-see-the-aerial-imagery-without-editing-the-map But that is kind of understandable, as that one might not be free.
* No restaurant ratings: https://help.openstreetmap.org/questions/64852/ratings-for-pois because it is "Subjective". OMG those people, such a huge value powerhouse wasted.

  Not just for restaurants, but for other things as well, e.g. sharing of good cycle circuits.

All of this is a shame, because they do have some incredible data that you cannot find easily on other maps because people just edited it up.

= OsmAnd
{c}
{parent=OpenStreetMaps}
{wiki}

https://github.com/osmandapp/Osmand

Kind of works! Notably, has the amazing cycling database offline for you, if you fall within the 6 area downloads. It is worth supporting these people beyond the 6 free downloads however.

= Ordnance Survey
{c}
{parent=List of geographic information systems}
{wiki}

Has some of the best map data available for the <United Kingdom>, but their data appears to be proprietary?

= Integrated development environment
{parent=Software}
{wiki}

= IDE
{c}
{synonym}
{title2}

IDEs are absolutely essential for developing complex software.

The funny thing is that you don't notice this until someone shows it to you. But once you see it, there is not turning back, just like <Steve Jobs customers don't know what they want quote>.

Unfortunately, after the https://movingfulcrum.com/the-fall-of-eclipse/[Fall of Eclipse] (https://web.archive.org/web/20190824081229/https://movingfulcrum.com/the-fall-of-eclipse/[archive]), the IDE landscape in 2019 is horrible and split between:
* highly buggy but still feature rich Eclipse
* many may many other feature lacking options using possibly more trendy and forward lasting implementations like https://en.wikipedia.org/wiki/Electron_(software_framework)[Electron]
* awesome cross-platform proprietary https://en.wikipedia.org/wiki/JetBrains[JetBrains] IDEs
* the God-like Windows-only proprietary language-lacking Visual Studio

Programmers of the world: unite! Focus on one IDE, and make it work for all languages and all build systems. Give it all the features that Eclipse has, but none of the bugginess. Work with top project to make sure the IDE works for all top projects.

Projects of the world: support one IDE, with in-tree configuration. Complex integration is often required between the IDE and the build system, and successful projects must to that once for all developers. Either do this, or watch you complex project wither away.

Build tool maintainers: make it possible for IDEs to support your tool! E.g., implement https://clang.llvm.org/docs/JSONCompilationDatabase.html[JSON Compilation Database] output so that IDEs can read the exact compiler commands from that, in order to automatically determine how files should be parsed! Or better, just use libllvm in your IDE itself as the main parser.

Ciro is evaluating some IDEs at: https://github.com/cirosantilli/ide-test-projects

= Vim
{c}
{parent=Integrated development environment}
{wiki=Vim_(text_editor)}

Before we get a decent open source <integrated development environment>, what else can you do?

But also perfect for small one-off files when you don't have the patience to setup said <IDE>.

vim's defaults are atrocious for the 21st century! Vundle is reasonable as an ad-hoc package manager, but it can't set fixed versions of packages:
* https://stackoverflow.com/questions/15259868/vundle-plugin-install-concrete-version-of-plugin/67870413#67870413
* https://github.com/VundleVim/Vundle.vim/pull/681

= vader.vim
{parent=Integrated development environment}

https://github.com/junegunn/vader.vim

Vimscript unit testing!!!

= plasticboy/vim-markdown
{parent=vader.vim}

https://github.com/plasticboy/vim-markdown

<Ciro Santilli> contributed a bit to this, and was even given push rights, see also: see also: <Ciro Santilli's minor projects>.

= honza/vim-snippets
{parent=vader.vim}

https://github.com/honza/vim-snippets

= Vimium
{parent=vader.vim}

https://vimium.github.io/

Since you can't escape <shitty> browser <GUIs> and live in the command line, the next best thing you can do is to bring Vim bindings to your browser :-)

There is one major annoyance: you can't use ESC to leave the address bar focus, but using Tab as a workaround works:
* https://superuser.com/a/1560178/128124

= Killer application
{parent=Software}
{wiki}

= Killer app
{synonym}

= Memory management
{parent=Software}
{wiki}

= Garbage collection
{disambiguate=computer science}
{parent=Software}
{wiki}

= Garbage collection
{synonym}

\Include[messaging-software]{parent=software}

= Multimedia software
{parent=Software}

= FFmpeg
{c}
{parent=Multimedia software}
{wiki}

FFmpeg is the <assembler (computing)> of audio and video.

As a result, <Ciro Santilli> who likes "lower level stuff", has had many many hours if image manipulation fun with this software, see e.g.:
* the "Media" section of <articles>.
* <image Ciro knows how to convert videos to GIFs>

As older Ciro grows, the more he notices that FFmpeg can do basically any lower level audio video task. It is just an amazing piece of software, the immediate go-to for any low level operation.

FFmpeg was created by <Fabrice Bellard>, which Ciro deeply respects.

Resize a video: https://superuser.com/questions/624563/how-to-resize-a-video-to-make-it-smaller-with-ffmpeg[]:
``
ffmpeg -i input.avi -filter:v scale=720:-1 -c:a copy output.mkv
``
Unlike every other convention under the sun, the height in `scale` is the first number.

= FFmpeg is the backend of YouTube
{c}
{parent=FFmpeg}

FFmpeg is likely the backend of <YouTube> through <reverse engineering>: https://streaminglearningcenter.com/blogs/youtube-uses-ffmpeg-for-encoding.html (https://web.archive.org/web/20190519135210/https://streaminglearningcenter.com/blogs/youtube-uses-ffmpeg-for-encoding.html[archive])

On <Quora>: https://www.quora.com/What-does-YouTube-use-for-encoding-video/answer/Ciro-Santilli

= Concatenate two videos with ffmpeg
{parent=FFmpeg}

https://stackoverflow.com/questions/7333232/how-to-concatenate-two-mp4-files-using-ffmpeg

= ImageMagick
{c}
{parent=Multimedia software}
{wiki}

Crop `20` pixels from the bottom of the image:
``
convert image.png -gravity East -chop 20x0 result.png
``

= Join two images side-by-side
{parent=ImageMagick}

https://stackoverflow.com/questions/20737061/merge-images-side-by-sidehorizontally/63575228#63575228

= Open source software
{parent=Software}
{wiki}

= Open source
{synonym}

What happens when https://en.wikipedia.org/wiki/OpenCL[the underdogs] get https://stackoverflow.com/questions/1780599/what-is-the-meaning-of-posix/31865755#31865755[together] and try to factor out their efforts to beat some https://en.wikipedia.org/wiki/CUDA[evil] dominant <Microsoft Windows>[power], sometimes <Linux>[victoriously].

Or when https://github.com/facebook[startups] use the cheapest stuff available and randomly become the https://github.com/google[next big thing], and decide to keep maintaining the open stuff to get features for free from other companies, or because they are <Linux>[forced by the Holy GPL].

Open source frees employees. When you change jobs, a large part of the specific knowledge you acquired about closed source a project with your blood and tears goes to the trash. When companies get bought, projects get shut down, and closed source code goes to the trash. What sane non desperate person would sell their life energy into such closed source projects that could die at any moment? Working on open source is the single most important non money perk a company can have to attract the best employees.

Open source is worth more than the mere pragmatic financial value of not having to pay for software or the ability to freely add new features.

Its greatest value is perhaps the fact that it allows people study it, to appreciate the beauty of the code, and feel empowered by being able to add the features that they want.

That is why <Ciro Santilli> thought:
\Q[Life is too short for closed source.]

But quoting Ciro's colleague S.:
\Q[Every software is open source when you read https://en.wikipedia.org/wiki/Assembly_language[assembly code].]

And https://computergraphics.stackexchange.com/questions/7809/what-does-gpu-assembly-look-like["can <reverse engineering>[reverse engineer] the undocumented GPU hardware APIs"], <Ciro Santilli>[Ciro] would add.

While software is the most developed open source technology available in the 2010's, due to the https://www.vox.com/recode/2019/6/24/18715421/internet-free-data-ads-cost["zero cost"] of copying it over the Internet, Ciro also believes that <open knowledge>[the world would benefit enormously from open source knowledge in all areas on science and engineering], for the same reasons as open source.

= Free and open-source software
{parent=Open source software}
{wiki}

= FOSS
{c}
{synonym}
{title2}

A more precise term for those in the know: <open source software> that also has a liberal license, for some definition of liberal.

<Ciro Santilli> defines liberal as: "can be commercialized without paying anything back" (but possibly subject to other restrictions).

He therefore does not consider <Creative Commons licenses> with NC to be FOSS.

For the newbs, the term <open source software> is good enough, since most open source software is also FOSS.

But when it's not, it's crucial to know.

= Models for financing open source software
{parent=Free and open-source software}

* <sponsorware>{child}

= Software developer collective
{parent=Models for financing open source software}

This model can work well when there is a set of commonly used libraries that some developers often use together, but such that there isn't enough maintenance work for each one individually.

So what people do is to create a group that maintains all those projects, to try and get enough money to survive from the contributions done primarily for each one individually.

Examples:
* https://github.com/pmndrs

= Open source software that is not-FOSS
{parent=Free and open-source software}
{wiki}

* <GitLab>{child}

= Source code leaks
{parent=Open source software}

* <Nintendo>
  * 2020-05-04 leaks via the BroadOn company
  * items
    * Wii <Verilog>
  * coverage
    * https://www.ladbible.com/technology/gaming-the-biggest-nintendo-hack-in-history-leaks-console-source-codes-20200504
  * fake leak commentary
    * "Sebastian" is apparently reuploaded devkit demos claiming that they are from this leak, if that is correct, <fuck> him:
      * https://www.youtube.com/watch?v=6FSOFrgbi4I&lc=UgwWEWT3oyxf85J0PQB4AaABAg
      * https://www.youtube.com/watch?v=teRRcouGxwc&list=PL8Yms2YDl4qOXI99jpI8oH75d3X2oxnBM&index=14

= Open knowledge
{parent=Open source software}
{wiki}

<Ciro Santilli>'s raison d'etre, one of his attempts: <OurBigBook.com>.

The outcome of closed knowledge is <reverse engineering>.

= Open educational resources
{parent=Open knowledge}
{title2=OER}
{wiki}

Projects:
* <MIT OpenCourseWare>
* several <e-learning websites>, e.g. <OpenStax>

= Horrors of open source
{parent=Open source software}

Not everything is perfect.

One big problem of many big open source projects is that they are contributed to by separate selfish organizations, that have private information. Then what happens is that:
* people implement the same thing twice, or one change makes the other completely unmergeable
* you get bugs but can't share your closed source test cases, and then you can't automate tests for them, or clearly demonstrate the problem
* other contributors don't see your full semi secret important motivation, and may either nitpick too much or take too long to review your stuff

Another common difficulty is that open source maintainers may simply not care enough about their own project (maybe they did in the past but lost interest) to review external patches by people they don't know.

This is understandable: a new patch, is a new risk of things breaking.

Therefore, if you ever submit patches and they get ignore, don't be too sad. It just comes down to a question of maintenance cost, and means that you will waste some extra time on the next rebase. You just have to decide your goals and be cold about it:
* are you doing the right thing and going for a specific goal <backward design>? Then just fork, run as fast as possible towards a minimum viable product, and if you start to feel that rebase is costing you a lot, or feel you could get some open source fame for cheap, open reviews and see what upstream says. If they ignore you, politely tell yourself in your mind silently "<fuck> them", and carry on with the MVP
* otherwise, e.g. you just want to randomly help out, you have to ask them before doing anything big "how can I be of help". If I propose a patch for this issue, do you promise to review it?

Writing documentation in an open source project in which you don't have immediate push rights is another major pain due to code reviews. Code code reviews tend to be much less subjective, because if you do something wrong, stuff crashes, runs slower, or you need more lines of code to reach the same goal. There are tradeoffs, but in a limited number. Documentation code reviews on the other hand, are an open invitation to https://en.wikipedia.org/wiki/Law_of_triviality[infinite bike-shedding], since you can't "run" documentation through a standardized <brain>[brain model]. Much better is for one good documenter person to just make one cohesive <Stack Overflow> post, and ping others with more knowledge to review details or add any missing pieces :-)

= Code drop
{parent=Open source software}

<Open source> development model in which developers develop in private, and only release code to the public during releases.

Notable example project: <Android Open Source Project>.

This development model basically makes reporting bugs and sending patches a waste of time, because many of them will already have been solved, which is why this development model is <evil>{parent}.

= Closed source is less bad on online services
{parent=Open source software}

<Ciro Santilli> can accept closed source on <server> products more easily than offline, because the servers have to be paid for somehow (by stealing your private data).

= Closed source offline software used by millions
{parent=Closed source is less bad on online services}

Closed source on offline products used by millions of people is <evil>, when you could just have those for free with <open source software>! Thus Ciro's hatred for <Microsoft Windows>{child} and <MacOS>{child} (at <is the MacOS kernel open source?>[least userland, maybe]).

= Closed source software
{parent=Open source software}

= Closed source
{synonym}

The opposite of <open source software>.

= Closed standard
{parent=Closed source software}

<ISO> is the main culprit of this <bullshit>, some notable examples related to <open source software>:
* <ANSI C>
* <SQL standard>
* <Verilog>

The only low level thing that escaped this was <OpenGL> via <Khronos>, what heroes those people are.

How the hell are you supposed to develop an open source implementation of something that has a closed standard?

Not to mention open source test suites, that would be way too much to ask for, those always end up being made by some shady small companies that go bankrupt from time to time, see e.g. .

= International Organization for Standardization
{c}
{parent=Closed standard}
{wiki}

= ISO
{c}
{synonym}

= Inner source
{parent=Closed source software}
{wiki}

If you are going to do <closed source>, at least do it like this.

Basically the opposite of <need to know> for <software>.

= Personal information management
{parent=Software}
{wiki}

= Productivity software
{parent=Software}
{wiki}

= LibreOffice
{c}
{parent=Productivity software}
{wiki}

These people are heroes. There's nothing else to say.

= Program optimization
{parent=Software}
{wiki}

= Benchmark
{parent=Program optimization}
{wiki}

= Profiling
{disambiguate=computer programming}
{parent=Program optimization}
{wiki}

= Profile
{disambiguate=computer programming}
{synonym}

\Include[programming-language]{parent=software}

= Recreational programming
{parent=Software}

= Code golf
{parent=Recreational programming}
{wiki}

= Search engine
{parent=Software}
{wiki}

= Reverse image search
{parent=Software}
{wiki}

= Scientific computing
{parent=Software}
{wiki}

= Computer simulation
{parent=Scientific computing}
{wiki}

= Computer algebra system
{parent=Scientific computing}
{wiki}

= SymPy
{parent=Computer algebra system}
{wiki}

This is the dream <exam>[cheating] software every student should know about.

It also has serious applications obviously. https://www.sympy.org/scipy-2017-codegen-tutorial/ mentions <code generation> capabilities, which sounds super cool!

The code in this section was tested on `sympy==1.8` and <Python> 3.9.5.

Let's start with some basics. <fractions>:
``
from sympy import *
sympify(2)/3 + sympify(1)/2
``
outputs:
``
7/6
``
Note that this is an exact value, it does not get converted to <floating-point numbers> where precision could be lost!

We can also do everything with symbols:
``
from sympy import *
x, y = symbols('x y')
expr = x/3 + y/2
print(expr)
``
outputs:
``
x/3 + y/2
``
We can now evaluate that expression object at any time:
``
expr.subs({x: 1, y: 2})
``
outputs:
``
4/3
``

How about a square root?
``
x = sqrt(2)
print(x)
``
outputs:
``
sqrt(2)
``
so we understand that the value was kept without simplification. And of course:
``
sqrt(2)**2
``
outputs `2`. Also:
``
sqrt(-1)
``
outputs:
``
I
``
`I` is the <imaginary unit>. We can use that symbol directly as well, e.g.:
``
I*I
``
gives:
``
-1
``

Let's do some trigonometry:
``
cos(pi)
``
gives:
``
-1
``
and:
``
cos(pi/4)
``
gives:
``
sqrt(2)/2
``
The exponential also works:
``
exp(I*pi)
``
gives;
``
-1
``

Now for some <calculus>. To find the <derivative> of the <natural logarithm>:
``
from sympy import *
x = symbols('x')
diff(ln(x), x)
``
outputs:
``
1/x
``
Just read that. One over x. Beauty.

Let's do some more. Let's solve a simple <differential equation>:
``
y''(t) - 2y'(t) + y(t) = sin(t)
``
Doing:
``
from sympy import *
x = symbols('x')
f, g = symbols('f g', cls=Function)
diffeq = Eq(f(x).diff(x, x) - 2*f(x).diff(x) + f(x), sin(x)**4)
print(dsolve(diffeq, f(x)))
``
outputs:
``
Eq(f(x), (C1 + C2*x)*exp(x) + cos(x)/2)
``
which means:
$$
f(x) = C_1 + C_2x e^x + cos(x)/2
$$
To be fair though, it can't do anything crazy, it likely just goes over known patterns that it has solvers for, e.g. if we change it to:
``
diffeq = Eq(f(x).diff(x, x)**2 + f(x), 0)
``
it just blows up:
``
NotImplementedError: solve: Cannot solve f(x) + Derivative(f(x), (x, 2))**2
``
Sad.

Let's try some <polynomial equations>:
``
from sympy import *
x, a, b, c = symbols('x a b c d e f')
eq = Eq(a*x**2 + b*x + c, 0)
sol = solveset(eq, x)
print(sol)
``
which outputs:
``
FiniteSet(-b/(2*a) - sqrt(-4*a*c + b**2)/(2*a), -b/(2*a) + sqrt(-4*a*c + b**2)/(2*a))
``
which is a not amazingly nice version of the <quadratic formula>. Let's evaluate with some specific constants after the fact:
``
sol.subs({a: 1, b: 2, c: 3})
``
which outputs
``
FiniteSet(-1 + sqrt(2)*I, -1 - sqrt(2)*I)
``
Let's see if it handles the <quartic equation>:
``
x, a, b, c, d, e, f = symbols('x a b c d e f')
eq = Eq(e*x**4 + d*x**3 + c*x**2 + b*x + a, 0)
solveset(eq, x)
``
Something comes out. It takes up the entire terimnal. Naughty. And now let's try to <Abel-Ruffini theorem>[mess with it]:
``
x, a, b, c, d, e, f = symbols('x a b c d e f')
eq = Eq(f*x**5 + e*x**4 + d*x**3 + c*x**2 + b*x + a, 0)
solveset(eq, x)
``
and this time it spits out something more magic:
``
ConditionSet(x, Eq(a + b*x + c*x**2 + d*x**3 + e*x**4 + f*x**5, 0), Complexes)
``
Oh well.

Let's try some <linear algebra>.
``
m = Matrix([[1, 2], [3, 4]])
``
Let's invert it:
``
m**-1
``
outputs:
``
Matrix([
[ -2,    1],
[3/2, -1/2]])
``

= Scientific visualization software
{parent=Scientific computing}

https://en.wikipedia.org/wiki/Scientific_visualization

<Ciro Santilli>[Ciro's] large dataset survey: <Survey of open source interactive plotting software with a 10 million point scatter plot benchmark by Ciro Santilli>{full}.

= Open source scientific computing consultancies
{parent=Scientific visualization software}

Huge respect to this companies.

= Enthought
{c}
{parent=Open source scientific computing consultancies}
{wiki}

= Kitware
{c}
{parent=Open source scientific computing consultancies}
{wiki}

= Plotting software
{parent=Scientific visualization software}

= Survey of open source interactive plotting software with a 10 million point scatter plot benchmark by Ciro Santilli
{c}
{parent=Plotting software}

https://stackoverflow.com/questions/5854515/large-plot-20-million-samples-gigabytes-of-data/55967461#55967461

By <Ciro Santilli>.

\Image[https://raw.githubusercontent.com/cirosantilli/media/master/VisIt_zoom_in_10_million_straight_line_plot_with_some_marked_points.png]
{source=https://stackoverflow.com/questions/5854515/large-plot-20-million-samples-gigabytes-of-data/55967461#55967461}

= Matplotlib
{c}
{parent=Plotting software}
{wiki}

It does a huge percentage of what you want easily, and from <Python>[the language that you want to use].

Tends to be <Ciro Santilli>[Ciro]'s pick if <gnuplot> can't handle the use case, or if the project is really really serious.

Couldn't handle exploration of large datasets though: <Survey of open source interactive plotting software with a 10 million point scatter plot benchmark by Ciro Santilli>

Examples:
* \a[matplotlib/hello.py]
* \a[matplotlib/educational2d.py]
* \a[matplotlib/axis.py]
* \a[matplotlib/label.py]
* Line style
  * \a[matplotlib/line_points.py]
  * \a[matplotlib/tick.py]
  * \a[matplotlib/prop_cycle.py]
* Subplots
  * \a[matplotlib/subplots.py]
  * \a[matplotlib/subplots_add.py]
* \a[matplotlib/two_lines.py]
  * \a[matplotlib/plot_matrix.py]
  * \a[matplotlib/plot_matrix_x.py]
  * \a[matplotlib/legend_outside.py]
* Data from files
  * \a[matplotlib/plotfile.py]
* Specialized
  * \a[matplotlib/bloch_sphere_walk.py]
  * \a[matplotlib/bloch_sphere.py]

= gnuplot
{c}
{parent=Plotting software}
{wiki=Gnuplot}

Tends to be <Ciro Santilli>'s first attempt for quick and dirty graphing: https://github.com/cirosantilli/gnuplot-cheat[].

<domain-specific language>. When it get the jobs done, it is in 3 lines and it feels great.

When it doesn't, you Google for an hours, and then you give up in frustration, and fall back to <Matplotlib>.

Couldn't handle exploration of large datasets though: <Survey of open source interactive plotting software with a 10 million point scatter plot benchmark by Ciro Santilli>

= Software bug
{parent=Software}
{wiki}

= Glitch
{parent=Software bug}
{wiki}

A glitch is more precisely a <software bug> that is hard to reproduce. But it has also been used to mean a software bug that is not very serious.

= Debugging
{parent=Software bug}
{wiki}

Debugging sucks. But there's also nothing quite that "oh fuck, that's why it doesn't work" moment, which happens after you have examined and placed everything that is relevant to the problem into your brain. You just can't see it coming. It just happens. You just learn what you generally have to look at so it happens faster.

Related:
* <keep debug notes>{child}

= Bisection
{disambiguate=software engineering}
{parent=Debugging}

One of the Holiest age old debugging techniques!

<Git> has some helpers to help you achieve bisection Nirvana: https://stackoverflow.com/questions/4713088/how-to-use-git-bisect/22592593#22592593

Obviously not restricted to software engineering alone, and used in all areas of engineering, e.g. <video Air-tight vs. Vacuum-tight by AlphaPhoenix (2020)> uses it in <vacuum engineering>.

The cool thing about bisection is that it is a brainless process: unlike when using a <debugger>, you don't have to understand anything about the system, and it incredibly narrows down the problem cause for you. Not having to think is great!

= Debugger
{parent=Debugging}
{wiki}

= Step debugger
{synonym}

= GNU Debugger
{c}
{parent=Debugger}

= GDB
{c}
{synonym}
{title2}

= GDB step debug
{c}
{synonym}

Just add <GDB Dashboard>, and you're good to go.

= Reverse debugging
{parent=GNU Debugger}

Nirvana!!!

The best open source implementation as of 2020 seems to be: <Mozilla rr>.

* https://stackoverflow.com/questions/1206872/go-to-previous-line-in-gdb/46996380#46996380
* https://stackoverflow.com/questions/1470434/how-does-reverse-debugging-work/53063242#53063242
* https://stackoverflow.com/questions/3649468/setting-breakpoint-in-gdb-where-the-function-returns/46116927#46116927
* https://stackoverflow.com/questions/27770896/how-to-debug-a-rare-deadlock/50073993#50073993
* https://stackoverflow.com/questions/522619/how-to-do-bidirectional-or-reverse-debugging-of-programs/50074106#50074106 link only, marked as duplicate of go to previous line
* https://softwareengineering.stackexchange.com/questions/181527/why-is-reverse-debugging-rarely-used

= Mozilla rr
{c}
{parent=Reverse debugging}

https://github.com/mozilla/rr

= GDB Dashboard
{c}
{parent=GNU Debugger}

https://github.com/cyrus-and/gdb-dashboard

<GDB> Nirvana?

https://stackoverflow.com/questions/10115540/gdb-split-view-with-code/51301717#51301717

\Image[https://web.archive.org/web/20200504130959if_/https://i.stack.imgur.com/mHC8f.png]
{height=600}
{title=Screenshot of terminal running GDB Dashboard}
{source=https://github.com/cyrus-and/gdb-dashboard/tree/2d31a3b391e5d0e032b791e1fb7172338b02cecb}

= Minimal working example
{parent=Software bug}
{wiki}

The <musical study> of <software engineering>.

<Ciro Santilli> is obsessed by those in order to learn any new concept, not just for bug reporting.

This includes to learn more theoretical subjects like <physics> and <mathematics>.

= Software company
{parent=Software}
{tag=Company}
{wiki}

\Include[microsoft]{parent=Software company}

= Oracle Corporation
{c}
{parent=Software company}
{wiki}

= Oracle
{c}
{synonym}

<Evil> company that desecrated the beauty created by <Sun Microsystems>, and was https://en.wikipedia.org/wiki/Google_v._Oracle_America[trying to bury Java once and or all in the 2010's].

Their database is already matched by <open source> e.g. <PostgreSQL>, and https://en.wikipedia.org/wiki/Enterprise_resource_planning[ERP] and https://en.wikipedia.org/wiki/Customer_relationship_management[CRM] specific systems are boring.

Oracle basically grew out of selling one of the first <SQL> implementations in the late 70's, and notably to the <United States Government> and particularly the <CIA>. They did deliver a lot of value in those early pre-internet days, but now <open source> is and will supplant them entirely.

= Sun Microsystems
{c}
{parent=Oracle Corporation}
{tag=Computer company}
{wiki}

Although <Ciro Santilli> is a bit past their era, there's an aura of technical excellence about those people. It just seems that they sucked at business. Those open source hippies. Erm, wait.

Bibliography:
* https://archive.org/details/sunburstascentof00hall Sunburst: the ascent of Sun Microsystems by Mark Hall (1990)

= Software documentation
{parent=Software}
{wiki}

= README
{c}
{parent=Software documentation}
{wiki}

Please, use <AsciiDoc> and <one page to rule them all>.

= Software engineering
{parent=Software}
{wiki}

= Software development
{parent=Software engineering}
{wiki}

= Software development principle
{parent=Software development}

= Don't repeat yourself
{parent=Software development principle}
{wiki}

= Yet another
{parent=Don't repeat yourself}
{wiki}

The mandatory <xkcd>: <xkcd 927: Standards>.

= DRY
{c}
{synonym}

= Ciro Santilli's software engineering wisdom
{c}
{parent=Software engineering}
{tag=Essays by Ciro Santilli}

Of course, "<Ciro Santilli>" with quotes, since all of those are either taken directly from others, or had been previously formulated by others.

= Excessive encapsulation is the root of much evil
{parent=Ciro Santilli's software engineering wisdom}

Some anecdotes.

<Ciro Santilli> never splits up functions unless there is more than one calling point. If you split early, the chances that the interface will be wrong are huge, and a much larger refactoring follows.

If you just want to separate variables, just use a scope e.g.:

``
int cross_block_var;

// First step.
{
    int myvar;
}

// Second step.
{
    int myvar;
}
``

Ciro has seen and had to deal with in his lifetime with two projects that had like 3 to 10 git separate Git repositories, all created and maintained by the same small group of developers of the same organization, even though one could not build without the other. Keeping everything in sync was Hell! Why not just have three directories inside a single repository with a single source of truth?

Another important case: <Linux> should have at least a C standard library, init system, and shell in-tree, like <BSD Operating Systems>, as mentioned at: <Linux>{full}.

= The development cycle time is your God
{parent=Ciro Santilli's software engineering wisdom}

A slow development test cycle will kill your software.

New developers won't want to learn your project, because they would rather shoot themselves.

This means that build time, and the time to run tests, must be short.

5 seconds to rebuild is the maximum upper limit.

Of course, at some point software gets large enough that things won't fit anymore in 5 seconds. But then you \i[must] have either some kind of build caching, or options to do partial builds/tests that will bring things down to that 5 second mark.

You also have to spend some time profiling execution and build from scratch times.

A slow build from scratch will mean that your <continuous integration> costs a lot, money that could be invested in a new developer!

It also means that people won't bother to reproduce bugs on given commits, or <bisection (software engineering)>[bisect stuff].

One anecdote comes to mind. <Ciro Santilli> was trying to debug something, and more experience colleague came over.

To reproduce a problem, ciro was running one command, wait 5 seconds, run a second command, wait 5 seconds, run a third command:
``
cmd1
# wait 5 seconds
cmd2
# wait 5 seconds
cmd3
``

The first thing the colleague said: join those three commands into one:
``
cmd1;cmd2;cmd3
``
And so, <the correlation between software engineers and Buddhism>[Ciro was enlightened].

= Everything that is not tested breaks
{parent=Ciro Santilli's software engineering wisdom}

= Everything can break everything
{parent=Ciro Santilli's software engineering wisdom}

Whenever someone asks:
\Q[I can only see this one thing different our setups, do you think it could be the cause of our different behaviour?]
you don't need to read anymore, just point them to this page immediately. <Virtualization> for the win.

= Fix it twice
{parent=Ciro Santilli's software engineering wisdom}

= You aren't gonna need it
{parent=Ciro Santilli's software engineering wisdom}
{wiki}

= YAGNI
{c}
{synonym}
{title2}

Sometimes you are really certain that something is a required substep for another thing that is coming right afterwards. 

When things are this concrete, fine, just do the substep.

But you have to always beware of cases where "I'm sure this will be needed at some unspecified point in the future", because such points tends to never happen.

YAGNI is so fundamental, there are several closely related concepts to it:
* <backward design>
* <assign the hard task to the lazy person>

= KISS principle
{c}
{parent=Ciro Santilli's software engineering wisdom}
{tag=Simplicity is the ultimate sophistication}
{wiki}

= Keep it simple, stupid
{synonym}
{title2}

The software engineer phrasing of <simplicity is the ultimate sophistication>.

Like all other principles, it is not absolute.

But it is something that you should always have on the back of your mind.

<you aren't gonna need it> is closely related, as generally the extra unnecessary complications are set in place to accommodate useless features that will never be needed.

= Hofstadter's law
{c}
{parent=Ciro Santilli's software engineering wisdom}
{wiki}

= It is impossible to predict how long it will take to do something
{synonym}

The trivial takes a few hours.

The easy takes a week.

And what seemed hard takes a few hours.

As "deadlines" approach, feature sets get cut down, then there are delays, and finally a feasible feature set is delivered some time after the deadline.

The only deadlines that can be met are those of tasks which have already been done but not announced.

This is of course <Hofstadter's law>.

On the other hand, it is also known that the time it takes for a task to be done expands without limits to match the deadline. And therefore, without deadlines, tasks will take forever and never get done.

And so, in a moment, perceiving <Koan>[this paradox], <the correlation between software engineers and Buddhism>[Ciro was enlightened].

= Brooks's law
{parent=Ciro Santilli's software engineering wisdom}
{wiki}

= Sometimes you can debug software by staring at the code for long enough
{parent=Ciro Santilli's software engineering wisdom}
{wiki}

Once upon a time, when <Ciro Santilli> had a job, he had a programming problem.

A senior developer came over, and rather than trying to run and modify the code like an idiot, which is what <Ciro Santilli> usually does (see also experimentalism remarks at <Ciro Santilli's bad old event memory>{full}), he just stared at the code for about 10 minutes.

We knew that the problem was likely in a particular function, but it was really hard to see why things were going wrong.

After the 10 minutes of examining every line in minute detail, he said:
\Q[I think this function call has such or such weird edge case]
and truly, that was the cause.

And so, <the correlation between software engineers and Buddhism>[Ciro was enlightened].

= Office space design and remote work
{parent=Ciro Santilli's software engineering wisdom}

Working remotely is hard if you don't already highly master the software and enterprise systems used.

Also you don't feel people's love as strongly, and usefulness is built on love, see also <Steve Jobs>'s Pixar office space design philosophy.

But please, give workers a small silent office so that we can concentrate instead of a silly open space, and create an internal social network so people can see what others are doing.

Remote working is much better if the majority of the team also does it, otherwise you will get excluded. Maybe after VR...

= Keep debug notes
{parent=Ciro Santilli's software engineering wisdom}

When <debugging> complex software, make sure to keep notes of every interesting find you make in a note file, as you extract it from the <integrated development environment> or <debugger>.

Especially if your <Ciro Santilli's bad old event memory>[memory sucks like Ciro's].

This is incredibly helpful in fully understanding and then solving complex bugs.

= "Hello, World!" program
{parent=Software engineering}
{wiki}

= Hello world
{synonym}

The most important <program> ever written!!!

Other programs that can be considered "hello worlds" in different contexts:

* <web development>
  * <A blog in every web framework>
* <video game>
  * Doom is the hello world <shooter game>

= Time to Hello World
{parent="Hello, World!" program}

= Software engineer
{parent=Software engineering}
{wiki}

= Programmer
{synonym}

Poet warriors monkeys? Or Code peasants (https://baike.baidu.com/item/码农/10262742[码农]) according to the Chinese.

<Ciro Santilli> claims to be one of them.

Much like a pianist plays his piano, a software engineer plays his <computer>.

= Software engineer stereotype
{parent=Software engineer}

= Correlation between sofware engineers and Asian fetish
{parent=Software engineer stereotype}
{tag=Asian fetish}

https://www.quora.com/Why-do-successful-geeky-white-men-have-Asian-wives-This-seems-to-be-the-norm-in-Silicon-Valley says it is just an statistical inevitability.

= The correlation between software engineers and Buddhism
{parent=Software engineer stereotype}

= A correlation between software engineers and Buddhism
{synonym}

<Ciro Santilli> believes that there is a positive correlation between being a <software engineer>[software engineer] and liking <Buddhist>-like things.

Maybe it is linked to minimalism and <DRY>, which software engineers value so greatly.

Even Ciro had to try an unoriginal Buddhist joke intro in https://stackoverflow.com/questions/572897/how-does-javascript-prototype-work/23877420#23877420[one of this Stack Overflow answers].

Ciro also feels that his https://github.com/cirosantilli/linux-kernel-module-cheat/tree/e1d0a2fafbb35c9e65c1a8a0b6d46df3e9161461/userland["minimal reproducible example" scientific language/concept learning method obsession] of breaking things into tiny sub-problems has a strong link with <Koans>.

Other programmers are equally obsessed by koans:
* http://www.catb.org/~esr/writings/unix-koans/ "The Unix Koans of Master Foo - Rootless Root (无根的根)" by the legendary https://en.wikipedia.org/wiki/Eric_S._Raymond[Eric Steven Raymond] is notable
* http://thecodelesscode.com/ "The Codeless Code" by anonymous Qi.
* http://canonical.org/~kragen/tao-of-programming.html
* https://wiki.c2.com/?MysticalProgrammingKoans
* http://rubykoans.com/[] even <evil> programming languages adopt them!

Another thing that points the correlation out is the existence of https://wattsalan.github.io/ on a `github.io` about <Alan Watts>.

= List of software engineers
{parent=Software engineer}

= Aaron Swartz
{c}
{parent=List of software engineers}
{wiki}

Aaron, <Ciro Santilli> will complete <OurBigBook.com>[your quest to make eduction free]. Just <legally> this time, with the and with the <Creative Commons license> you helped to create.

Ciro likes how <The Internet's Own Boy (2014)> explains how Aaron felt like high school was <bullshit>, and that he could <autodidacticism>[learn whatever he wanted from books], <ourbigbook com/motivation>[which is one of Ciro's key feelings].

It also mentions how he was a natural teacher from a very early age.

= Guerilla Open Access Manifesto by Aaron Swartz (2008)
{c}
{parent=Aaron Swartz}
{wiki}

https://gist.github.com/briandoll/4522952

Hmmm, he does not know how to spell guerilla? <sic>? https://www.quora.com/What-is-the-correct-spelling-guerilla-or-guerrilla

Note to self: if you are going to commit a <crime>, don't publish your plans online.

<Ross Ulbricht>'s diaries come to mind.

That's how <Russian> <shadow library> maintainers do it, they know how to crime good old Russians. Maybe there is a good thing about having <dictatorships> in the world that give zero fucks about <American> copyright laws. There will always be some random <Russian> academic who will implement this and not go to jail. Maybe it's even <government>[state] sponsored.

= The Internet's Own Boy (2014)
{c}
{parent=Aaron Swartz}
{wiki}

= James Somers
{c}
{parent=List of software engineers}
{wiki}

* https://jsomers.net/
* https://www.linkedin.com/in/james-somers-4703364/

Huge interest overlap with <Ciro Santilli>, e.g. he's into
* <molecular biology> in general: <I should have loved biology by James Somers>
* <JCVI-syn3.0>: https://www.newyorker.com/magazine/2022/03/07/a-journey-to-the-center-of-our-cells
* <cryo-EM>: https://www.newyorker.com/magazine/2022/03/07/a-journey-to-the-center-of-our-cells
* <David Goodsell>: https://www.newyorker.com/magazine/2022/03/07/a-journey-to-the-center-of-our-cells
* <History of Google>: https://www.newyorker.com/magazine/2018/12/10/the-friendship-that-made-google-huge

= I should have loved biology by James Somers
{c}
{parent=James Somers}

https://jsomers.net/i-should-have-loved-biology/

This resonates a lot with <Ciro Santilli>'s ideas!
* <physics and the illusion of life>
* <physics education needs more focus on understanding experiments and their history>:
  * <there is value in tutorials written by early pioneers of the field>{full}
  * <doing physics means calculating a number>{full}
* <education is broken>
* <molecular biology feels like systems programming>
  \Q[I've never come across a subject so fractal in its complexity. It reminds me of computing that way.]

= Sandy Maguire
{c}
{parent=List of software engineers}
{wiki}

* https://sandymaguire.me
* https://github.com/isovector/

Lots of similar ideologies to <Ciro Santilli>, love it:
* https://sandymaguire.me/about/[]:
  * he's an <idealist>
  \Q[I might best be described somewhere between independent researcher and voluntarily-unemployed bum. At the ripe old age of 27 I decided to quit my highly-lucrative engineering job and decide to focus more on living than on grinding for the man. It's what you might call a work in progress.]
* https://sandymaguire.me/blog/reaching-climbing/[]: <don't be a pussy>
  \Q[Last Friday was my final day at work. According to my facebook profile, I am now "happily retired." As of today, I don't plan to do another day of "traditional work" in my life. That's not to say that I'll be sitting idle playing tiddly winks. I want to build things, to dedicate my life to independent study, and to get really, really good with building communities. I don't have time for any of this "work" stuff that somehow pervades our entire culture, choking our inspiration and sapping our energy away from the things we'd rather be doing.]
  One is also reminded of <Gwern Branwen>. Sandy is also into self-improvement stuff, so even more like Gwern. This is a point Ciro diverges on. Ciro works actively on self-worsening.
* he thinks <university> is useless:
  * https://sandymaguire.me/blog/where-uni-fails/ Where University Fails (2018), mostly talking about <backward design>
  * https://sandymaguire.me/blog/gatekept/ rejected from <Imperial College> <PhD> program due to <grade (exam)> being slightly too low for their stupid requirements, even though he had a referral already, and an amazing CV
* he likes <jazz>: https://sandymaguire.me/blog/too-smart/

Other interesting points:
* https://sandymaguire.me/blog/sandy-runback/ he changed his own name to Sandy because he didn't like it, he was born Alexander
* https://algebradriven.design/ <closed source> books though, ouch. At least they seem to have been made with <leanpub> though, could be worse.

He's a <Haskell> person.

= Dan Dascalescu
{c}
{parent=List of software engineers}

His website is down as of 2020, shame: https://wiki.dandascalescu.com/essays/english-universal-language

= English as a universal language by Dan Dascalescu (2008)
{c}
{parent=Dan Dascalescu}

https://wiki.dandascalescu.com/essays/english-universal-language

https://web.archive.org/web/20200317221752/https://wiki.dandascalescu.com/essays/english-universal-language

<Dan Dascalescu>'s version of <having more than one natural language is bad for the world>.

= Donald Knuth
{c}
{parent=List of software engineers}
{wiki}

= Knuth reward check
{c}
{parent=Donald Knuth}
{wiki}

* https://tex.stackexchange.com/questions/110586/327-68-knuth-reward-check
* https://www.quora.com/What-is-it-like-to-receive-a-Knuth-reward-check
* https://www-cs-faculty.stanford.edu/~knuth/boss.html

= Gwern Branwen
{c}
{parent=Software engineer}

A <LessWrong> person.

= gwern.net
{c}
{parent=Gwern Branwen}
{tag=The best personal webpages of all time}

https://www.gwern.net/

One thing that annoys <Ciro Santilli> about that website are the footnote overload. Ciro likes linear things.

= Richard Stallman
{c}
{parent=Software engineer}
{wiki}

TODO find the best source for the amazing "I have done your mother" quote.

= Tim O'Reilly
{c}
{parent=Software engineer}
{wiki}

= Computer programming
{parent=Software engineering}
{wiki}

= Programming
{synonym}

Programming is hard. To <Ciro Santilli>, it's almost masochistic.

What makes Ciro especially mad when programming is not the hard things.

It is the things that should be easy, but aren't, and which take up a lot of your programming time.

Especially when you are already a few levels of "simple problems" down from your original goal, and another one of them shows up.

This is basically the cause of <Hofstadter's law>.

But of course, it is because it is hard that it feels amazing when you achieve your goal.

Putting a complex and useful program together is like composing a symphony, or reaching the summit of a hard <rock climbing> proble.

= Software portability
{parent=Software}
{wiki}

= Porting
{parent=Software portability}
{wiki}

= Port
{disambiguate=software-portability}
{synonym}

= Software quality assurance
{parent=Software}
{wiki}

= Static program analysis
{parent=Software quality assurance}
{wiki}

= Linting
{parent=Static program analysis}
{wiki=Lint (software)}

= Linter
{synonym}

= Software testing
{parent=Software quality assurance}
{wiki}

= test_executables.js
{file}
{parent=Software testing}

This script tests all executables under a selected directory.

<Ciro Santilli> has been writing scripts of that type for a long time in order to test his <Ciro Santilli's documentation superpowers>[programming self-learning setups with asserts].

The most advanced of those being the https://github.com/cirosantilli/linux-kernel-module-cheat/blob/9b6552ab6c66cb14d531eff903c4e78f3561e9ca/test[test system] of <Linux Kernel Module Cheat>.

But had too much stuff that would be specific to that project, so Ciro decided to start this new one in <Node.js>, hopefully it will also be the last he ever writes.

A sample usage of the test library can be seen at: \a[nodejs/sequelize/test].

= Assertion
{disambiguate=software development}
{parent=Software testing}
{wiki}

= Continuous integration
{parent=Software testing}
{wiki}

= CI
{c}
{synonym}
{title2}

= Test driven development
{parent=Software testing}
{wiki}

This is a good approach. The downside is that while you are developing the implementation and testing interactively you might notice that the requirements are wrong, and then the tests have to change.

One intermediate approach <Ciro Santilli> likes is to do the implementation and be happy with interactive usage, then create the test, make it pass, then remove the code that would make it pass, and see it fail. This does have a risk that you will forget to test something, but Ciro finds it is a worth it generally. Unless it really is one of those features that you are unable to develop without an automated test, generally more "logical/mathematical" stuff. This is a sort of <laziness Driven Development>.

= Laziness Driven Development
{parent=Test driven development}

= Source code
{parent=Software}
{wiki}

= The best code is no code at all
{parent=Source code}

Some <blogs>:
* https://blog.codinghorror.com/the-best-code-is-no-code-at-all/ The Best Code is No Code At All (2007)
* http://www.skrenta.com/2007/05/code_is_our_enemy.html Code is our enemy (2007)

Also resonates with <backward design>.

= Use The Source Luke
{parent=Source code}

https://wiki.c2.com/?UseTheSourceLuke

\Include[systems-programming]{parent=software}

= Terminal emulator
{parent=Software}
{wiki}

Terminals don't really matter. Just use <tmux>.

= Yakuake
{parent=Terminal emulator}

https://github.com/KDE/yakuake

= Terminal multiplexer
{parent=Terminal emulator}
{wiki}

= tmux
{c}
{parent=Terminal multiplexer}
{wiki}

https://github.com/tmux/tmux

If session autosave was finally mainlined, this would be Nirvana.

= Version control
{parent=Software}
{wiki}

= Concurrent Versions System
{c}
{parent=Version control}
{title2=CSV}
{wiki}

It is said, that once upon a time, programmers used CSV and collaborated on <SourceForge>, and that everyone was happy.

These days, are however, long gone in the mists of time as of 2020, and beyond <Ciro Santilli>'s programming birth.

= Git
{c}
{parent=Version control}
{wiki}

= Git UI
{parent=Git}

Perfect Git integration belongs in <integrated development environments> :-)

= tig
{disambiguate=git UI}
{parent=Git UI}

https://github.com/jonas/tig

This is good. But it misses some key operations, so much so that makes Ciro not want to learn/use it daily.

= Pro Git book
{c}
{parent=Git}

https://github.com/progit/progit2

= libgit2
{c}
{parent=Git}

https://github.com/libgit2/libgit2

= libgit2/rugged
{c}
{parent=libgit2}

https://github.com/libgit2/rugged

= Git web interface
{c}
{parent=Git}

= GitHub
{c}
{parent=Git web interface}
{wiki}

This is where <Ciro Santilli> stored his code since he started coding nonstop in 2013.

He <closed source is less bad on online services>[does not like the closed source aspect of it], but hey, there are more important things to worry about, the network effect is just too strong.

= GitHub porn policy
{c}
{parent=GitHub}

https://www.quora.com/Does-github-allow-uploading-a-porn-image/answer/Ciro-Santilli

= GitHub users deleted by GitHub
{c}
{parent=GitHub}

https://stackoverflow.com/questions/50720844/can-github-delete-your-account/66105692#66105692

= GitHub Pages
{c}
{parent=GitHub}

https://pages.github.com/

The cheapest and most resilient way to publish <how to teach/text is cheaper than video>[text content] humanity has achieved so far.

= GitHub Sponsors
{c}
{parent=GitHub}

= Who are the developers that are making the most money through GitHub sponsors?
{c}
{parent=GitHub Sponsors}

https://github.com/isaacs/github/issues/1824

= Pull request
{parent=GitHub}

The heart/main innovation of GitHub!

= Octokat.js
{c}
{parent=GitHub}

https://github.com/philschatz/octokat.js

= octokit.js
{c}
{parent=Octokat.js}

https://github.com/philschatz/octokit.js

= GitLab
{c}
{parent=Git web interface}
{wiki}

GitLab was very important to Ciro because he wanted to base https://github.com/booktree/booktree[Booktree] on it.

See also: <Ciro Santilli's minor projects>.

= GitLab CI
{c}
{parent=GitLab}
{tag=Continuous integration}

https://github.com/gitlabhq/gitlab-ci

= GitLab cookbook
{c}
{parent=GitLab}

https://gitlab.com/gitlab-org/cookbook-gitlab

= SourceForge
{c}
{parent=Git web interface}
{wiki}

RIP: https://www.quora.com/Is-SourceForge-still-relevant-to-open-source-projects/answer/Ciro-Santilli

\Include[web-technology]{parent=software}

= Software bibliography
{parent=Software}

= EbookFoundation/free-programming-books
{parent=Software bibliography}

https://github.com/EbookFoundation/free-programming-books
